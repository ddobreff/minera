/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */
(function (global, factory) {
  if (typeof module === 'object' && typeof module.exports === 'object') {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('jQuery requires a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }  // Pass this if window is not defined yet
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  // Support: Firefox 18+
  // Can't be in strict mode, several libs including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  //
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var
    // Use the correct document accordingly with window argument (sandbox)
    document = window.document, version = '2.1.4',
    // Define a local copy of jQuery
    jQuery = function (selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },
    // Support: Android<4.1
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi,
    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: '',
    length: 0,
    toArray: function () {
      return slice.call(this);
    },
    get: function (num) {
      return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
    },
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems);
      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;
      ret.context = this.context;
      // Return the newly-formed element set
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      // Skip the boolean and the target
      target = arguments[i] || {};
      i++;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    // Extend jQuery itself if only one argument is passed
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];
          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }
          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            // Never move original objects, clone them
            target[name] = jQuery.extend(deep, clone, copy);  // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    // Return the modified object
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
    isReady: true,
    error: function (msg) {
      throw new Error(msg);
    },
    noop: function () {
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      // parseFloat NaNs numeric-cast false positives (null|true|false|"")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      // adding 1 corrects loss of precision from parseFloat (#15100)
      return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
    },
    isPlainObject: function (obj) {
      // Not plain objects:
      // - Any object or value whose internal [[Class]] property is not "[object Object]"
      // - DOM nodes
      // - window
      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return false;
      }
      // If the function hasn't returned already, we're confident that
      // |obj| is a plain object, created by {} or constructed with new Object
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function (obj) {
      if (obj == null) {
        return obj + '';
      }
      // Support: Android<4.0, iOS<6 (functionish RegExp)
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
    },
    globalEval: function (code) {
      var script, indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        // If the code includes a valid, prologue position
        // strict mode pragma, execute code by injecting a
        // script tag into the document.
        if (code.indexOf('use strict') === 1) {
          script = document.createElement('script');
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          // Otherwise, avoid the DOM node creation, insertion
          // and removal by using an indirect global eval
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }  // A special, fast, case for the most common use of each
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? '' : (text + '').replace(rtrim, '');
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var len = +second.length, j = 0, i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, invert) {
      var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
      // Go through the array, only saving the items
      // that pass the validator function
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      // Go through the array, translating each of the items to their new values
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }  // Go through every key on the object,
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      // Flatten any nested arrays
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      // Simulated bind
      args = slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  // Populate the class2type map
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    // Support: iOS 8.2 (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = 'length' in obj && obj.length, type = jQuery.type(obj);
    if (type === 'function' || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
  }
  var Sizzle = function (window) {
      var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate,
        // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
        // Instance-specific data
        expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        // General-purpose constants
        MAX_NEGATIVE = 1 << 31,
        // Instance methods
        hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function (list, elem) {
          var i = 0, len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
        // Regular expressions
        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = '[\\x20\\t\\r\\n\\f]',
        // http://www.w3.org/TR/css3-syntax/#characters
        characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+',
        // Loosely modeled on CSS identifier characters
        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = characterEncoding.replace('w', 'w#'),
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = '\\[' + whitespace + '*(' + characterEncoding + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)',
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
          'ID': new RegExp('^#(' + characterEncoding + ')'),
          'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
          'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
          'ATTR': new RegExp('^' + attributes),
          'PSEUDO': new RegExp('^' + pseudos),
          'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
          'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
          'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g,
        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
          var high = '0x' + escaped - 65536;
          // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        },
        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function () {
          setDocument();
        };
      // Optimize for push.apply( _, NodeList )
      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
        // Support: Android<4.0
        // Detect silently failing push.apply
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? function (target, els) {
            push_native.apply(target, slice.call(els));
          } : function (target, els) {
            var j = target.length, i = 0;
            // Can't trust NodeList.length
            while (target[j++] = els[i++]) {
            }
            target.length = j - 1;
          }
        };
      }
      function Sizzle(selector, context, results, seed) {
        var match, elem, m, nodeType,
          // QSA vars
          i, groups, old, nid, newContext, newSelector;
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        results = results || [];
        nodeType = context.nodeType;
        if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        }
        if (!seed && documentIsHTML) {
          // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // Speed-up: Sizzle("#ID")
            if (m = match[1]) {
              if (nodeType === 9) {
                elem = context.getElementById(m);
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document (jQuery #6963)
                if (elem && elem.parentNode) {
                  // Handle the case where IE, Opera, and Webkit return items
                  // by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                // Context is not a document
                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }  // Speed-up: Sizzle("TAG")
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;  // Speed-up: Sizzle(".CLASS")
            } else if ((m = match[3]) && support.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          // QSA path
          if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType !== 1 && selector;
            // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn't work on object elements
            if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
              groups = tokenize(selector);
              if (old = context.getAttribute('id')) {
                nid = old.replace(rescape, '\\$&');
              } else {
                context.setAttribute('id', nid);
              }
              nid = '[id=\'' + nid + '\'] ';
              i = groups.length;
              while (i--) {
                groups[i] = nid + toSelector(groups[i]);
              }
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              newSelector = groups.join(',');
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {
              } finally {
                if (!old) {
                  context.removeAttribute('id');
                }
              }
            }
          }
        }
        // All others
        return select(selector.replace(rtrim, '$1'), context, results, seed);
      }
      /**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
      function createCache() {
        var keys = [];
        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + ' ') > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }
          return cache[key + ' '] = value;
        }
        return cache;
      }
      /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      /**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
      function assert(fn) {
        var div = document.createElement('div');
        try {
          return !!fn(div);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
          // release memory in IE
          div = null;
        }
      }
      /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
      function addHandle(attrs, handler) {
        var arr = attrs.split('|'), i = attrs.length;
        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
      function siblingCheck(a, b) {
        var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
        // Use IE sourceIndex if available on both nodes
        if (diff) {
          return diff;
        }
        // Check if b follows a
        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }
        return a ? 1 : -1;
      }
      /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
      function createInputPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === type;
        };
      }
      /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
      function createButtonPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === 'input' || name === 'button') && elem.type === type;
        };
      }
      /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
      function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
          argument = +argument;
          return markFunction(function (seed, matches) {
            var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
            // Match elements found at the specified indexes
            while (i--) {
              if (seed[j = matchIndexes[i]]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }
      /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== 'undefined' && context;
      }
      // Expose support vars for convenience
      support = Sizzle.support = {};
      /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
      isXML = Sizzle.isXML = function (elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== 'HTML' : false;
      };
      /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
      setDocument = Sizzle.setDocument = function (node) {
        var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
        // If no document and documentElement is available, return
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }
        // Set our document
        document = doc;
        docElem = doc.documentElement;
        parent = doc.defaultView;
        // Support: IE>8
        // If iframe document is assigned to "document" variable and if iframe has been reloaded,
        // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
        // IE6-8 do not support the defaultView property so parent will be undefined
        if (parent && parent !== parent.top) {
          // IE11 does not have attachEvent, so all must suffer
          if (parent.addEventListener) {
            parent.addEventListener('unload', unloadHandler, false);
          } else if (parent.attachEvent) {
            parent.attachEvent('onunload', unloadHandler);
          }
        }
        /* Support tests
	---------------------------------------------------------------------- */
        documentIsHTML = !isXML(doc);
        /* Attributes
	---------------------------------------------------------------------- */
        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert(function (div) {
          div.className = 'i';
          return !div.getAttribute('className');
        });
        /* getElement(s)By*
	---------------------------------------------------------------------- */
        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert(function (div) {
          div.appendChild(doc.createComment(''));
          return !div.getElementsByTagName('*').length;
        });
        // Support: IE<9
        support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function (div) {
          docElem.appendChild(div).id = expando;
          return !doc.getElementsByName || !doc.getElementsByName(expando).length;
        });
        // ID find and filter
        if (support.getById) {
          Expr.find['ID'] = function (id, context) {
            if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
              var m = context.getElementById(id);
              // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document #6963
              return m && m.parentNode ? [m] : [];
            }
          };
          Expr.filter['ID'] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute('id') === attrId;
            };
          };
        } else {
          // Support: IE6/7
          // getElementById is not reliable as a find shortcut
          delete Expr.find['ID'];
          Expr.filter['ID'] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
              return node && node.value === attrId;
            };
          };
        }
        // Tag
        Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
          if (typeof context.getElementsByTagName !== 'undefined') {
            return context.getElementsByTagName(tag);  // DocumentFragment nodes don't have gEBTN
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function (tag, context) {
          var elem, tmp = [], i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
            results = context.getElementsByTagName(tag);
          // Filter out possible comments
          if (tag === '*') {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }
            return tmp;
          }
          return results;
        };
        // Class
        Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
          if (documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        /* QSA/matchesSelector
	---------------------------------------------------------------------- */
        // QSA and matchesSelector support
        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];
        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See http://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];
        if (support.qsa = rnative.test(doc.querySelectorAll)) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function (div) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            docElem.appendChild(div).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\f]\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
            // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
            if (div.querySelectorAll('[msallowcapture^=\'\']').length) {
              rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
            }
            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if (!div.querySelectorAll('[selected]').length) {
              rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
            }
            // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
            if (!div.querySelectorAll('[id~=' + expando + '-]').length) {
              rbuggyQSA.push('~=');
            }
            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if (!div.querySelectorAll(':checked').length) {
              rbuggyQSA.push(':checked');
            }
            // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibing-combinator selector` fails
            if (!div.querySelectorAll('a#' + expando + '+*').length) {
              rbuggyQSA.push('.#.+[+~]');
            }
          });
          assert(function (div) {
            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = doc.createElement('input');
            input.setAttribute('type', 'hidden');
            div.appendChild(input).setAttribute('name', 'D');
            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if (div.querySelectorAll('[name=d]').length) {
              rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
            }
            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if (!div.querySelectorAll(':enabled').length) {
              rbuggyQSA.push(':enabled', ':disabled');
            }
            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll('*,:x');
            rbuggyQSA.push(',.*:');
          });
        }
        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function (div) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(div, 'div');
            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call(div, '[s!=\'\']:x');
            rbuggyMatches.push('!=', pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
        /* Contains
	---------------------------------------------------------------------- */
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        // Element contains another
        // Purposefully does not implement inclusive descendent
        // As in, an element does not contain itself
        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }
          return false;
        };
        /* Sorting
	---------------------------------------------------------------------- */
        // Document order sorting
        sortOrder = hasCompare ? function (a, b) {
          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          // Sort on method existence if only one input has compareDocumentPosition
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }
          // Calculate position if both inputs belong to the same document
          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
          // Disconnected nodes
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            // Choose the first element that is related to our preferred document
            if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            }
            // Maintain original order
            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        } : function (a, b) {
          // Exit early if the nodes are identical
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
          // Parentless nodes are either documents or disconnected
          if (!aup || !bup) {
            return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;  // If the nodes are siblings, we can do a quick check
          } else if (aup === bup) {
            return siblingCheck(a, b);
          }
          // Otherwise we need full lists of their ancestors for comparison
          cur = a;
          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }
          cur = b;
          while (cur = cur.parentNode) {
            bp.unshift(cur);
          }
          // Walk down the tree looking for a discrepancy
          while (ap[i] === bp[i]) {
            i++;
          }
          return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
        };
        return doc;
      };
      Sizzle.matches = function (expr, elements) {
        return Sizzle(expr, null, null, elements);
      };
      Sizzle.matchesSelector = function (elem, expr) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        // Make sure that attribute selectors are quoted
        expr = expr.replace(rattributeQuotes, '=\'$1\']');
        if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            // IE 9's matchesSelector returns false on disconnected nodes
            if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {
          }
        }
        return Sizzle(expr, document, null, [elem]).length > 0;
      };
      Sizzle.contains = function (context, elem) {
        // Set document vars if needed
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };
      Sizzle.attr = function (elem, name) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };
      Sizzle.error = function (msg) {
        throw new Error('Syntax error, unrecognized expression: ' + msg);
      };
      /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
      Sizzle.uniqueSort = function (results) {
        var elem, duplicates = [], j = 0, i = 0;
        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }
        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;
        return results;
      };
      /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
      getText = Sizzle.getText = function (elem) {
        var node, ret = '', i = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while (node = elem[i++]) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === 'string') {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes
        return ret;
      };
      Expr = Sizzle.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          '>': {
            dir: 'parentNode',
            first: true
          },
          ' ': { dir: 'parentNode' },
          '+': {
            dir: 'previousSibling',
            first: true
          },
          '~': { dir: 'previousSibling' }
        },
        preFilter: {
          'ATTR': function (match) {
            match[1] = match[1].replace(runescape, funescape);
            // Move the given value to match[3] whether quoted or unquoted
            match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
            if (match[2] === '~=') {
              match[3] = ' ' + match[3] + ' ';
            }
            return match.slice(0, 4);
          },
          'CHILD': function (match) {
            /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === 'nth') {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              }
              // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
              match[5] = +(match[7] + match[8] || match[3] === 'odd');  // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }
            return match;
          },
          'PSEUDO': function (match) {
            var excess, unquoted = !match[6] && match[2];
            if (matchExpr['CHILD'].test(match[0])) {
              return null;
            }
            // Accept quoted arguments as-is
            if (match[3]) {
              match[2] = match[4] || match[5] || '';  // Strip excess characters from unquoted arguments
            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }
            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice(0, 3);
          }
        },
        filter: {
          'TAG': function (nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === '*' ? function () {
              return true;
            } : function (elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          'CLASS': function (className) {
            var pattern = classCache[className + ' '];
            return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
              return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
            });
          },
          'ATTR': function (name, operator, check) {
            return function (elem) {
              var result = Sizzle.attr(elem, name);
              if (result == null) {
                return operator === '!=';
              }
              if (!operator) {
                return true;
              }
              result += '';
              return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
            };
          },
          'CHILD': function (type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
            return first === 1 && last === 0 ? function (elem) {
              return !!elem.parentNode;
            } : function (elem, context, xml) {
              var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
              if (parent) {
                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;
                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    }
                    // Reverse direction for :only-* (if we haven't yet done so)
                    start = dir = type === 'only' && !start && 'nextSibling';
                  }
                  return true;
                }
                start = [forward ? parent.firstChild : parent.lastChild];
                // non-xml :nth-child(...) stores cache data on `parent`
                if (forward && useCache) {
                  // Seek `elem` from a previously-cached index
                  outerCache = parent[expando] || (parent[expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = cache[0] === dirruns && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    // When found, cache indexes on `parent` and break
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      outerCache[type] = [
                        dirruns,
                        nodeIndex,
                        diff
                      ];
                      break;
                    }
                  }  // Use previously-cached element index if available
                } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                  diff = cache[1];  // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                } else {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        (node[expando] || (node[expando] = {}))[type] = [
                          dirruns,
                          diff
                        ];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
                // Incorporate the offset, then check against cycle size
                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          'PSEUDO': function (pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if (fn[expando]) {
              return fn(argument);
            }
            // But maintain support for old signatures
            if (fn.length > 1) {
              args = [
                pseudo,
                pseudo,
                '',
                argument
              ];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                var idx, matched = fn(seed, argument), i = matched.length;
                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function (elem) {
                return fn(elem, 0, args);
              };
            }
            return fn;
          }
        },
        pseudos: {
          'not': markFunction(function (selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
              var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
              // Match elements unmatched by `matcher`
              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function (elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results);
              // Don't keep the element (issue #299)
              input[0] = null;
              return !results.pop();
            };
          }),
          'has': markFunction(function (selector) {
            return function (elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          'contains': markFunction(function (text) {
            text = text.replace(runescape, funescape);
            return function (elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),
          'lang': markFunction(function (lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || '')) {
              Sizzle.error('unsupported lang: ' + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;
              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          'target': function (elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          'root': function (elem) {
            return elem === docElem;
          },
          'focus': function (elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          'enabled': function (elem) {
            return elem.disabled === false;
          },
          'disabled': function (elem) {
            return elem.disabled === true;
          },
          'checked': function (elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
          },
          'selected': function (elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          'empty': function (elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          'parent': function (elem) {
            return !Expr.pseudos['empty'](elem);
          },
          'header': function (elem) {
            return rheader.test(elem.nodeName);
          },
          'input': function (elem) {
            return rinputs.test(elem.nodeName);
          },
          'button': function (elem) {
            var name = elem.nodeName.toLowerCase();
            return name === 'input' && elem.type === 'button' || name === 'button';
          },
          'text': function (elem) {
            var attr;
            return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
          },
          'first': createPositionalPseudo(function () {
            return [0];
          }),
          'last': createPositionalPseudo(function (matchIndexes, length) {
            return [length - 1];
          }),
          'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          'even': createPositionalPseudo(function (matchIndexes, length) {
            var i = 0;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          'odd': createPositionalPseudo(function (matchIndexes, length) {
            var i = 1;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; --i >= 0;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; ++i < length;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos['nth'] = Expr.pseudos['eq'];
      // Add button/input type pseudos
      for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in {
          submit: true,
          reset: true
        }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }
      // Easy API for creating new setFilters
      function setFilters() {
      }
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
        var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push(tokens = []);
          }
          matched = false;
          // Combinators
          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: match[0].replace(rtrim, ' ')
            });
            soFar = soFar.slice(matched.length);
          }
          // Filters
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
      };
      function toSelector(tokens) {
        var i = 0, len = tokens.length, selector = '';
        for (; i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }
      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
        return combinator.first ? function (elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }
        } : function (elem, context, xml) {
          var oldCache, outerCache, newCache = [
              dirruns,
              doneName
            ];
          // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  // Assign to newCache so results back-propagate to previous elements
                  return newCache[2] = oldCache[2];
                } else {
                  // Reuse newcache so results back-propagate to previous elements
                  outerCache[dir] = newCache;
                  // A match means we're done; a fail means we have to keep checking
                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }
        };
      }
      function elementMatcher(matchers) {
        return matchers.length > 1 ? function (elem, context, xml) {
          var i = matchers.length;
          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }
          return true;
        } : matchers[0];
      }
      function multipleContexts(selector, contexts, results) {
        var i = 0, len = contexts.length;
        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }
      function condense(unmatched, map, filter, context, xml) {
        var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
        for (; i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }
        return newUnmatched;
      }
      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function (seed, results, context, xml) {
          var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
            // Get initial elements from seed or context
            elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
          // Find primary matches
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }
          // Apply postFilter
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);
            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if (elem = matcherOut[i]) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push(matcherIn[i] = elem);
                  }
                }
                postFinder(null, matcherOut = [], temp, xml);
              }
              // Move matched elements from seed to results to keep them synchronized
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }  // Add elements to results, through postFinder if defined
          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }
      function matcherFromTokens(tokens) {
        var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(function (elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function (elem, context, xml) {
              var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              // Avoid hanging onto element (issue #299)
              checkContext = null;
              return ret;
            }];
        for (; i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
            // Return special upon seeing a positional matcher
            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }
            matchers.push(matcher);
          }
        }
        return elementMatcher(matchers);
      }
      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
              elems = seed || byElement && Expr.find['TAG']('*', outermost),
              // Use integer dirruns iff this is the outermost matcher
              dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context !== document && context;
            }
            // Add elements passing elementMatchers directly to results
            // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              // Track unmatched elements for set filters
              if (bySet) {
                // They will have gone through all possible matchers
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                // Lengthen the array for every element, matched or not
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            // Apply set filters to unmatched elements
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                // Reintegrate element matches to eliminate the need for sorting
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                // Discard index placeholder values to get only actual matches
                setMatched = condense(setMatched);
              }
              // Add matches to results
              push.apply(results, setMatched);
              // Seedless set matches succeeding multiple successful matchers stipulate sorting
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            // Override manipulation of globals by nested matchers
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
        return bySet ? markFunction(superMatcher) : superMatcher;
      }
      compile = Sizzle.compile = function (selector, match) {
        var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          // Cache the compiled function
          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
          // Save selector and tokenization
          cached.selector = selector;
        }
        return cached;
      };
      /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
      select = Sizzle.select = function (selector, context, results, seed) {
        var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || [];
        // Try to minimize operations if there is no seed and only one group
        if (match.length === 1) {
          // Take a shortcut and set the context if the root selector is an ID
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;  // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          // Fetch a seed set for right-to-left matching
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            // Abort if we hit a combinator
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      };
      // One-time assignments
      // Sort stability
      support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
      // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function
      support.detectDuplicates = !!hasDuplicate;
      // Initialize against the default document
      setDocument();
      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*
      support.sortDetached = assert(function (div1) {
        // Should return 1, but returns 4 (following)
        return div1.compareDocumentPosition(document.createElement('div')) & 1;
      });
      // Support: IE<8
      // Prevent attribute/property "interpolation"
      // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
      if (!assert(function (div) {
          div.innerHTML = '<a href=\'#\'></a>';
          return div.firstChild.getAttribute('href') === '#';
        })) {
        addHandle('type|href|height|width', function (elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
          }
        });
      }
      // Support: IE<9
      // Use defaultValue in place of getAttribute("value")
      if (!support.attributes || !assert(function (div) {
          div.innerHTML = '<input/>';
          div.firstChild.setAttribute('value', '');
          return div.firstChild.getAttribute('value') === '';
        })) {
        addHandle('value', function (elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === 'input') {
            return elem.defaultValue;
          }
        });
      }
      // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies
      if (!assert(function (div) {
          return div.getAttribute('disabled') == null;
        })) {
        addHandle(booleans, function (elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      }
      return Sizzle;
    }(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[':'] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
  var risSimple = /^.[^:#\[\.,]*$/;
  // Implement the identical functionality for filter and not
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        /* jshint -W018 */
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ':not(' + expr + ')';
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function (selector) {
      var i, len = this.length, ret = [], self = this;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      // Needed because $( selector, context ) becomes $( context ).find( selector )
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  // Initialize a jQuery object
  // A central reference to the root jQuery(document)
  var rootjQuery,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
      var match, elem;
      // HANDLE: $(""), $(null), $(undefined), $(false)
      if (!selector) {
        return this;
      }
      // Handle HTML strings
      if (typeof selector === 'string') {
        if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        // Match html or make sure no context is specified for #id
        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            // HANDLE: $(html, props)
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);  // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;  // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);
            // Support: Blackberry 4.6
            // gEBID returns nodes no longer in the document (#6963)
            if (elem && elem.parentNode) {
              // Inject the element directly into the jQuery object
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }  // HANDLE: $(expr, $(...))
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);  // HANDLE: $(expr, context)
                                                          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        }  // HANDLE: $(DOMElement)
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;  // HANDLE: $(function)
                      // Shortcut for document ready
      } else if (jQuery.isFunction(selector)) {
        return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    };
  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;
  // Initialize central reference
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.extend({
    dir: function (elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function (target) {
      var targets = jQuery(target, this), l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          // Always skip document fragments
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      // Index in selector
      if (typeof elem === 'string') {
        return indexOf.call(jQuery(elem), this[0]);
      }
      // Locate the position of the desired element
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        // Reverse order for parents* and prev-derivatives
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = /\S+/g;
  // String to Object options format cache
  var optionsCache = {};
  // Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var
      // Last fire value (for non-forgettable lists)
      memory,
      // Flag to know if list was already fired
      fired,
      // Flag to know if list is currently firing
      firing,
      // First callback to fire (used internally by add and fireWith)
      firingStart,
      // End of the loop when firing
      firingLength,
      // Index of currently firing callback (modified by remove if needed)
      firingIndex,
      // Actual callback list
      list = [],
      // Stack of fire calls for repeatable lists
      stack = !options.once && [],
      // Fire callbacks
      fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            // To prevent further calls using add
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      // Actual Callbacks object
      self = {
        add: function () {
          if (list) {
            // First, we save the current length
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  // Inspect recursively
                  add(arg);
                }
              });
            }(arguments));
            // Do we need to add the callbacks to the
            // current firing batch?
            if (firing) {
              firingLength = list.length;  // With memory, if we're not firing then
                                           // we should call right away
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                // Handle firing indexes
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var fn = jQuery.isFunction(fns[i]) && fns[i];
                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      // Keep pipe for back-compat
      promise.pipe = promise.then;
      // Add list-specific methods
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        // promise[ done | fail | progress ] = list.add
        promise[tuple[1]] = list.add;
        // Handle state
        if (stateString) {
          list.add(function () {
            // state = [ resolved | rejected ]
            state = stateString;  // [ reject_list | resolve_list ].disable; progress_list.lock
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        // deferred[ resolve | reject | notify ]
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      // Make the deferred a promise
      promise.promise(deferred);
      // Call given func if any
      if (func) {
        func.call(deferred, deferred);
      }
      // All done!
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length,
        // the count of uncompleted subordinates
        remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
        // Update function for both resolve and progress values
        updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      // Add listeners to Deferred subordinates; treat others as resolved
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      // If we're not waiting on anything, resolve the master
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  // The deferred used on DOM ready
  var readyList;
  jQuery.fn.ready = function (fn) {
    // Add the callback
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      // Remember that the DOM is ready
      jQuery.isReady = true;
      // If a normal DOM Ready event fired, decrement, and wait if need be
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      // If there are functions bound, to execute
      readyList.resolveWith(document, [jQuery]);
      // Trigger any bound ready events
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler('ready');
        jQuery(document).off('ready');
      }
    }
  });
  /**
 * The ready event handler and self cleanup method
 */
  function completed() {
    document.removeEventListener('DOMContentLoaded', completed, false);
    window.removeEventListener('load', completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      // Catch cases where $(document).ready() is called after the browser event has already occurred.
      // We once tried to use readyState "interactive" here, but it caused issues like the one
      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
      if (document.readyState === 'complete') {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout(jQuery.ready);
      } else {
        // Use the handy event callback
        document.addEventListener('DOMContentLoaded', completed, false);
        // A fallback to window.onload, that will always work
        window.addEventListener('load', completed, false);
      }
    }
    return readyList.promise(obj);
  };
  // Kick off the DOM ready check even if the user does not
  jQuery.ready.promise();
  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      // Sets many values
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }  // Sets one value
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          // Bulk operations run against the entire set
          if (raw) {
            fn.call(elems, value);
            fn = null;  // ...except when executing function values
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < len; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
  /**
 * Determines whether an object can have data
 */
  jQuery.acceptData = function (owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    /* jshint -W018 */
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };
  function Data() {
    // Support: Android<4,
    // Old WebKit does not have Object.preventExtensions/freeze method,
    // return new empty object instead with no [[set]] accessor
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    });
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function (owner) {
      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return the key for a frozen object.
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
        // Check if the owner object already has a cache key
        unlock = owner[this.expando];
      // If not, create one
      if (!unlock) {
        unlock = Data.uid++;
        // Secure it in a non-enumerable, non-writable property
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);  // Support: Android<4
                                                       // Fallback to a less secure definition
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      // Ensure the cache object
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop,
        // There may be an unlock assigned to this node,
        // if there is no entry for this "owner", create one inline
        // and set the unlock as though an owner entry had always existed
        unlock = this.key(owner), cache = this.cache[unlock];
      // Handle: [ owner, key, value ] args
      if (typeof data === 'string') {
        cache[data] = value;  // Handle: [ owner, { properties } ] args
      } else {
        // Fresh assignments by object are shallow copied
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);  // Otherwise, copy the properties one-by-one to the cache object
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      // Either a valid cache is found, or will be created.
      // New caches will be created and the unlock returned,
      // allowing direct access to the newly created
      // empty data object. A valid owner object must be provided.
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === 'string' && value === undefined) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      // [*]When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set(owner, key, value);
      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        // Support array or space separated string of keys
        if (jQuery.isArray(key)) {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          // Try the string as a key before any manipulation
          if (key in cache) {
            name = [
              key,
              camel
            ];
          } else {
            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            name = camel;
            name = name in cache ? [name] : name.match(rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    var name;
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {
        }
        // Make sure we set the data so it isn't changed later
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var i, name, data, elem = this[0], attrs = elem && elem.attributes;
      // Gets all values
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
            i = attrs.length;
            while (i--) {
              // Support: IE11+
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf('data-') === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, 'hasDataAttrs', true);
          }
        }
        return data;
      }
      // Sets multiple values
      if (typeof key === 'object') {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return access(this, function (value) {
        var data, camelKey = jQuery.camelCase(key);
        // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.
        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // with the key as-is
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          // Attempt to get data from the cache
          // with the key camelized
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          // Attempt to "discover" the data in
          // HTML5 custom data-* attrs
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          // We tried really hard, but the data doesn't exist.
          return;
        }
        // Set the data...
        this.each(function () {
          // First, attempt to store a copy or reference of any
          // data that might've been store with a camelCased key.
          var data = data_user.get(this, camelKey);
          // For HTML5 data-* attribute interop, we have to
          // store property names with dashes in a camelCase form.
          // This might not apply to all properties...*
          data_user.set(this, camelKey, value);
          // *... In the case of properties that might _actually_
          // have dashes, we need to also store a copy of that
          // unchanged property.
          if (key.indexOf('-') !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = data_priv.get(elem, type);
        // Speed up dequeue by getting out quickly if this is just a lookup
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      // If the fx queue is dequeued, always remove the progress sentinel
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        // Clear up the last queue stop function
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          data_priv.remove(elem, [
            type + 'queue',
            key
          ]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        // Ensure a hooks for this queue
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = data_priv.get(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ];
  var isHidden = function (elem, el) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = /^(?:checkbox|radio)$/i;
  (function () {
    var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
    // Support: Safari<=5.1
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)
    input.setAttribute('type', 'radio');
    input.setAttribute('checked', 'checked');
    input.setAttribute('name', 't');
    div.appendChild(input);
    // Support: Safari<=5.1, Android<4.2
    // Older WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    // Support: IE<=11+
    // Make sure textarea (and checkbox) defaultValue is properly cloned
    div.innerHTML = '<textarea>x</textarea>';
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  }());
  var strundefined = typeof undefined;
  support.focusinBubbles = 'onfocusin' in window;
  var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
      // Don't attach events to noData or text/comment nodes (but allow plain objects)
      if (!elemData) {
        return;
      }
      // Caller can pass in an object of custom data in lieu of the handler
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      // Make sure that the handler has a unique ID, used to find/remove it later
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      // Init the element's event structure and main handler, if this is the first
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      // Handle multiple events separated by a space
      types = (types || '').match(rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        // There *must* be a type, no attaching namespace-only handlers
        if (!type) {
          continue;
        }
        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[type] || {};
        // If selector defined, determine special event api type, otherwise given type
        type = (selector ? special.delegateType : special.bindType) || type;
        // Update special based on newly reset type
        special = jQuery.event.special[type] || {};
        // handleObj is passed to all event handlers
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        // Init the event handler queue if we're the first
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          // Only use addEventListener if the special events handler returns false
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        // Add to the element's handler list, delegates in front
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[type] = true;
      }
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      // Once for each type.namespace in types; type may be omitted
      types = (types || '').match(rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        // Unbind all events (on this namespace, if provided) for the element
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        // Remove matching events
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      // Remove the expando if it's no longer used
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      // Don't do events on text and comment nodes
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      // Clean up the event in case it is being reused
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      // Allow special events to draw outside the lines
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      // Fire handlers on the event path
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        // jQuery handler
        handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        // Native handler
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      // If nobody prevented the default action, do it now
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          // Call a native DOM method on the target with the same name name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[0] = event;
      event.delegateTarget = this;
      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      // Determine handlers
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      // Call the postDispatch hook for the mapped type
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      // Find delegate handlers
      // Black-hole SVG <use> instance trees (#13180)
      // Avoid non-left-click bubbling in Firefox (#3861)
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.disabled !== true || event.type !== 'click') {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              // Don't conflict with Object.prototype properties (#13203)
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      // Add the remaining (directly-bound) handlers
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        // Add which for key events
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var eventDoc, doc, body, button = original.button;
        // Calculate pageX/Y if missing and clientX/Y available
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      // Create a writable copy of the event object and normalize some properties
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      // Support: Cordova 2.5 (WebKit) (#13255)
      // All events should have a target; Cordova deviceready doesn't
      if (!event.target) {
        event.target = document;
      }
      // Support: Safari 6.0+, Chrome<28
      // Target should not be a text node (#504, #13143)
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      // Piggyback on a donor event to simulate a different one.
      // Fake originalEvent to avoid donor's stopPropagation, but if the
      // simulated event prevents default then we do the same on the donor.
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    // Event object
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;  // Event type
    } else {
      this.type = src;
    }
    // Put explicitly provided properties onto the event object
    if (props) {
      jQuery.extend(this, props);
    }
    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();
    // Mark it as fixed
    this[jQuery.expando] = true;
  };
  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  // Create mouseenter/leave events using mouseover/out and event-time checks
  // Support: Chrome 15+
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout',
    pointerenter: 'pointerover',
    pointerleave: 'pointerout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  // Support: Firefox, Chrome, Safari
  // Create "bubbling" focus and blur events
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function () {
          var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      // Types can be a map of types/handlers
      if (typeof types === 'object') {
        // ( types-Object, selector, data )
        if (typeof selector !== 'string') {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        // Use same guid so caller can remove using origFn
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    // We have to close these tags to support XHTML (#13200)
    wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      col: [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: [
        0,
        '',
        ''
      ]
    };
  // Support: IE9
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  // Support: 1.x compatibility
  // Manipulating tables requires a tbody
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript(elem) {
    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  // Mark scripts as having already been evaluated
  function setGlobalEval(elems, refElements) {
    var i = 0, l = elems.length;
    for (; i < l; i++) {
      data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    // 1. Copy private data: events, handlers, etc.
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    // 2. Copy user data
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  // Fix IE bugs, see support tests
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    // Fails to persist the checked state of a cloned checkbox or radio button.
    if (nodeName === 'input' && rcheckableType.test(src.type)) {
      dest.checked = src.checked;  // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
      // Fix IE cloning issues
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      // Copy the events from the original to the clone
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      // Preserve script evaluation history
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      // Return the cloned set
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          // Add nodes directly
          if (jQuery.type(elem) === 'object') {
            // Support: QtWebKit, PhantomJS
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);  // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));  // Convert html into DOM nodes
          } else {
            tmp = tmp || fragment.appendChild(context.createElement('div'));
            // Deserialize a standard representation
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            // Descend through wrappers to the right content
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            // Support: QtWebKit, PhantomJS
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, tmp.childNodes);
            // Remember the top-level container
            tmp = fragment.firstChild;
            // Ensure the created nodes are orphaned (#12392)
            tmp.textContent = '';
          }
        }
      }
      // Remove wrapper from fragment
      fragment.textContent = '';
      i = 0;
      while (elem = nodes[i++]) {
        // #4087 - If origin and destination elements are the same, and this is
        // that element, do not do anything
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        // Append to fragment
        tmp = getAll(fragment.appendChild(elem), 'script');
        // Preserve script evaluation history
        if (contains) {
          setGlobalEval(tmp);
        }
        // Capture executables
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data, elem, type, key, special = jQuery.event.special, i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);  // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              // Discard any remaining `private` data
              delete data_priv.cache[key];
            }
          }
        }
        // Discard any remaining `user` data
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function (value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false));
          // Remove any remaining nodes
          elem.textContent = '';
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        // See if we can take a shortcut and just use innerHTML
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              // Remove element nodes and prevent memory leaks
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;  // If using innerHTML throws an exception, use the fallback method
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var arg = arguments[0];
      // Make the changes, replacing each context element with the new content
      this.domManip(arguments, function (elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      // Force removal if there was no new content (e.g., from empty arguments)
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback) {
      // Flatten any nested arrays
      args = concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      // We can't cloneNode fragments that contain checked, in WebKit
      if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          // Use the original fragment for the last item instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              // Keep references to cloned scripts for later restoration
              if (hasScripts) {
                // Support: QtWebKit
                // jQuery.merge because push.apply(_, arraylike) throws
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            // Reenable scripts
            jQuery.map(scripts, restoreScript);
            // Evaluate executable scripts on first document insertion
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  // Optional AJAX dependency, but won't run scripts if not present
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        // Support: QtWebKit
        // .get() because push.apply(_, arraylike) throws
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe, elemdisplay = {};
  /**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
  // Called only from within defaultDisplay
  function actualDisplay(name, doc) {
    var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body),
      // getDefaultComputedStyle might be reliably used only on attached element
      display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], 'display');
    // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element
    elem.detach();
    return display;
  }
  /**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
  function defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      // If the simple way fails, read from inside an iframe
      if (display === 'none' || !display) {
        // Use the already-created iframe if possible
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
        doc = iframe[0].contentDocument;
        // Support: IE
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      // Store the correct default display
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = /^margin/;
  var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
  var getStyles = function (elem) {
    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };
  function curCSS(elem, name, computed) {
    var width, minWidth, maxWidth, ret, style = elem.style;
    computed = computed || getStyles(elem);
    // Support: IE9
    // getPropertyValue is only needed for .css('filter') (#12537)
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      // Support: iOS < 6
      // A tribute to the "awesome hack by Dean Edwards"
      // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
      // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        // Put in the new values to get a computed value out
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        // Revert the changed values
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + '' : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function () {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        }
        // Hook needed; redefine it so that the support test is not executed again.
        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }
  (function () {
    var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement('div'), div = document.createElement('div');
    if (!div.style) {
      return;
    }
    // Support: IE9-11+
    // Style of cloned element affects source element cloned (#8908)
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    container.style.cssText = 'border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;' + 'position:absolute';
    container.appendChild(div);
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;' + 'box-sizing:border-box;display:block;margin-top:1%;top:1%;' + 'border:1px;padding:1px;width:4px;position:absolute';
      div.innerHTML = '';
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== '1%';
      boxSizingReliableVal = divStyle.width === '4px';
      docElem.removeChild(container);
    }
    // Support: node.js jsdom
    // Don't assume that getComputedStyle is a property of the global object
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function () {
          // This test is executed only once but we still do memoizing
          // since we can use the boxSizingReliable pre-computing.
          // No need to check if the test was already performed, though.
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function () {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function () {
          // Support: Android 2.3
          // Check if div with explicit width and no margin-right incorrectly
          // gets computed margin-right based on width of container. (#3333)
          // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
          // This support function is only executed once so no memoizing is needed.
          var ret, marginDiv = div.appendChild(document.createElement('div'));
          // Reset CSS: box-sizing; display; margin; border; padding
          marginDiv.style.cssText = div.style.cssText = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;padding:0';
          marginDiv.style.marginRight = marginDiv.style.width = '0';
          div.style.width = '1px';
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  }());
  // A method for quickly swapping in/out CSS properties to get correct calculations.
  jQuery.swap = function (elem, options, callback, args) {
    var ret, name, old = {};
    // Remember the old values, and insert the new ones
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    // Revert the old values
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var
    // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: '0',
      fontWeight: '400'
    }, cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  // Return a css property mapped to a potentially vendor prefixed property
  function vendorPropName(style, name) {
    // Shortcut for names that are not vendor prefixed
    if (name in style) {
      return name;
    }
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      // Both box models exclude margin, so add it if we want it
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        // At this point, extra isn't border nor margin, so remove border
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        // At this point, extra isn't content, so add padding
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        // At this point, extra isn't content nor padding, so add border
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    // Some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if (val <= 0 || val == null) {
      // Fall back to computed then uncomputed css if necessary
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      // Computed unit is not pixels. Stop here and return.
      if (rnumnonpx.test(val)) {
        return val;
      }
      // Check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      // Normalize "", auto, and prepare for extra
      val = parseFloat(val) || 0;
    }
    // Use the active box-sizing model to add/subtract irrelevant styles
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        // Reset the inline display of this element to learn if it is
        // being hidden by cascaded rules or not
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        // Set elements which have been overridden with display: none
        // in a stylesheet to whatever the default browser style is
        // for such an element
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = data_priv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== 'none' || !hidden) {
          data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
        }
      }
    }
    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'flexGrow': true,
      'flexShrink': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': 'cssFloat' },
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      // Make sure that we're working with the right name
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      // Gets hook for the prefixed version, then unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      // Check if we're setting a value
      if (value !== undefined) {
        type = typeof value;
        // Convert "+=" or "-=" to relative numbers (#7345)
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          // Fixes bug #9237
          type = 'number';
        }
        // Make sure that null and NaN values aren't set (#7116)
        if (value == null || value !== value) {
          return;
        }
        // If a number, add 'px' to the (except for certain CSS properties)
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        // Support: IE9-11+
        // background-* props affect original clone's values
        if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        // If a hook was provided, use that value, otherwise just set the specified value
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        // Otherwise just get the value from the style object
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val, num, hooks, origName = jQuery.camelCase(name);
      // Make sure that we're working with the right name
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      // Try prefixed name followed by the unprefixed name
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      // If a hook was provided get the computed value from there
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      // Otherwise, if a way to get the computed value exists, use that
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      // Convert "normal" to computed value
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      // Make numeric if forced or a qualifier was provided and val looks numeric
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  // Support: Android 2.3
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
    if (computed) {
      return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
        elem,
        'marginRight'
      ]);
    }
  });
  // These hooks are used by animate to expand properties
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {},
          // Assumes a single number if not a string
          parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function (name, value) {
      return access(this, function (elem, name, value) {
        var styles, len, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.
        result = jQuery.css(tween.elem, tween.prop, '');
        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  // Support: IE9
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  // Back Compat <1.8 extension point
  jQuery.fx.step = {};
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'),
            // Starting value computation is required for potential unit mismatches
            start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            // Trust units reported by jQuery.css
            unit = unit || start[3];
            // Make sure we update the tween properties later on
            parts = parts || [];
            // Iteratively approximate from a nonzero starting point
            start = +target || 1;
            do {
              // If previous iteration zeroed out, double until we get *something*.
              // Use string for doubling so we don't accidentally see scale as unchanged below
              scale = scale || '.5';
              // Adjust and apply
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);  // Update scale, tolerating zero or NaN from tween.cur(),
                                                             // break the loop if scale is unchanged or perfect, or if we've just had enough
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          // Update tween properties
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            // If a +=/-= token was provided, we're doing a relative animation
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  // Animations created synchronously will run synchronously
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  // Generate parameters to create a standard animation
  function genFx(type, includeWidth) {
    var which, i = 0, attrs = { height: type };
    // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
    // Handle queue: false promises
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    // Height/width overflow pass
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      // Make sure that nothing sneaks out
      // Record all 3 overflow attributes because IE9-10 do not
      // change the overflow attribute when overflowX and
      // overflowY are set to the same value
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      // Set display property to inline-block for height/width
      // animations on inline elements that are having width/height animated
      display = jQuery.css(elem, 'display');
      // Test default display if display is currently "none"
      checkDisplay = display === 'none' ? data_priv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
        style.display = 'inline-block';
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    // show/hide pass
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);  // Any non-fx value stops us from restoring the original display value
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, 'fxshow', {});
      }
      // Store state if its toggle - enables .stop().toggle() to "reverse"
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }  // If this is a noop like .hide().hide(), restore an overwritten display value
    } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    // camelCase, specialEasing and expand cssHook pass
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        // Don't match elem in the :animated selector
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
          temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0,
            // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          // Resolve when we played the last frame; otherwise, reject
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    // attach callbacks from options
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    // Normalize opt.queue - true/undefined/null -> "fx"
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    // Queueing
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          // Empty animations, or finishing resolves immediately
          if (empty || data_priv.get(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        // Enable finishing flag on private data
        data.finish = true;
        // Empty the queue first
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        // Look for any active animations, and finish them
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        // Look for any animations in the old queue and finish them
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        // Turn off finishing flag
        delete data.finish;
      });
    }
  });
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  // Generate shortcuts for custom animations
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function () {
    var timer, i = 0, timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      // Checks the timer has not already been removed
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || 'fx';
    return this.queue(type, function (next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function () {
        clearTimeout(timeout);
      };
    });
  };
  (function () {
    var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
    input.type = 'checkbox';
    // Support: iOS<=5.1, Android<=4.2+
    // Default value for a checkbox should be "on"
    support.checkOn = input.value !== '';
    // Support: IE<=11+
    // Must access selectedIndex to make default options select
    support.optSelected = opt.selected;
    // Support: Android<=2.3
    // Options inside disabled selects are incorrectly marked as disabled
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    // Support: IE<=11+
    // An input loses its value after becoming a radio
    input = document.createElement('input');
    input.value = 't';
    input.type = 'radio';
    support.radioValue = input.value === 't';
  }());
  var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      // don't get/set attributes on text, comment and attribute nodes
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      // Fallback to prop when attributes are not supported
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      // All attributes are lowercase
      // Grab necessary hook if one is defined
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        // Non-existent attributes return null, we normalize to undefined
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          // Boolean attributes get special treatment (#10870)
          if (jQuery.expr.match.bool.test(name)) {
            // Set corresponding property to false
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    }
  });
  // Hooks for boolean attributes
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function (elem, name, isXML) {
      var ret, handle;
      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      // Don't get/set properties on text, comment and attribute nodes
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }
      }
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function (value) {
      var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === 'string' && value, i = 0, len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        // The disjunction here is for better compressibility (see removeClass)
        classes = (value || '').match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            // only assign if different to avoid unneeded rendering.
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === 'string' && value, i = 0, len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          // This expression is here for better compressibility (see addClass)
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            // Only assign if different to avoid unneeded rendering.
            finalValue = value ? jQuery.trim(cur) : '';
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          // Toggle individual class names
          var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }  // Toggle whole class name
        } else if (type === strundefined || type === 'boolean') {
          if (this.className) {
            // store className if set
            data_priv.set(this, '__className__', this.className);
          }
          // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function (value) {
      var hooks, ret, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        // Treat null/undefined as ""; convert numbers to string
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        // If set returns undefined, fall back to normal setting
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, 'value');
          return val != null ? val : jQuery.trim(jQuery.text(elem));
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          // Loop through all the selected options
          for (; i < max; i++) {
            option = options[i];
            // IE6-9 doesn't update selected after form reset (#2551)
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              // Get the specific value for the option
              value = jQuery(option).val();
              // We don't need an array for one selects
              if (one) {
                return value;
              }
              // Multi-Selects return an array
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(option.value, values) >= 0) {
              optionSet = true;
            }
          }
          // Force browsers to behave consistently when non-matching value is set
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });
  // Radios and checkboxes getter/setter
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  // Return jQuery for attributes-only inclusion
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = /\?/;
  // Support: Android 2.3
  // Workaround failure to string-cast null input
  jQuery.parseJSON = function (data) {
    return JSON.parse(data + '');
  };
  // Cross-browser xml parsing
  jQuery.parseXML = function (data) {
    var xml, tmp;
    if (!data || typeof data !== 'string') {
      return null;
    }
    // Support: IE9
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, 'text/xml');
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName('parsererror').length) {
      jQuery.error('Invalid XML: ' + data);
    }
    return xml;
  };
  var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {},
    /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {},
    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = '*/'.concat('*'),
    // Document location
    ajaxLocation = window.location.href,
    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);  // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend(target, src) {
    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
    // Remove auto dataType and get content-type in the process
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    // Check if we're dealing with a known content-type
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    // Check to see if we have a response for the expected dataType
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }
    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {},
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();
    // Create converters map with lowercased keys
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    // Convert to each sequential dataType
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      // Apply the dataFilter if provided
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === '*') {
          current = prev;  // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== '*' && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          // If none found, seek a pair
          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2];  // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          // Apply converter (if not an equivalence)
          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      // Force options to be an object
      options = options || {};
      var transport,
        // URL without anti-cache param
        cacheURL,
        // Response headers
        responseHeadersString, responseHeaders,
        // timeout handle
        timeoutTimer,
        // Cross-domain detection vars
        parts,
        // To know if global events are to be dispatched
        fireGlobals,
        // Loop variable
        i,
        // Create the final options object
        s = jQuery.ajaxSetup({}, options),
        // Callbacks context
        callbackContext = s.context || s,
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
        // Deferreds
        deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'),
        // Status-dependent callbacks
        statusCode = s.statusCode || {},
        // Headers (they are sent all at once)
        requestHeaders = {}, requestHeadersNames = {},
        // The jqXHR state
        state = 0,
        // Default abort message
        strAbort = 'canceled',
        // Fake xhr
        jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  // Lazy-add the new callback in a way that preserves old ones
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      // Attach deferreds
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      // Remove hash character (#7531: and string promotion)
      // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      // Alias method option to type as per ticket #12004
      s.type = options.method || options.type || s.method || s.type;
      // Extract dataTypes list
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
      // A cross-domain request is in order when we have a protocol:host:port mismatch
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      // Convert data if not already a string
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      // Apply prefilters
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      // If request was aborted inside a prefilter, stop there
      if (state === 2) {
        return jqXHR;
      }
      // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
      fireGlobals = jQuery.event && s.global;
      // Watch for a new set of requests
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      // Uppercase the type
      s.type = s.type.toUpperCase();
      // Determine if request has content
      s.hasContent = !rnoContent.test(s.type);
      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      cacheURL = s.url;
      // More options handling for requests with no content
      if (!s.hasContent) {
        // If data is available, append data to url
        if (s.data) {
          cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
          // #9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }
        // Add anti-cache in url if needed
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
        }
      }
      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      // Set the correct header, if data is being sent
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      // Check for headers option
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      // Allow custom headers/mimetypes and early abort
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        // Abort if not done already and return
        return jqXHR.abort();
      }
      // Aborting is no longer a cancellation
      strAbort = 'abort';
      // Install callbacks on deferreds
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      // Get transport
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      // If no transport, we auto-abort
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        // Send global event
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        // Timeout
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Propagate exception as error if not done
          if (state < 2) {
            done(-1, e);  // Simply rethrow otherwise
          } else {
            throw e;
          }
        }
      }
      // Callback for when everything is done
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        // Called once
        if (state === 2) {
          return;
        }
        // State is "done" now
        state = 2;
        // Clear timeout if it exists
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;
        // Cache response headers
        responseHeadersString = headers || '';
        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;
        // Determine if successful
        isSuccess = status >= 200 && status < 300 || status === 304;
        // Get response data
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        // If successful, handle type chaining
        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          // if no content
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';  // if not modified
          } else if (status === 304) {
            statusText = 'notmodified';  // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        // Success/Error
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        // Status-dependent callbacks
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        // Complete
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          // Handle the global AJAX counter
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,
      type: 'GET',
      dataType: 'script',
      async: false,
      global: false,
      'throws': true
    });
  };
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        // The elements to wrap the target around
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function (elem) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function (elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }
  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        // If value is a function, invoke it and return its value
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    // If an array was passed in, assume that it is an array of form elements.
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    // Return the resulting serialization
    return s.join('&').replace(r20, '+');
  };
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        // Use .is( ":disabled" ) so that fieldset[disabled] works
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {
    }
  };
  var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
  // Support: IE9
  // Open requests must be manually aborted on unload (#5280)
  // See https://support.microsoft.com/kb/2856746 for more info
  if (window.attachEvent) {
    window.attachEvent('onunload', function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    // Cross domain only allowed if supported through XMLHttpRequest
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i, xhr = options.xhr(), id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          // Apply custom fields if provided
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          // Override mime type if needed
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          // Set headers
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          // Callback
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === 'abort') {
                  xhr.abort();
                } else if (type === 'error') {
                  complete(xhr.status, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          // Listen to events
          xhr.onload = callback();
          xhr.onerror = callback('error');
          // Create the abort callback
          callback = xhrCallbacks[id] = callback('abort');
          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (callback) {
              throw e;
            }
          }
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  // Install script dataType
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
    }
  });
  // Bind script tag hack transport
  jQuery.ajaxTransport('script', function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery('<script>').prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on('load error', callback = function (evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === 'error' ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  // Default jsonp settings
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
      this[callback] = true;
      return callback;
    }
  });
  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      // Insert callback into url or form data
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      // Use data converter to retrieve json after script execution
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      // force json dataType
      s.dataTypes[0] = 'json';
      // Install callback
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      // Clean-up function (fires after converters)
      jqXHR.always(function () {
        // Restore preexisting value
        window[callbackName] = overwritten;
        // Save back as free
        if (s[callbackName]) {
          // make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;
          // save the callback name for future use
          oldCallbacks.push(callbackName);
        }
        // Call if it was a function and we have a response
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      // Delegate to script
      return 'script';
    }
  });
  // data: string of html
  // context (optional): If specified, the fragment will be created in this context, defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function (data, context, keepScripts) {
    if (!data || typeof data !== 'string') {
      return null;
    }
    if (typeof context === 'boolean') {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
    // Single tag
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  // Keep a copy of the old load method
  var _load = jQuery.fn.load;
  /**
 * Load a url into a page
 */
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    // If it's a function
    if (jQuery.isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined;  // Otherwise, build a param string
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    // If we have elements to modify, make the request
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  // Attach a bunch of functions for handling common AJAX events
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  /**
 * Gets a window from an element
 */
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
      // Set position first, in-case top/left are set even on static elem
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, 'top');
      curCSSLeft = jQuery.css(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    offset: function (options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem, win, elem = this[0], box = {
          top: 0,
          left: 0
        }, doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      // Make sure it's not a disconnected DOM node
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      // Support: BlackBerry 5, iOS 3 (original iPhone)
      // If we don't have gBCR, just use 0,0 rather than error
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
      if (jQuery.css(elem, 'position') === 'fixed') {
        // Assume getBoundingClientRect is there when computed position is fixed
        offset = elem.getBoundingClientRect();
      } else {
        // Get *real* offsetParent
        offsetParent = this.offsetParent();
        // Get correct offsets
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        // Add offsetParent borders
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      // Subtract parent offsets and element margins
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  // Create scrollLeft and scrollTop methods
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = 'pageYOffset' === prop;
    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  // Support: Safari<7+, Chrome<37+
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each([
    'top',
    'left'
  ], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
      }
    });
  });
  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
            // isn't a whole lot we can do. See pull request at this URL for discussion:
            // https://github.com/jquery/jquery/pull/764
            return elem.document.documentElement['client' + name];
          }
          // Get document width or height
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  // The number of elements contained in the matched element set
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
  if (typeof define === 'function' && define.amd) {
    define('jquery', [], function () {
      return jQuery;
    });
  }
  var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
    // Map over the $ in case of overwrite
    _$ = window.$;
  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));/*! jQuery UI - v1.11.4 - 2015-03-11
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {
  /*!
 * jQuery UI Core 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
  // $.ui might exist from components with no dependencies, e.g., $.ui.position
  $.ui = $.ui || {};
  $.extend($.ui, {
    version: '1.11.4',
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  });
  // plugins
  $.fn.extend({
    scrollParent: function (includeHidden) {
      var position = this.css('position'), excludeStaticParent = position === 'absolute', overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function () {
          var parent = $(this);
          if (excludeStaticParent && parent.css('position') === 'static') {
            return false;
          }
          return overflowRegex.test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
        }).eq(0);
      return position === 'fixed' || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
    },
    uniqueId: function () {
      var uuid = 0;
      return function () {
        return this.each(function () {
          if (!this.id) {
            this.id = 'ui-id-' + ++uuid;
          }
        });
      };
    }(),
    removeUniqueId: function () {
      return this.each(function () {
        if (/^ui-id-\d+$/.test(this.id)) {
          $(this).removeAttr('id');
        }
      });
    }
  });
  // selectors
  function focusable(element, isTabIndexNotNaN) {
    var map, mapName, img, nodeName = element.nodeName.toLowerCase();
    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=\'#' + mapName + '\']')[0];
      return !!img && visible(img);
    }
    return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
  }
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, 'visibility') === 'hidden';
    }).length;
  }
  $.extend($.expr[':'], {
    data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
      return function (elem) {
        return !!$.data(elem, dataName);
      };
    }) : function (elem, i, match) {
      return !!$.data(elem, match[3]);
    },
    focusable: function (element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    },
    tabbable: function (element) {
      var tabIndex = $.attr(element, 'tabindex'), isTabIndexNaN = isNaN(tabIndex);
      return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    }
  });
  // support: jQuery <1.8
  if (!$('<a>').outerWidth(1).jquery) {
    $.each([
      'Width',
      'Height'
    ], function (i, name) {
      var side = name === 'Width' ? [
          'Left',
          'Right'
        ] : [
          'Top',
          'Bottom'
        ], type = name.toLowerCase(), orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };
      function reduce(elem, size, border, margin) {
        $.each(side, function () {
          size -= parseFloat($.css(elem, 'padding' + this)) || 0;
          if (border) {
            size -= parseFloat($.css(elem, 'border' + this + 'Width')) || 0;
          }
          if (margin) {
            size -= parseFloat($.css(elem, 'margin' + this)) || 0;
          }
        });
        return size;
      }
      $.fn['inner' + name] = function (size) {
        if (size === undefined) {
          return orig['inner' + name].call(this);
        }
        return this.each(function () {
          $(this).css(type, reduce(this, size) + 'px');
        });
      };
      $.fn['outer' + name] = function (size, margin) {
        if (typeof size !== 'number') {
          return orig['outer' + name].call(this, size);
        }
        return this.each(function () {
          $(this).css(type, reduce(this, size, true, margin) + 'px');
        });
      };
    });
  }
  // support: jQuery <1.8
  if (!$.fn.addBack) {
    $.fn.addBack = function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    };
  }
  // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
  if ($('<a>').data('a-b', 'a').removeData('a-b').data('a-b')) {
    $.fn.removeData = function (removeData) {
      return function (key) {
        if (arguments.length) {
          return removeData.call(this, $.camelCase(key));
        } else {
          return removeData.call(this);
        }
      };
    }($.fn.removeData);
  }
  // deprecated
  $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
  $.fn.extend({
    focus: function (orig) {
      return function (delay, fn) {
        return typeof delay === 'number' ? this.each(function () {
          var elem = this;
          setTimeout(function () {
            $(elem).focus();
            if (fn) {
              fn.call(elem);
            }
          }, delay);
        }) : orig.apply(this, arguments);
      };
    }($.fn.focus),
    disableSelection: function () {
      var eventType = 'onselectstart' in document.createElement('div') ? 'selectstart' : 'mousedown';
      return function () {
        return this.bind(eventType + '.ui-disableSelection', function (event) {
          event.preventDefault();
        });
      };
    }(),
    enableSelection: function () {
      return this.unbind('.ui-disableSelection');
    },
    zIndex: function (zIndex) {
      if (zIndex !== undefined) {
        return this.css('zIndex', zIndex);
      }
      if (this.length) {
        var elem = $(this[0]), position, value;
        while (elem.length && elem[0] !== document) {
          // Ignore z-index if position is set to a value where z-index is ignored by the browser
          // This makes behavior of this function consistent across browsers
          // WebKit always returns auto if the element is positioned
          position = elem.css('position');
          if (position === 'absolute' || position === 'relative' || position === 'fixed') {
            // IE returns 0 when zIndex is not specified
            // other browsers return a string
            // we ignore the case of nested elements with an explicit value of 0
            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
            value = parseInt(elem.css('zIndex'), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }
      return 0;
    }
  });
  // $.ui.plugin is deprecated. Use $.widget() extensions instead.
  $.ui.plugin = {
    add: function (module, option, set) {
      var i, proto = $.ui[module].prototype;
      for (i in set) {
        proto.plugins[i] = proto.plugins[i] || [];
        proto.plugins[i].push([
          option,
          set[i]
        ]);
      }
    },
    call: function (instance, name, args, allowDisconnected) {
      var i, set = instance.plugins[name];
      if (!set) {
        return;
      }
      if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
        return;
      }
      for (i = 0; i < set.length; i++) {
        if (instance.options[set[i][0]]) {
          set[i][1].apply(instance.element, args);
        }
      }
    }
  };
  /*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
  var widget_uuid = 0, widget_slice = Array.prototype.slice;
  $.cleanData = function (orig) {
    return function (elems) {
      var events, elem, i;
      for (i = 0; (elem = elems[i]) != null; i++) {
        try {
          // Only trigger remove when necessary to save time
          events = $._data(elem, 'events');
          if (events && events.remove) {
            $(elem).triggerHandler('remove');
          }  // http://bugs.jquery.com/ticket/8235
        } catch (e) {
        }
      }
      orig(elems);
    };
  }($.cleanData);
  $.widget = function (name, base, prototype) {
    var fullName, existingConstructor, constructor, basePrototype,
      // proxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)
      proxiedPrototype = {}, namespace = name.split('.')[0];
    name = name.split('.')[1];
    fullName = namespace + '-' + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    // create selector for plugin
    $.expr[':'][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }
      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      _proto: $.extend({}, prototype),
      _childConstructors: []
    });
    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = function () {
        var _super = function () {
            return base.prototype[prop].apply(this, arguments);
          }, _superApply = function (args) {
            return base.prototype[prop].apply(this, args);
          };
        return function () {
          var __super = this._super, __superApply = this._superApply, returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      }();
    });
    constructor.prototype = $.widget.extend(basePrototype, { widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });
    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;
        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + '.' + childPrototype.widgetName, constructor, child._proto);
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
    return constructor;
  };
  $.widget.extend = function (target) {
    var input = widget_slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);  // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === 'string', args = widget_slice.call(arguments, 1), returnValue = this;
      if (isMethodCall) {
        this.each(function () {
          var methodValue, instance = $.data(this, fullName);
          if (options === 'instance') {
            returnValue = instance;
            return false;
          }
          if (!instance) {
            return $.error('cannot call methods on ' + name + ' prior to initialization; ' + 'attempted to call method \'' + options + '\'');
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
            return $.error('no such method \'' + options + '\' for ' + name + ' widget instance');
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
            return false;
          }
        });
      } else {
        // Allow multiple hashes to be passed on init
        if (args.length) {
          options = $.widget.extend.apply(null, [options].concat(args));
        }
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {});
            if (instance._init) {
              instance._init();
            }
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function () {
  };
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: 'widget',
    widgetEventPrefix: '',
    defaultElement: '<div>',
    options: {
      disabled: false,
      create: null
    },
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = widget_uuid++;
      this.eventNamespace = '.' + this.widgetName + this.uuid;
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ? element.ownerDocument : element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this._create();
      this._trigger('create', null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function () {
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
      this.widget().unbind(this.eventNamespace).removeAttr('aria-disabled').removeClass(this.widgetFullName + '-disabled ' + 'ui-state-disabled');
      // clean up events and states
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass('ui-state-hover');
      this.focusable.removeClass('ui-state-focus');
    },
    _destroy: $.noop,
    widget: function () {
      return this.element;
    },
    option: function (key, value) {
      var options = key, parts, curOption, i;
      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }
      if (typeof key === 'string') {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split('.');
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function (options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function (key, value) {
      this.options[key] = value;
      if (key === 'disabled') {
        this.widget().toggleClass(this.widgetFullName + '-disabled', !!value);
        // If the widget is becoming disabled, then nothing is interactive
        if (value) {
          this.hoverable.removeClass('ui-state-hover');
          this.focusable.removeClass('ui-state-focus');
        }
      }
      return this;
    },
    enable: function () {
      return this._setOptions({ disabled: false });
    },
    disable: function () {
      return this._setOptions({ disabled: true });
    },
    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement, instance = this;
      // no suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== 'boolean') {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
      // no element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass('ui-state-disabled'))) {
            return;
          }
          return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
        }
        // copy the guid so direct unbinding works
        if (typeof handler !== 'string') {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^([\w:-]*)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },
    _off: function (element, eventName) {
      eventName = (eventName || '').split(' ').join(this.eventNamespace + ' ') + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $(this.bindings.not(element).get());
      this.focusable = $(this.focusable.not(element).get());
      this.hoverable = $(this.hoverable.not(element).get());
    },
    _delay: function (handler, delay) {
      function handlerProxy() {
        return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          $(event.currentTarget).addClass('ui-state-hover');
        },
        mouseleave: function (event) {
          $(event.currentTarget).removeClass('ui-state-hover');
        }
      });
    },
    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          $(event.currentTarget).addClass('ui-state-focus');
        },
        focusout: function (event) {
          $(event.currentTarget).removeClass('ui-state-focus');
        }
      });
    },
    _trigger: function (type, event, data) {
      var prop, orig, callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];
      // copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: 'fadeIn',
    hide: 'fadeOut'
  }, function (method, defaultEffect) {
    $.Widget.prototype['_' + method] = function (element, options, callback) {
      if (typeof options === 'string') {
        options = { effect: options };
      }
      var hasOptions, effectName = !options ? method : options === true || typeof options === 'number' ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === 'number') {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
  var widget = $.widget;
  /*!
 * jQuery UI Mouse 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */
  var mouseHandled = false;
  $(document).mouseup(function () {
    mouseHandled = false;
  });
  var mouse = $.widget('ui.mouse', {
      version: '1.11.4',
      options: {
        cancel: 'input,textarea,button,select,option',
        distance: 1,
        delay: 0
      },
      _mouseInit: function () {
        var that = this;
        this.element.bind('mousedown.' + this.widgetName, function (event) {
          return that._mouseDown(event);
        }).bind('click.' + this.widgetName, function (event) {
          if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
            $.removeData(event.target, that.widgetName + '.preventClickEvent');
            event.stopImmediatePropagation();
            return false;
          }
        });
        this.started = false;
      },
      _mouseDestroy: function () {
        this.element.unbind('.' + this.widgetName);
        if (this._mouseMoveDelegate) {
          this.document.unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
        }
      },
      _mouseDown: function (event) {
        // don't let more than one widget handle mouseStart
        if (mouseHandled) {
          return;
        }
        this._mouseMoved = false;
        // we may have missed mouseup (out of window)
        this._mouseStarted && this._mouseUp(event);
        this._mouseDownEvent = event;
        var that = this, btnIsLeft = event.which === 1,
          // event.target.nodeName works around a bug in IE 8 with
          // disabled inputs (#7620)
          elIsCancel = typeof this.options.cancel === 'string' && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
        if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
          return true;
        }
        this.mouseDelayMet = !this.options.delay;
        if (!this.mouseDelayMet) {
          this._mouseDelayTimer = setTimeout(function () {
            that.mouseDelayMet = true;
          }, this.options.delay);
        }
        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
          this._mouseStarted = this._mouseStart(event) !== false;
          if (!this._mouseStarted) {
            event.preventDefault();
            return true;
          }
        }
        // Click event may never have fired (Gecko & Opera)
        if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
          $.removeData(event.target, this.widgetName + '.preventClickEvent');
        }
        // these delegates are required to keep context
        this._mouseMoveDelegate = function (event) {
          return that._mouseMove(event);
        };
        this._mouseUpDelegate = function (event) {
          return that._mouseUp(event);
        };
        this.document.bind('mousemove.' + this.widgetName, this._mouseMoveDelegate).bind('mouseup.' + this.widgetName, this._mouseUpDelegate);
        event.preventDefault();
        mouseHandled = true;
        return true;
      },
      _mouseMove: function (event) {
        // Only check for mouseups outside the document if you've moved inside the document
        // at least once. This prevents the firing of mouseup in the case of IE<9, which will
        // fire a mousemove event if content is placed under the cursor. See #7778
        // Support: IE <9
        if (this._mouseMoved) {
          // IE mouseup check - mouseup happened when mouse was out of window
          if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
            return this._mouseUp(event);  // Iframe mouseup check - mouseup occurred in another document
          } else if (!event.which) {
            return this._mouseUp(event);
          }
        }
        if (event.which || event.button) {
          this._mouseMoved = true;
        }
        if (this._mouseStarted) {
          this._mouseDrag(event);
          return event.preventDefault();
        }
        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
          this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
          this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
        }
        return !this._mouseStarted;
      },
      _mouseUp: function (event) {
        this.document.unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
        if (this._mouseStarted) {
          this._mouseStarted = false;
          if (event.target === this._mouseDownEvent.target) {
            $.data(event.target, this.widgetName + '.preventClickEvent', true);
          }
          this._mouseStop(event);
        }
        mouseHandled = false;
        return false;
      },
      _mouseDistanceMet: function (event) {
        return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
      },
      _mouseDelayMet: function () {
        return this.mouseDelayMet;
      },
      _mouseStart: function () {
      },
      _mouseDrag: function () {
      },
      _mouseStop: function () {
      },
      _mouseCapture: function () {
        return true;
      }
    });
  /*!
 * jQuery UI Position 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
  (function () {
    $.ui = $.ui || {};
    var cachedScrollbarWidth, supportsOffsetFractions, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
    function getOffsets(offsets, width, height) {
      return [
        parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
        parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
      ];
    }
    function parseCss(element, property) {
      return parseInt($.css(element, property), 10) || 0;
    }
    function getDimensions(elem) {
      var raw = elem[0];
      if (raw.nodeType === 9) {
        return {
          width: elem.width(),
          height: elem.height(),
          offset: {
            top: 0,
            left: 0
          }
        };
      }
      if ($.isWindow(raw)) {
        return {
          width: elem.width(),
          height: elem.height(),
          offset: {
            top: elem.scrollTop(),
            left: elem.scrollLeft()
          }
        };
      }
      if (raw.preventDefault) {
        return {
          width: 0,
          height: 0,
          offset: {
            top: raw.pageY,
            left: raw.pageX
          }
        };
      }
      return {
        width: elem.outerWidth(),
        height: elem.outerHeight(),
        offset: elem.offset()
      };
    }
    $.position = {
      scrollbarWidth: function () {
        if (cachedScrollbarWidth !== undefined) {
          return cachedScrollbarWidth;
        }
        var w1, w2, div = $('<div style=\'display:block;position:absolute;width:50px;height:50px;overflow:hidden;\'><div style=\'height:100px;width:auto;\'></div></div>'), innerDiv = div.children()[0];
        $('body').append(div);
        w1 = innerDiv.offsetWidth;
        div.css('overflow', 'scroll');
        w2 = innerDiv.offsetWidth;
        if (w1 === w2) {
          w2 = div[0].clientWidth;
        }
        div.remove();
        return cachedScrollbarWidth = w1 - w2;
      },
      getScrollInfo: function (within) {
        var overflowX = within.isWindow || within.isDocument ? '' : within.element.css('overflow-x'), overflowY = within.isWindow || within.isDocument ? '' : within.element.css('overflow-y'), hasOverflowX = overflowX === 'scroll' || overflowX === 'auto' && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === 'scroll' || overflowY === 'auto' && within.height < within.element[0].scrollHeight;
        return {
          width: hasOverflowY ? $.position.scrollbarWidth() : 0,
          height: hasOverflowX ? $.position.scrollbarWidth() : 0
        };
      },
      getWithinInfo: function (element) {
        var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
        return {
          element: withinElement,
          isWindow: isWindow,
          isDocument: isDocument,
          offset: withinElement.offset() || {
            left: 0,
            top: 0
          },
          scrollLeft: withinElement.scrollLeft(),
          scrollTop: withinElement.scrollTop(),
          width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
          height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
        };
      }
    };
    $.fn.position = function (options) {
      if (!options || !options.of) {
        return _position.apply(this, arguments);
      }
      // make a copy, we don't want to modify arguments
      options = $.extend({}, options);
      var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || 'flip').split(' '), offsets = {};
      dimensions = getDimensions(target);
      if (target[0].preventDefault) {
        // force left top to allow flipping
        options.at = 'left top';
      }
      targetWidth = dimensions.width;
      targetHeight = dimensions.height;
      targetOffset = dimensions.offset;
      // clone to reuse original targetOffset later
      basePosition = $.extend({}, targetOffset);
      // force my and at to have valid horizontal and vertical positions
      // if a value is missing or invalid, it will be converted to center
      $.each([
        'my',
        'at'
      ], function () {
        var pos = (options[this] || '').split(' '), horizontalOffset, verticalOffset;
        if (pos.length === 1) {
          pos = rhorizontal.test(pos[0]) ? pos.concat(['center']) : rvertical.test(pos[0]) ? ['center'].concat(pos) : [
            'center',
            'center'
          ];
        }
        pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center';
        pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center';
        // calculate offsets
        horizontalOffset = roffset.exec(pos[0]);
        verticalOffset = roffset.exec(pos[1]);
        offsets[this] = [
          horizontalOffset ? horizontalOffset[0] : 0,
          verticalOffset ? verticalOffset[0] : 0
        ];
        // reduce to just the positions without the offsets
        options[this] = [
          rposition.exec(pos[0])[0],
          rposition.exec(pos[1])[0]
        ];
      });
      // normalize collision option
      if (collision.length === 1) {
        collision[1] = collision[0];
      }
      if (options.at[0] === 'right') {
        basePosition.left += targetWidth;
      } else if (options.at[0] === 'center') {
        basePosition.left += targetWidth / 2;
      }
      if (options.at[1] === 'bottom') {
        basePosition.top += targetHeight;
      } else if (options.at[1] === 'center') {
        basePosition.top += targetHeight / 2;
      }
      atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
      basePosition.left += atOffset[0];
      basePosition.top += atOffset[1];
      return this.each(function () {
        var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, 'marginLeft'), marginTop = parseCss(this, 'marginTop'), collisionWidth = elemWidth + marginLeft + parseCss(this, 'marginRight') + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, 'marginBottom') + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
        if (options.my[0] === 'right') {
          position.left -= elemWidth;
        } else if (options.my[0] === 'center') {
          position.left -= elemWidth / 2;
        }
        if (options.my[1] === 'bottom') {
          position.top -= elemHeight;
        } else if (options.my[1] === 'center') {
          position.top -= elemHeight / 2;
        }
        position.left += myOffset[0];
        position.top += myOffset[1];
        // if the browser doesn't support fractions, then round for consistent results
        if (!supportsOffsetFractions) {
          position.left = round(position.left);
          position.top = round(position.top);
        }
        collisionPosition = {
          marginLeft: marginLeft,
          marginTop: marginTop
        };
        $.each([
          'left',
          'top'
        ], function (i, dir) {
          if ($.ui.position[collision[i]]) {
            $.ui.position[collision[i]][dir](position, {
              targetWidth: targetWidth,
              targetHeight: targetHeight,
              elemWidth: elemWidth,
              elemHeight: elemHeight,
              collisionPosition: collisionPosition,
              collisionWidth: collisionWidth,
              collisionHeight: collisionHeight,
              offset: [
                atOffset[0] + myOffset[0],
                atOffset[1] + myOffset[1]
              ],
              my: options.my,
              at: options.at,
              within: within,
              elem: elem
            });
          }
        });
        if (options.using) {
          // adds feedback as second argument to using callback, if present
          using = function (props) {
            var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                target: {
                  element: target,
                  left: targetOffset.left,
                  top: targetOffset.top,
                  width: targetWidth,
                  height: targetHeight
                },
                element: {
                  element: elem,
                  left: position.left,
                  top: position.top,
                  width: elemWidth,
                  height: elemHeight
                },
                horizontal: right < 0 ? 'left' : left > 0 ? 'right' : 'center',
                vertical: bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle'
              };
            if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
              feedback.horizontal = 'center';
            }
            if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
              feedback.vertical = 'middle';
            }
            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
              feedback.important = 'horizontal';
            } else {
              feedback.important = 'vertical';
            }
            options.using.call(this, props, feedback);
          };
        }
        elem.offset($.extend(position, { using: using }));
      });
    };
    $.ui.position = {
      fit: {
        left: function (position, data) {
          var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
          // element is wider than within
          if (data.collisionWidth > outerWidth) {
            // element is initially over the left side of within
            if (overLeft > 0 && overRight <= 0) {
              newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
              position.left += overLeft - newOverRight;  // element is initially over right side of within
            } else if (overRight > 0 && overLeft <= 0) {
              position.left = withinOffset;  // element is initially over both left and right sides of within
            } else {
              if (overLeft > overRight) {
                position.left = withinOffset + outerWidth - data.collisionWidth;
              } else {
                position.left = withinOffset;
              }
            }  // too far left -> align with left edge
          } else if (overLeft > 0) {
            position.left += overLeft;  // too far right -> align with right edge
          } else if (overRight > 0) {
            position.left -= overRight;  // adjust based on position and margin
          } else {
            position.left = max(position.left - collisionPosLeft, position.left);
          }
        },
        top: function (position, data) {
          var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
          // element is taller than within
          if (data.collisionHeight > outerHeight) {
            // element is initially over the top of within
            if (overTop > 0 && overBottom <= 0) {
              newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
              position.top += overTop - newOverBottom;  // element is initially over bottom of within
            } else if (overBottom > 0 && overTop <= 0) {
              position.top = withinOffset;  // element is initially over both top and bottom of within
            } else {
              if (overTop > overBottom) {
                position.top = withinOffset + outerHeight - data.collisionHeight;
              } else {
                position.top = withinOffset;
              }
            }  // too far up -> align with top
          } else if (overTop > 0) {
            position.top += overTop;  // too far down -> align with bottom edge
          } else if (overBottom > 0) {
            position.top -= overBottom;  // adjust based on position and margin
          } else {
            position.top = max(position.top - collisionPosTop, position.top);
          }
        }
      },
      flip: {
        left: function (position, data) {
          var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === 'left' ? -data.elemWidth : data.my[0] === 'right' ? data.elemWidth : 0, atOffset = data.at[0] === 'left' ? data.targetWidth : data.at[0] === 'right' ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
          if (overLeft < 0) {
            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
            if (newOverRight < 0 || newOverRight < abs(overLeft)) {
              position.left += myOffset + atOffset + offset;
            }
          } else if (overRight > 0) {
            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
            if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
              position.left += myOffset + atOffset + offset;
            }
          }
        },
        top: function (position, data) {
          var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === 'top', myOffset = top ? -data.elemHeight : data.my[1] === 'bottom' ? data.elemHeight : 0, atOffset = data.at[1] === 'top' ? data.targetHeight : data.at[1] === 'bottom' ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
          if (overTop < 0) {
            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
            if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
              position.top += myOffset + atOffset + offset;
            }
          } else if (overBottom > 0) {
            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
            if (newOverTop > 0 || abs(newOverTop) < overBottom) {
              position.top += myOffset + atOffset + offset;
            }
          }
        }
      },
      flipfit: {
        left: function () {
          $.ui.position.flip.left.apply(this, arguments);
          $.ui.position.fit.left.apply(this, arguments);
        },
        top: function () {
          $.ui.position.flip.top.apply(this, arguments);
          $.ui.position.fit.top.apply(this, arguments);
        }
      }
    };
    // fraction support test
    (function () {
      var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName('body')[0], div = document.createElement('div');
      //Create a "fake body" for testing based on method used in jQuery.support
      testElement = document.createElement(body ? 'div' : 'body');
      testElementStyle = {
        visibility: 'hidden',
        width: 0,
        height: 0,
        border: 0,
        margin: 0,
        background: 'none'
      };
      if (body) {
        $.extend(testElementStyle, {
          position: 'absolute',
          left: '-1000px',
          top: '-1000px'
        });
      }
      for (i in testElementStyle) {
        testElement.style[i] = testElementStyle[i];
      }
      testElement.appendChild(div);
      testElementParent = body || document.documentElement;
      testElementParent.insertBefore(testElement, testElementParent.firstChild);
      div.style.cssText = 'position: absolute; left: 10.7432222px;';
      offsetLeft = $(div).offset().left;
      supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
      testElement.innerHTML = '';
      testElementParent.removeChild(testElement);
    }());
  }());
  var position = $.ui.position;
  /*!
 * jQuery UI Accordion 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 */
  var accordion = $.widget('ui.accordion', {
      version: '1.11.4',
      options: {
        active: 0,
        animate: {},
        collapsible: false,
        event: 'click',
        header: '> li > :first-child,> :not(li):even',
        heightStyle: 'auto',
        icons: {
          activeHeader: 'ui-icon-triangle-1-s',
          header: 'ui-icon-triangle-1-e'
        },
        activate: null,
        beforeActivate: null
      },
      hideProps: {
        borderTopWidth: 'hide',
        borderBottomWidth: 'hide',
        paddingTop: 'hide',
        paddingBottom: 'hide',
        height: 'hide'
      },
      showProps: {
        borderTopWidth: 'show',
        borderBottomWidth: 'show',
        paddingTop: 'show',
        paddingBottom: 'show',
        height: 'show'
      },
      _create: function () {
        var options = this.options;
        this.prevShow = this.prevHide = $();
        this.element.addClass('ui-accordion ui-widget ui-helper-reset').attr('role', 'tablist');
        // don't allow collapsible: false and active: false / null
        if (!options.collapsible && (options.active === false || options.active == null)) {
          options.active = 0;
        }
        this._processPanels();
        // handle negative values
        if (options.active < 0) {
          options.active += this.headers.length;
        }
        this._refresh();
      },
      _getCreateEventData: function () {
        return {
          header: this.active,
          panel: !this.active.length ? $() : this.active.next()
        };
      },
      _createIcons: function () {
        var icons = this.options.icons;
        if (icons) {
          $('<span>').addClass('ui-accordion-header-icon ui-icon ' + icons.header).prependTo(this.headers);
          this.active.children('.ui-accordion-header-icon').removeClass(icons.header).addClass(icons.activeHeader);
          this.headers.addClass('ui-accordion-icons');
        }
      },
      _destroyIcons: function () {
        this.headers.removeClass('ui-accordion-icons').children('.ui-accordion-header-icon').remove();
      },
      _destroy: function () {
        var contents;
        // clean up main element
        this.element.removeClass('ui-accordion ui-widget ui-helper-reset').removeAttr('role');
        // clean up headers
        this.headers.removeClass('ui-accordion-header ui-accordion-header-active ui-state-default ' + 'ui-corner-all ui-state-active ui-state-disabled ui-corner-top').removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected').removeAttr('aria-controls').removeAttr('tabIndex').removeUniqueId();
        this._destroyIcons();
        // clean up content panels
        contents = this.headers.next().removeClass('ui-helper-reset ui-widget-content ui-corner-bottom ' + 'ui-accordion-content ui-accordion-content-active ui-state-disabled').css('display', '').removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby').removeUniqueId();
        if (this.options.heightStyle !== 'content') {
          contents.css('height', '');
        }
      },
      _setOption: function (key, value) {
        if (key === 'active') {
          // _activate() will handle invalid values and update this.options
          this._activate(value);
          return;
        }
        if (key === 'event') {
          if (this.options.event) {
            this._off(this.headers, this.options.event);
          }
          this._setupEvents(value);
        }
        this._super(key, value);
        // setting collapsible: false while collapsed; open first panel
        if (key === 'collapsible' && !value && this.options.active === false) {
          this._activate(0);
        }
        if (key === 'icons') {
          this._destroyIcons();
          if (value) {
            this._createIcons();
          }
        }
        // #5332 - opacity doesn't cascade to positioned elements in IE
        // so we need to add the disabled class to the headers and panels
        if (key === 'disabled') {
          this.element.toggleClass('ui-state-disabled', !!value).attr('aria-disabled', value);
          this.headers.add(this.headers.next()).toggleClass('ui-state-disabled', !!value);
        }
      },
      _keydown: function (event) {
        if (event.altKey || event.ctrlKey) {
          return;
        }
        var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
        switch (event.keyCode) {
        case keyCode.RIGHT:
        case keyCode.DOWN:
          toFocus = this.headers[(currentIndex + 1) % length];
          break;
        case keyCode.LEFT:
        case keyCode.UP:
          toFocus = this.headers[(currentIndex - 1 + length) % length];
          break;
        case keyCode.SPACE:
        case keyCode.ENTER:
          this._eventHandler(event);
          break;
        case keyCode.HOME:
          toFocus = this.headers[0];
          break;
        case keyCode.END:
          toFocus = this.headers[length - 1];
          break;
        }
        if (toFocus) {
          $(event.target).attr('tabIndex', -1);
          $(toFocus).attr('tabIndex', 0);
          toFocus.focus();
          event.preventDefault();
        }
      },
      _panelKeyDown: function (event) {
        if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
          $(event.currentTarget).prev().focus();
        }
      },
      refresh: function () {
        var options = this.options;
        this._processPanels();
        // was collapsed or no panel
        if (options.active === false && options.collapsible === true || !this.headers.length) {
          options.active = false;
          this.active = $();  // active false only when collapsible is true
        } else if (options.active === false) {
          this._activate(0);  // was active, but active panel is gone
        } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
          // all remaining panel are disabled
          if (this.headers.length === this.headers.find('.ui-state-disabled').length) {
            options.active = false;
            this.active = $();  // activate previous panel
          } else {
            this._activate(Math.max(0, options.active - 1));
          }  // was active, active panel still exists
        } else {
          // make sure active index is correct
          options.active = this.headers.index(this.active);
        }
        this._destroyIcons();
        this._refresh();
      },
      _processPanels: function () {
        var prevHeaders = this.headers, prevPanels = this.panels;
        this.headers = this.element.find(this.options.header).addClass('ui-accordion-header ui-state-default ui-corner-all');
        this.panels = this.headers.next().addClass('ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom').filter(':not(.ui-accordion-content-active)').hide();
        // Avoid memory leaks (#10056)
        if (prevPanels) {
          this._off(prevHeaders.not(this.headers));
          this._off(prevPanels.not(this.panels));
        }
      },
      _refresh: function () {
        var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent();
        this.active = this._findActive(options.active).addClass('ui-accordion-header-active ui-state-active ui-corner-top').removeClass('ui-corner-all');
        this.active.next().addClass('ui-accordion-content-active').show();
        this.headers.attr('role', 'tab').each(function () {
          var header = $(this), headerId = header.uniqueId().attr('id'), panel = header.next(), panelId = panel.uniqueId().attr('id');
          header.attr('aria-controls', panelId);
          panel.attr('aria-labelledby', headerId);
        }).next().attr('role', 'tabpanel');
        this.headers.not(this.active).attr({
          'aria-selected': 'false',
          'aria-expanded': 'false',
          tabIndex: -1
        }).next().attr({ 'aria-hidden': 'true' }).hide();
        // make sure at least one header is in the tab order
        if (!this.active.length) {
          this.headers.eq(0).attr('tabIndex', 0);
        } else {
          this.active.attr({
            'aria-selected': 'true',
            'aria-expanded': 'true',
            tabIndex: 0
          }).next().attr({ 'aria-hidden': 'false' });
        }
        this._createIcons();
        this._setupEvents(options.event);
        if (heightStyle === 'fill') {
          maxHeight = parent.height();
          this.element.siblings(':visible').each(function () {
            var elem = $(this), position = elem.css('position');
            if (position === 'absolute' || position === 'fixed') {
              return;
            }
            maxHeight -= elem.outerHeight(true);
          });
          this.headers.each(function () {
            maxHeight -= $(this).outerHeight(true);
          });
          this.headers.next().each(function () {
            $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
          }).css('overflow', 'auto');
        } else if (heightStyle === 'auto') {
          maxHeight = 0;
          this.headers.next().each(function () {
            maxHeight = Math.max(maxHeight, $(this).css('height', '').height());
          }).height(maxHeight);
        }
      },
      _activate: function (index) {
        var active = this._findActive(index)[0];
        // trying to activate the already active panel
        if (active === this.active[0]) {
          return;
        }
        // trying to collapse, simulate a click on the currently active header
        active = active || this.active[0];
        this._eventHandler({
          target: active,
          currentTarget: active,
          preventDefault: $.noop
        });
      },
      _findActive: function (selector) {
        return typeof selector === 'number' ? this.headers.eq(selector) : $();
      },
      _setupEvents: function (event) {
        var events = { keydown: '_keydown' };
        if (event) {
          $.each(event.split(' '), function (index, eventName) {
            events[eventName] = '_eventHandler';
          });
        }
        this._off(this.headers.add(this.headers.next()));
        this._on(this.headers, events);
        this._on(this.headers.next(), { keydown: '_panelKeyDown' });
        this._hoverable(this.headers);
        this._focusable(this.headers);
      },
      _eventHandler: function (event) {
        var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
            oldHeader: active,
            oldPanel: toHide,
            newHeader: collapsing ? $() : clicked,
            newPanel: toShow
          };
        event.preventDefault();
        if (clickedIsActive && !options.collapsible || this._trigger('beforeActivate', event, eventData) === false) {
          return;
        }
        options.active = collapsing ? false : this.headers.index(clicked);
        // when the call to ._toggle() comes after the class changes
        // it causes a very odd bug in IE 8 (see #6720)
        this.active = clickedIsActive ? $() : clicked;
        this._toggle(eventData);
        // switch classes
        // corner classes on the previously active header stay after the animation
        active.removeClass('ui-accordion-header-active ui-state-active');
        if (options.icons) {
          active.children('.ui-accordion-header-icon').removeClass(options.icons.activeHeader).addClass(options.icons.header);
        }
        if (!clickedIsActive) {
          clicked.removeClass('ui-corner-all').addClass('ui-accordion-header-active ui-state-active ui-corner-top');
          if (options.icons) {
            clicked.children('.ui-accordion-header-icon').removeClass(options.icons.header).addClass(options.icons.activeHeader);
          }
          clicked.next().addClass('ui-accordion-content-active');
        }
      },
      _toggle: function (data) {
        var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
        // handle activating a panel during the animation for another activation
        this.prevShow.add(this.prevHide).stop(true, true);
        this.prevShow = toShow;
        this.prevHide = toHide;
        if (this.options.animate) {
          this._animate(toShow, toHide, data);
        } else {
          toHide.hide();
          toShow.show();
          this._toggleComplete(data);
        }
        toHide.attr({ 'aria-hidden': 'true' });
        toHide.prev().attr({
          'aria-selected': 'false',
          'aria-expanded': 'false'
        });
        // if we're switching panels, remove the old header from the tab order
        // if we're opening from collapsed state, remove the previous header from the tab order
        // if we're collapsing, then keep the collapsing header in the tab order
        if (toShow.length && toHide.length) {
          toHide.prev().attr({
            'tabIndex': -1,
            'aria-expanded': 'false'
          });
        } else if (toShow.length) {
          this.headers.filter(function () {
            return parseInt($(this).attr('tabIndex'), 10) === 0;
          }).attr('tabIndex', -1);
        }
        toShow.attr('aria-hidden', 'false').prev().attr({
          'aria-selected': 'true',
          'aria-expanded': 'true',
          tabIndex: 0
        });
      },
      _animate: function (toShow, toHide, data) {
        var total, easing, duration, that = this, adjust = 0, boxSizing = toShow.css('box-sizing'), down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function () {
            that._toggleComplete(data);
          };
        if (typeof options === 'number') {
          duration = options;
        }
        if (typeof options === 'string') {
          easing = options;
        }
        // fall back from options to animation in case of partial down settings
        easing = easing || options.easing || animate.easing;
        duration = duration || options.duration || animate.duration;
        if (!toHide.length) {
          return toShow.animate(this.showProps, duration, easing, complete);
        }
        if (!toShow.length) {
          return toHide.animate(this.hideProps, duration, easing, complete);
        }
        total = toShow.show().outerHeight();
        toHide.animate(this.hideProps, {
          duration: duration,
          easing: easing,
          step: function (now, fx) {
            fx.now = Math.round(now);
          }
        });
        toShow.hide().animate(this.showProps, {
          duration: duration,
          easing: easing,
          complete: complete,
          step: function (now, fx) {
            fx.now = Math.round(now);
            if (fx.prop !== 'height') {
              if (boxSizing === 'content-box') {
                adjust += fx.now;
              }
            } else if (that.options.heightStyle !== 'content') {
              fx.now = Math.round(total - toHide.outerHeight() - adjust);
              adjust = 0;
            }
          }
        });
      },
      _toggleComplete: function (data) {
        var toHide = data.oldPanel;
        toHide.removeClass('ui-accordion-content-active').prev().removeClass('ui-corner-top').addClass('ui-corner-all');
        // Work around for rendering bug in IE (#5421)
        if (toHide.length) {
          toHide.parent()[0].className = toHide.parent()[0].className;
        }
        this._trigger('activate', null, data);
      }
    });
  /*!
 * jQuery UI Menu 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 */
  var menu = $.widget('ui.menu', {
      version: '1.11.4',
      defaultElement: '<ul>',
      delay: 300,
      options: {
        icons: { submenu: 'ui-icon-carat-1-e' },
        items: '> *',
        menus: 'ul',
        position: {
          my: 'left-1 top',
          at: 'right top'
        },
        role: 'menu',
        blur: null,
        focus: null,
        select: null
      },
      _create: function () {
        this.activeMenu = this.element;
        // Flag used to prevent firing of the click handler
        // as the event bubbles up through nested menus
        this.mouseHandled = false;
        this.element.uniqueId().addClass('ui-menu ui-widget ui-widget-content').toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length).attr({
          role: this.options.role,
          tabIndex: 0
        });
        if (this.options.disabled) {
          this.element.addClass('ui-state-disabled').attr('aria-disabled', 'true');
        }
        this._on({
          'mousedown .ui-menu-item': function (event) {
            event.preventDefault();
          },
          'click .ui-menu-item': function (event) {
            var target = $(event.target);
            if (!this.mouseHandled && target.not('.ui-state-disabled').length) {
              this.select(event);
              // Only set the mouseHandled flag if the event will bubble, see #9469.
              if (!event.isPropagationStopped()) {
                this.mouseHandled = true;
              }
              // Open submenu on click
              if (target.has('.ui-menu').length) {
                this.expand(event);
              } else if (!this.element.is(':focus') && $(this.document[0].activeElement).closest('.ui-menu').length) {
                // Redirect focus to the menu
                this.element.trigger('focus', [true]);
                // If the active item is on the top level, let it stay active.
                // Otherwise, blur the active item since it is no longer visible.
                if (this.active && this.active.parents('.ui-menu').length === 1) {
                  clearTimeout(this.timer);
                }
              }
            }
          },
          'mouseenter .ui-menu-item': function (event) {
            // Ignore mouse events while typeahead is active, see #10458.
            // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
            // is over an item in the menu
            if (this.previousFilter) {
              return;
            }
            var target = $(event.currentTarget);
            // Remove ui-state-active class from siblings of the newly focused menu item
            // to avoid a jump caused by adjacent elements both having a class with a border
            target.siblings('.ui-state-active').removeClass('ui-state-active');
            this.focus(event, target);
          },
          mouseleave: 'collapseAll',
          'mouseleave .ui-menu': 'collapseAll',
          focus: function (event, keepActiveItem) {
            // If there's already an active item, keep it active
            // If not, activate the first item
            var item = this.active || this.element.find(this.options.items).eq(0);
            if (!keepActiveItem) {
              this.focus(event, item);
            }
          },
          blur: function (event) {
            this._delay(function () {
              if (!$.contains(this.element[0], this.document[0].activeElement)) {
                this.collapseAll(event);
              }
            });
          },
          keydown: '_keydown'
        });
        this.refresh();
        // Clicks outside of a menu collapse any open menus
        this._on(this.document, {
          click: function (event) {
            if (this._closeOnDocumentClick(event)) {
              this.collapseAll(event);
            }
            // Reset the mouseHandled flag
            this.mouseHandled = false;
          }
        });
      },
      _destroy: function () {
        // Destroy (sub)menus
        this.element.removeAttr('aria-activedescendant').find('.ui-menu').addBack().removeClass('ui-menu ui-widget ui-widget-content ui-menu-icons ui-front').removeAttr('role').removeAttr('tabIndex').removeAttr('aria-labelledby').removeAttr('aria-expanded').removeAttr('aria-hidden').removeAttr('aria-disabled').removeUniqueId().show();
        // Destroy menu items
        this.element.find('.ui-menu-item').removeClass('ui-menu-item').removeAttr('role').removeAttr('aria-disabled').removeUniqueId().removeClass('ui-state-hover').removeAttr('tabIndex').removeAttr('role').removeAttr('aria-haspopup').children().each(function () {
          var elem = $(this);
          if (elem.data('ui-menu-submenu-carat')) {
            elem.remove();
          }
        });
        // Destroy menu dividers
        this.element.find('.ui-menu-divider').removeClass('ui-menu-divider ui-widget-content');
      },
      _keydown: function (event) {
        var match, prev, character, skip, preventDefault = true;
        switch (event.keyCode) {
        case $.ui.keyCode.PAGE_UP:
          this.previousPage(event);
          break;
        case $.ui.keyCode.PAGE_DOWN:
          this.nextPage(event);
          break;
        case $.ui.keyCode.HOME:
          this._move('first', 'first', event);
          break;
        case $.ui.keyCode.END:
          this._move('last', 'last', event);
          break;
        case $.ui.keyCode.UP:
          this.previous(event);
          break;
        case $.ui.keyCode.DOWN:
          this.next(event);
          break;
        case $.ui.keyCode.LEFT:
          this.collapse(event);
          break;
        case $.ui.keyCode.RIGHT:
          if (this.active && !this.active.is('.ui-state-disabled')) {
            this.expand(event);
          }
          break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
          this._activate(event);
          break;
        case $.ui.keyCode.ESCAPE:
          this.collapse(event);
          break;
        default:
          preventDefault = false;
          prev = this.previousFilter || '';
          character = String.fromCharCode(event.keyCode);
          skip = false;
          clearTimeout(this.filterTimer);
          if (character === prev) {
            skip = true;
          } else {
            character = prev + character;
          }
          match = this._filterMenuItems(character);
          match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll('.ui-menu-item') : match;
          // If no matches on the current filter, reset to the last character pressed
          // to move down the menu to the first item that starts with that character
          if (!match.length) {
            character = String.fromCharCode(event.keyCode);
            match = this._filterMenuItems(character);
          }
          if (match.length) {
            this.focus(event, match);
            this.previousFilter = character;
            this.filterTimer = this._delay(function () {
              delete this.previousFilter;
            }, 1000);
          } else {
            delete this.previousFilter;
          }
        }
        if (preventDefault) {
          event.preventDefault();
        }
      },
      _activate: function (event) {
        if (!this.active.is('.ui-state-disabled')) {
          if (this.active.is('[aria-haspopup=\'true\']')) {
            this.expand(event);
          } else {
            this.select(event);
          }
        }
      },
      refresh: function () {
        var menus, items, that = this, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
        this.element.toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length);
        // Initialize nested menus
        submenus.filter(':not(.ui-menu)').addClass('ui-menu ui-widget ui-widget-content ui-front').hide().attr({
          role: this.options.role,
          'aria-hidden': 'true',
          'aria-expanded': 'false'
        }).each(function () {
          var menu = $(this), item = menu.parent(), submenuCarat = $('<span>').addClass('ui-menu-icon ui-icon ' + icon).data('ui-menu-submenu-carat', true);
          item.attr('aria-haspopup', 'true').prepend(submenuCarat);
          menu.attr('aria-labelledby', item.attr('id'));
        });
        menus = submenus.add(this.element);
        items = menus.find(this.options.items);
        // Initialize menu-items containing spaces and/or dashes only as dividers
        items.not('.ui-menu-item').each(function () {
          var item = $(this);
          if (that._isDivider(item)) {
            item.addClass('ui-widget-content ui-menu-divider');
          }
        });
        // Don't refresh list items that are already adapted
        items.not('.ui-menu-item, .ui-menu-divider').addClass('ui-menu-item').uniqueId().attr({
          tabIndex: -1,
          role: this._itemRole()
        });
        // Add aria-disabled attribute to any disabled menu item
        items.filter('.ui-state-disabled').attr('aria-disabled', 'true');
        // If the active item has been removed, blur the menu
        if (this.active && !$.contains(this.element[0], this.active[0])) {
          this.blur();
        }
      },
      _itemRole: function () {
        return {
          menu: 'menuitem',
          listbox: 'option'
        }[this.options.role];
      },
      _setOption: function (key, value) {
        if (key === 'icons') {
          this.element.find('.ui-menu-icon').removeClass(this.options.icons.submenu).addClass(value.submenu);
        }
        if (key === 'disabled') {
          this.element.toggleClass('ui-state-disabled', !!value).attr('aria-disabled', value);
        }
        this._super(key, value);
      },
      focus: function (event, item) {
        var nested, focused;
        this.blur(event, event && event.type === 'focus');
        this._scrollIntoView(item);
        this.active = item.first();
        focused = this.active.addClass('ui-state-focus').removeClass('ui-state-active');
        // Only update aria-activedescendant if there's a role
        // otherwise we assume focus is managed elsewhere
        if (this.options.role) {
          this.element.attr('aria-activedescendant', focused.attr('id'));
        }
        // Highlight active parent menu item, if any
        this.active.parent().closest('.ui-menu-item').addClass('ui-state-active');
        if (event && event.type === 'keydown') {
          this._close();
        } else {
          this.timer = this._delay(function () {
            this._close();
          }, this.delay);
        }
        nested = item.children('.ui-menu');
        if (nested.length && event && /^mouse/.test(event.type)) {
          this._startOpening(nested);
        }
        this.activeMenu = item.parent();
        this._trigger('focus', event, { item: item });
      },
      _scrollIntoView: function (item) {
        var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
        if (this._hasScroll()) {
          borderTop = parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0;
          paddingTop = parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0;
          offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
          scroll = this.activeMenu.scrollTop();
          elementHeight = this.activeMenu.height();
          itemHeight = item.outerHeight();
          if (offset < 0) {
            this.activeMenu.scrollTop(scroll + offset);
          } else if (offset + itemHeight > elementHeight) {
            this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
          }
        }
      },
      blur: function (event, fromFocus) {
        if (!fromFocus) {
          clearTimeout(this.timer);
        }
        if (!this.active) {
          return;
        }
        this.active.removeClass('ui-state-focus');
        this.active = null;
        this._trigger('blur', event, { item: this.active });
      },
      _startOpening: function (submenu) {
        clearTimeout(this.timer);
        // Don't open if already open fixes a Firefox bug that caused a .5 pixel
        // shift in the submenu position when mousing over the carat icon
        if (submenu.attr('aria-hidden') !== 'true') {
          return;
        }
        this.timer = this._delay(function () {
          this._close();
          this._open(submenu);
        }, this.delay);
      },
      _open: function (submenu) {
        var position = $.extend({ of: this.active }, this.options.position);
        clearTimeout(this.timer);
        this.element.find('.ui-menu').not(submenu.parents('.ui-menu')).hide().attr('aria-hidden', 'true');
        submenu.show().removeAttr('aria-hidden').attr('aria-expanded', 'true').position(position);
      },
      collapseAll: function (event, all) {
        clearTimeout(this.timer);
        this.timer = this._delay(function () {
          // If we were passed an event, look for the submenu that contains the event
          var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find('.ui-menu'));
          // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
          if (!currentMenu.length) {
            currentMenu = this.element;
          }
          this._close(currentMenu);
          this.blur(event);
          this.activeMenu = currentMenu;
        }, this.delay);
      },
      _close: function (startMenu) {
        if (!startMenu) {
          startMenu = this.active ? this.active.parent() : this.element;
        }
        startMenu.find('.ui-menu').hide().attr('aria-hidden', 'true').attr('aria-expanded', 'false').end().find('.ui-state-active').not('.ui-state-focus').removeClass('ui-state-active');
      },
      _closeOnDocumentClick: function (event) {
        return !$(event.target).closest('.ui-menu').length;
      },
      _isDivider: function (item) {
        // Match hyphen, em dash, en dash
        return !/[^\-\u2014\u2013\s]/.test(item.text());
      },
      collapse: function (event) {
        var newItem = this.active && this.active.parent().closest('.ui-menu-item', this.element);
        if (newItem && newItem.length) {
          this._close();
          this.focus(event, newItem);
        }
      },
      expand: function (event) {
        var newItem = this.active && this.active.children('.ui-menu ').find(this.options.items).first();
        if (newItem && newItem.length) {
          this._open(newItem.parent());
          // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
          this._delay(function () {
            this.focus(event, newItem);
          });
        }
      },
      next: function (event) {
        this._move('next', 'first', event);
      },
      previous: function (event) {
        this._move('prev', 'last', event);
      },
      isFirstItem: function () {
        return this.active && !this.active.prevAll('.ui-menu-item').length;
      },
      isLastItem: function () {
        return this.active && !this.active.nextAll('.ui-menu-item').length;
      },
      _move: function (direction, filter, event) {
        var next;
        if (this.active) {
          if (direction === 'first' || direction === 'last') {
            next = this.active[direction === 'first' ? 'prevAll' : 'nextAll']('.ui-menu-item').eq(-1);
          } else {
            next = this.active[direction + 'All']('.ui-menu-item').eq(0);
          }
        }
        if (!next || !next.length || !this.active) {
          next = this.activeMenu.find(this.options.items)[filter]();
        }
        this.focus(event, next);
      },
      nextPage: function (event) {
        var item, base, height;
        if (!this.active) {
          this.next(event);
          return;
        }
        if (this.isLastItem()) {
          return;
        }
        if (this._hasScroll()) {
          base = this.active.offset().top;
          height = this.element.height();
          this.active.nextAll('.ui-menu-item').each(function () {
            item = $(this);
            return item.offset().top - base - height < 0;
          });
          this.focus(event, item);
        } else {
          this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? 'first' : 'last']());
        }
      },
      previousPage: function (event) {
        var item, base, height;
        if (!this.active) {
          this.next(event);
          return;
        }
        if (this.isFirstItem()) {
          return;
        }
        if (this._hasScroll()) {
          base = this.active.offset().top;
          height = this.element.height();
          this.active.prevAll('.ui-menu-item').each(function () {
            item = $(this);
            return item.offset().top - base + height > 0;
          });
          this.focus(event, item);
        } else {
          this.focus(event, this.activeMenu.find(this.options.items).first());
        }
      },
      _hasScroll: function () {
        return this.element.outerHeight() < this.element.prop('scrollHeight');
      },
      select: function (event) {
        // TODO: It should never be possible to not have an active item at this
        // point, but the tests don't trigger mouseenter before click.
        this.active = this.active || $(event.target).closest('.ui-menu-item');
        var ui = { item: this.active };
        if (!this.active.has('.ui-menu').length) {
          this.collapseAll(event, true);
        }
        this._trigger('select', event, ui);
      },
      _filterMenuItems: function (character) {
        var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&'), regex = new RegExp('^' + escapedCharacter, 'i');
        return this.activeMenu.find(this.options.items).filter('.ui-menu-item').filter(function () {
          return regex.test($.trim($(this).text()));
        });
      }
    });
  /*!
 * jQuery UI Autocomplete 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 */
  $.widget('ui.autocomplete', {
    version: '1.11.4',
    defaultElement: '<input>',
    options: {
      appendTo: null,
      autoFocus: false,
      delay: 300,
      minLength: 1,
      position: {
        my: 'left top',
        at: 'left bottom',
        collision: 'none'
      },
      source: null,
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },
    requestIndex: 0,
    pending: 0,
    _create: function () {
      // Some browsers only repeat keydown events, not keypress events,
      // so we use the suppressKeyPress flag to determine if we've already
      // handled the keydown event. #7269
      // Unfortunately the code for & in keypress is the same as the up arrow,
      // so we use the suppressKeyPressRepeat flag to avoid handling keypress
      // events when we know the keydown event was used to modify the
      // search term. #7799
      var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === 'textarea', isInput = nodeName === 'input';
      this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop('isContentEditable');
      this.valueMethod = this.element[isTextarea || isInput ? 'val' : 'text'];
      this.isNewMenu = true;
      this.element.addClass('ui-autocomplete-input').attr('autocomplete', 'off');
      this._on(this.element, {
        keydown: function (event) {
          if (this.element.prop('readOnly')) {
            suppressKeyPress = true;
            suppressInput = true;
            suppressKeyPressRepeat = true;
            return;
          }
          suppressKeyPress = false;
          suppressInput = false;
          suppressKeyPressRepeat = false;
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
          case keyCode.PAGE_UP:
            suppressKeyPress = true;
            this._move('previousPage', event);
            break;
          case keyCode.PAGE_DOWN:
            suppressKeyPress = true;
            this._move('nextPage', event);
            break;
          case keyCode.UP:
            suppressKeyPress = true;
            this._keyEvent('previous', event);
            break;
          case keyCode.DOWN:
            suppressKeyPress = true;
            this._keyEvent('next', event);
            break;
          case keyCode.ENTER:
            // when menu is open and has focus
            if (this.menu.active) {
              // #6055 - Opera still allows the keypress to occur
              // which causes forms to submit
              suppressKeyPress = true;
              event.preventDefault();
              this.menu.select(event);
            }
            break;
          case keyCode.TAB:
            if (this.menu.active) {
              this.menu.select(event);
            }
            break;
          case keyCode.ESCAPE:
            if (this.menu.element.is(':visible')) {
              if (!this.isMultiLine) {
                this._value(this.term);
              }
              this.close(event);
              // Different browsers have different default behavior for escape
              // Single press can mean undo or clear
              // Double press in IE means clear the whole form
              event.preventDefault();
            }
            break;
          default:
            suppressKeyPressRepeat = true;
            // search timeout should be triggered before the input value is changed
            this._searchTimeout(event);
            break;
          }
        },
        keypress: function (event) {
          if (suppressKeyPress) {
            suppressKeyPress = false;
            if (!this.isMultiLine || this.menu.element.is(':visible')) {
              event.preventDefault();
            }
            return;
          }
          if (suppressKeyPressRepeat) {
            return;
          }
          // replicate some key handlers to allow them to repeat in Firefox and Opera
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
          case keyCode.PAGE_UP:
            this._move('previousPage', event);
            break;
          case keyCode.PAGE_DOWN:
            this._move('nextPage', event);
            break;
          case keyCode.UP:
            this._keyEvent('previous', event);
            break;
          case keyCode.DOWN:
            this._keyEvent('next', event);
            break;
          }
        },
        input: function (event) {
          if (suppressInput) {
            suppressInput = false;
            event.preventDefault();
            return;
          }
          this._searchTimeout(event);
        },
        focus: function () {
          this.selectedItem = null;
          this.previous = this._value();
        },
        blur: function (event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }
          clearTimeout(this.searching);
          this.close(event);
          this._change(event);
        }
      });
      this._initSource();
      this.menu = $('<ul>').addClass('ui-autocomplete ui-front').appendTo(this._appendTo()).menu({ role: null }).hide().menu('instance');
      this._on(this.menu.element, {
        mousedown: function (event) {
          // prevent moving focus out of the text field
          event.preventDefault();
          // IE doesn't prevent moving focus even with event.preventDefault()
          // so we set a flag to know when we should ignore the blur event
          this.cancelBlur = true;
          this._delay(function () {
            delete this.cancelBlur;
          });
          // clicking on the scrollbar causes focus to shift to the body
          // but we can't detect a mouseup or a click immediately afterward
          // so we have to track the next mousedown and close the menu if
          // the user clicks somewhere outside of the autocomplete
          var menuElement = this.menu.element[0];
          if (!$(event.target).closest('.ui-menu-item').length) {
            this._delay(function () {
              var that = this;
              this.document.one('mousedown', function (event) {
                if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                  that.close();
                }
              });
            });
          }
        },
        menufocus: function (event, ui) {
          var label, item;
          // support: Firefox
          // Prevent accidental activation of menu items in Firefox (#7024 #9118)
          if (this.isNewMenu) {
            this.isNewMenu = false;
            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
              this.menu.blur();
              this.document.one('mousemove', function () {
                $(event.target).trigger(event.originalEvent);
              });
              return;
            }
          }
          item = ui.item.data('ui-autocomplete-item');
          if (false !== this._trigger('focus', event, { item: item })) {
            // use value to match what will end up in the input, if it was a key event
            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
              this._value(item.value);
            }
          }
          // Announce the value in the liveRegion
          label = ui.item.attr('aria-label') || item.value;
          if (label && $.trim(label).length) {
            this.liveRegion.children().hide();
            $('<div>').text(label).appendTo(this.liveRegion);
          }
        },
        menuselect: function (event, ui) {
          var item = ui.item.data('ui-autocomplete-item'), previous = this.previous;
          // only trigger when focus was lost (click on menu)
          if (this.element[0] !== this.document[0].activeElement) {
            this.element.focus();
            this.previous = previous;
            // #6109 - IE triggers two focus events and the second
            // is asynchronous, so we need to reset the previous
            // term synchronously and asynchronously :-(
            this._delay(function () {
              this.previous = previous;
              this.selectedItem = item;
            });
          }
          if (false !== this._trigger('select', event, { item: item })) {
            this._value(item.value);
          }
          // reset the term after the select event
          // this allows custom select handling to work properly
          this.term = this._value();
          this.close(event);
          this.selectedItem = item;
        }
      });
      this.liveRegion = $('<span>', {
        role: 'status',
        'aria-live': 'assertive',
        'aria-relevant': 'additions'
      }).addClass('ui-helper-hidden-accessible').appendTo(this.document[0].body);
      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr('autocomplete');
        }
      });
    },
    _destroy: function () {
      clearTimeout(this.searching);
      this.element.removeClass('ui-autocomplete-input').removeAttr('autocomplete');
      this.menu.element.remove();
      this.liveRegion.remove();
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'source') {
        this._initSource();
      }
      if (key === 'appendTo') {
        this.menu.element.appendTo(this._appendTo());
      }
      if (key === 'disabled' && value && this.xhr) {
        this.xhr.abort();
      }
    },
    _appendTo: function () {
      var element = this.options.appendTo;
      if (element) {
        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
      }
      if (!element || !element[0]) {
        element = this.element.closest('.ui-front');
      }
      if (!element.length) {
        element = this.document[0].body;
      }
      return element;
    },
    _initSource: function () {
      var array, url, that = this;
      if ($.isArray(this.options.source)) {
        array = this.options.source;
        this.source = function (request, response) {
          response($.ui.autocomplete.filter(array, request.term));
        };
      } else if (typeof this.options.source === 'string') {
        url = this.options.source;
        this.source = function (request, response) {
          if (that.xhr) {
            that.xhr.abort();
          }
          that.xhr = $.ajax({
            url: url,
            data: request,
            dataType: 'json',
            success: function (data) {
              response(data);
            },
            error: function () {
              response([]);
            }
          });
        };
      } else {
        this.source = this.options.source;
      }
    },
    _searchTimeout: function (event) {
      clearTimeout(this.searching);
      this.searching = this._delay(function () {
        // Search if the value has changed, or if the user retypes the same value (see #7434)
        var equalValues = this.term === this._value(), menuVisible = this.menu.element.is(':visible'), modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
        if (!equalValues || equalValues && !menuVisible && !modifierKey) {
          this.selectedItem = null;
          this.search(null, event);
        }
      }, this.options.delay);
    },
    search: function (value, event) {
      value = value != null ? value : this._value();
      // always save the actual value, not the one passed as an argument
      this.term = this._value();
      if (value.length < this.options.minLength) {
        return this.close(event);
      }
      if (this._trigger('search', event) === false) {
        return;
      }
      return this._search(value);
    },
    _search: function (value) {
      this.pending++;
      this.element.addClass('ui-autocomplete-loading');
      this.cancelSearch = false;
      this.source({ term: value }, this._response());
    },
    _response: function () {
      var index = ++this.requestIndex;
      return $.proxy(function (content) {
        if (index === this.requestIndex) {
          this.__response(content);
        }
        this.pending--;
        if (!this.pending) {
          this.element.removeClass('ui-autocomplete-loading');
        }
      }, this);
    },
    __response: function (content) {
      if (content) {
        content = this._normalize(content);
      }
      this._trigger('response', null, { content: content });
      if (!this.options.disabled && content && content.length && !this.cancelSearch) {
        this._suggest(content);
        this._trigger('open');
      } else {
        // use ._close() instead of .close() so we don't cancel future searches
        this._close();
      }
    },
    close: function (event) {
      this.cancelSearch = true;
      this._close(event);
    },
    _close: function (event) {
      if (this.menu.element.is(':visible')) {
        this.menu.element.hide();
        this.menu.blur();
        this.isNewMenu = true;
        this._trigger('close', event);
      }
    },
    _change: function (event) {
      if (this.previous !== this._value()) {
        this._trigger('change', event, { item: this.selectedItem });
      }
    },
    _normalize: function (items) {
      // assume all items have the right format when the first item is complete
      if (items.length && items[0].label && items[0].value) {
        return items;
      }
      return $.map(items, function (item) {
        if (typeof item === 'string') {
          return {
            label: item,
            value: item
          };
        }
        return $.extend({}, item, {
          label: item.label || item.value,
          value: item.value || item.label
        });
      });
    },
    _suggest: function (items) {
      var ul = this.menu.element.empty();
      this._renderMenu(ul, items);
      this.isNewMenu = true;
      this.menu.refresh();
      // size and position menu
      ul.show();
      this._resizeMenu();
      ul.position($.extend({ of: this.element }, this.options.position));
      if (this.options.autoFocus) {
        this.menu.next();
      }
    },
    _resizeMenu: function () {
      var ul = this.menu.element;
      ul.outerWidth(Math.max(ul.width('').outerWidth() + 1, this.element.outerWidth()));
    },
    _renderMenu: function (ul, items) {
      var that = this;
      $.each(items, function (index, item) {
        that._renderItemData(ul, item);
      });
    },
    _renderItemData: function (ul, item) {
      return this._renderItem(ul, item).data('ui-autocomplete-item', item);
    },
    _renderItem: function (ul, item) {
      return $('<li>').text(item.label).appendTo(ul);
    },
    _move: function (direction, event) {
      if (!this.menu.element.is(':visible')) {
        this.search(null, event);
        return;
      }
      if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
        if (!this.isMultiLine) {
          this._value(this.term);
        }
        this.menu.blur();
        return;
      }
      this.menu[direction](event);
    },
    widget: function () {
      return this.menu.element;
    },
    _value: function () {
      return this.valueMethod.apply(this.element, arguments);
    },
    _keyEvent: function (keyEvent, event) {
      if (!this.isMultiLine || this.menu.element.is(':visible')) {
        this._move(keyEvent, event);
        // prevents moving cursor to beginning/end of the text field in some browsers
        event.preventDefault();
      }
    }
  });
  $.extend($.ui.autocomplete, {
    escapeRegex: function (value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
    },
    filter: function (array, term) {
      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), 'i');
      return $.grep(array, function (value) {
        return matcher.test(value.label || value.value || value);
      });
    }
  });
  // live region extension, adding a `messages` option
  // NOTE: This is an experimental API. We are still investigating
  // a full solution for string manipulation and internationalization.
  $.widget('ui.autocomplete', $.ui.autocomplete, {
    options: {
      messages: {
        noResults: 'No search results.',
        results: function (amount) {
          return amount + (amount > 1 ? ' results are' : ' result is') + ' available, use up and down arrow keys to navigate.';
        }
      }
    },
    __response: function (content) {
      var message;
      this._superApply(arguments);
      if (this.options.disabled || this.cancelSearch) {
        return;
      }
      if (content && content.length) {
        message = this.options.messages.results(content.length);
      } else {
        message = this.options.messages.noResults;
      }
      this.liveRegion.children().hide();
      $('<div>').text(message).appendTo(this.liveRegion);
    }
  });
  var autocomplete = $.ui.autocomplete;
  /*!
 * jQuery UI Button 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 */
  var lastActive, baseClasses = 'ui-button ui-widget ui-state-default ui-corner-all', typeClasses = 'ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only', formResetHandler = function () {
      var form = $(this);
      setTimeout(function () {
        form.find(':ui-button').button('refresh');
      }, 1);
    }, radioGroup = function (radio) {
      var name = radio.name, form = radio.form, radios = $([]);
      if (name) {
        name = name.replace(/'/g, '\\\'');
        if (form) {
          radios = $(form).find('[name=\'' + name + '\'][type=radio]');
        } else {
          radios = $('[name=\'' + name + '\'][type=radio]', radio.ownerDocument).filter(function () {
            return !this.form;
          });
        }
      }
      return radios;
    };
  $.widget('ui.button', {
    version: '1.11.4',
    defaultElement: '<button>',
    options: {
      disabled: null,
      text: true,
      label: null,
      icons: {
        primary: null,
        secondary: null
      }
    },
    _create: function () {
      this.element.closest('form').unbind('reset' + this.eventNamespace).bind('reset' + this.eventNamespace, formResetHandler);
      if (typeof this.options.disabled !== 'boolean') {
        this.options.disabled = !!this.element.prop('disabled');
      } else {
        this.element.prop('disabled', this.options.disabled);
      }
      this._determineButtonType();
      this.hasTitle = !!this.buttonElement.attr('title');
      var that = this, options = this.options, toggleButton = this.type === 'checkbox' || this.type === 'radio', activeClass = !toggleButton ? 'ui-state-active' : '';
      if (options.label === null) {
        options.label = this.type === 'input' ? this.buttonElement.val() : this.buttonElement.html();
      }
      this._hoverable(this.buttonElement);
      this.buttonElement.addClass(baseClasses).attr('role', 'button').bind('mouseenter' + this.eventNamespace, function () {
        if (options.disabled) {
          return;
        }
        if (this === lastActive) {
          $(this).addClass('ui-state-active');
        }
      }).bind('mouseleave' + this.eventNamespace, function () {
        if (options.disabled) {
          return;
        }
        $(this).removeClass(activeClass);
      }).bind('click' + this.eventNamespace, function (event) {
        if (options.disabled) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      });
      // Can't use _focusable() because the element that receives focus
      // and the element that gets the ui-state-focus class are different
      this._on({
        focus: function () {
          this.buttonElement.addClass('ui-state-focus');
        },
        blur: function () {
          this.buttonElement.removeClass('ui-state-focus');
        }
      });
      if (toggleButton) {
        this.element.bind('change' + this.eventNamespace, function () {
          that.refresh();
        });
      }
      if (this.type === 'checkbox') {
        this.buttonElement.bind('click' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
        });
      } else if (this.type === 'radio') {
        this.buttonElement.bind('click' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).addClass('ui-state-active');
          that.buttonElement.attr('aria-pressed', 'true');
          var radio = that.element[0];
          radioGroup(radio).not(radio).map(function () {
            return $(this).button('widget')[0];
          }).removeClass('ui-state-active').attr('aria-pressed', 'false');
        });
      } else {
        this.buttonElement.bind('mousedown' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).addClass('ui-state-active');
          lastActive = this;
          that.document.one('mouseup', function () {
            lastActive = null;
          });
        }).bind('mouseup' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).removeClass('ui-state-active');
        }).bind('keydown' + this.eventNamespace, function (event) {
          if (options.disabled) {
            return false;
          }
          if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
            $(this).addClass('ui-state-active');
          }
        }).bind('keyup' + this.eventNamespace + ' blur' + this.eventNamespace, function () {
          $(this).removeClass('ui-state-active');
        });
        if (this.buttonElement.is('a')) {
          this.buttonElement.keyup(function (event) {
            if (event.keyCode === $.ui.keyCode.SPACE) {
              // TODO pass through original event correctly (just as 2nd argument doesn't work)
              $(this).click();
            }
          });
        }
      }
      this._setOption('disabled', options.disabled);
      this._resetButton();
    },
    _determineButtonType: function () {
      var ancestor, labelSelector, checked;
      if (this.element.is('[type=checkbox]')) {
        this.type = 'checkbox';
      } else if (this.element.is('[type=radio]')) {
        this.type = 'radio';
      } else if (this.element.is('input')) {
        this.type = 'input';
      } else {
        this.type = 'button';
      }
      if (this.type === 'checkbox' || this.type === 'radio') {
        // we don't search against the document in case the element
        // is disconnected from the DOM
        ancestor = this.element.parents().last();
        labelSelector = 'label[for=\'' + this.element.attr('id') + '\']';
        this.buttonElement = ancestor.find(labelSelector);
        if (!this.buttonElement.length) {
          ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
          this.buttonElement = ancestor.filter(labelSelector);
          if (!this.buttonElement.length) {
            this.buttonElement = ancestor.find(labelSelector);
          }
        }
        this.element.addClass('ui-helper-hidden-accessible');
        checked = this.element.is(':checked');
        if (checked) {
          this.buttonElement.addClass('ui-state-active');
        }
        this.buttonElement.prop('aria-pressed', checked);
      } else {
        this.buttonElement = this.element;
      }
    },
    widget: function () {
      return this.buttonElement;
    },
    _destroy: function () {
      this.element.removeClass('ui-helper-hidden-accessible');
      this.buttonElement.removeClass(baseClasses + ' ui-state-active ' + typeClasses).removeAttr('role').removeAttr('aria-pressed').html(this.buttonElement.find('.ui-button-text').html());
      if (!this.hasTitle) {
        this.buttonElement.removeAttr('title');
      }
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'disabled') {
        this.widget().toggleClass('ui-state-disabled', !!value);
        this.element.prop('disabled', !!value);
        if (value) {
          if (this.type === 'checkbox' || this.type === 'radio') {
            this.buttonElement.removeClass('ui-state-focus');
          } else {
            this.buttonElement.removeClass('ui-state-focus ui-state-active');
          }
        }
        return;
      }
      this._resetButton();
    },
    refresh: function () {
      //See #8237 & #8828
      var isDisabled = this.element.is('input, button') ? this.element.is(':disabled') : this.element.hasClass('ui-button-disabled');
      if (isDisabled !== this.options.disabled) {
        this._setOption('disabled', isDisabled);
      }
      if (this.type === 'radio') {
        radioGroup(this.element[0]).each(function () {
          if ($(this).is(':checked')) {
            $(this).button('widget').addClass('ui-state-active').attr('aria-pressed', 'true');
          } else {
            $(this).button('widget').removeClass('ui-state-active').attr('aria-pressed', 'false');
          }
        });
      } else if (this.type === 'checkbox') {
        if (this.element.is(':checked')) {
          this.buttonElement.addClass('ui-state-active').attr('aria-pressed', 'true');
        } else {
          this.buttonElement.removeClass('ui-state-active').attr('aria-pressed', 'false');
        }
      }
    },
    _resetButton: function () {
      if (this.type === 'input') {
        if (this.options.label) {
          this.element.val(this.options.label);
        }
        return;
      }
      var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $('<span></span>', this.document[0]).addClass('ui-button-text').html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
      if (icons.primary || icons.secondary) {
        if (this.options.text) {
          buttonClasses.push('ui-button-text-icon' + (multipleIcons ? 's' : icons.primary ? '-primary' : '-secondary'));
        }
        if (icons.primary) {
          buttonElement.prepend('<span class=\'ui-button-icon-primary ui-icon ' + icons.primary + '\'></span>');
        }
        if (icons.secondary) {
          buttonElement.append('<span class=\'ui-button-icon-secondary ui-icon ' + icons.secondary + '\'></span>');
        }
        if (!this.options.text) {
          buttonClasses.push(multipleIcons ? 'ui-button-icons-only' : 'ui-button-icon-only');
          if (!this.hasTitle) {
            buttonElement.attr('title', $.trim(buttonText));
          }
        }
      } else {
        buttonClasses.push('ui-button-text-only');
      }
      buttonElement.addClass(buttonClasses.join(' '));
    }
  });
  $.widget('ui.buttonset', {
    version: '1.11.4',
    options: { items: 'button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)' },
    _create: function () {
      this.element.addClass('ui-buttonset');
    },
    _init: function () {
      this.refresh();
    },
    _setOption: function (key, value) {
      if (key === 'disabled') {
        this.buttons.button('option', key, value);
      }
      this._super(key, value);
    },
    refresh: function () {
      var rtl = this.element.css('direction') === 'rtl', allButtons = this.element.find(this.options.items), existingButtons = allButtons.filter(':ui-button');
      // Initialize new buttons
      allButtons.not(':ui-button').button();
      // Refresh existing buttons
      existingButtons.button('refresh');
      this.buttons = allButtons.map(function () {
        return $(this).button('widget')[0];
      }).removeClass('ui-corner-all ui-corner-left ui-corner-right').filter(':first').addClass(rtl ? 'ui-corner-right' : 'ui-corner-left').end().filter(':last').addClass(rtl ? 'ui-corner-left' : 'ui-corner-right').end().end();
    },
    _destroy: function () {
      this.element.removeClass('ui-buttonset');
      this.buttons.map(function () {
        return $(this).button('widget')[0];
      }).removeClass('ui-corner-left ui-corner-right').end().button('destroy');
    }
  });
  var button = $.ui.button;
  /*!
 * jQuery UI Datepicker 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */
  $.extend($.ui, { datepicker: { version: '1.11.4' } });
  var datepicker_instActive;
  function datepicker_getZindex(elem) {
    var position, value;
    while (elem.length && elem[0] !== document) {
      // Ignore z-index if position is set to a value where z-index is ignored by the browser
      // This makes behavior of this function consistent across browsers
      // WebKit always returns auto if the element is positioned
      position = elem.css('position');
      if (position === 'absolute' || position === 'relative' || position === 'fixed') {
        // IE returns 0 when zIndex is not specified
        // other browsers return a string
        // we ignore the case of nested elements with an explicit value of 0
        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
        value = parseInt(elem.css('zIndex'), 10);
        if (!isNaN(value) && value !== 0) {
          return value;
        }
      }
      elem = elem.parent();
    }
    return 0;
  }
  /* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */
  function Datepicker() {
    this._curInst = null;
    // The current instance in use
    this._keyEvent = false;
    // If the last event was a key event
    this._disabledInputs = [];
    // List of date picker inputs that have been disabled
    this._datepickerShowing = false;
    // True if the popup picker is showing , false if not
    this._inDialog = false;
    // True if showing within a "dialog", false if not
    this._mainDivId = 'ui-datepicker-div';
    // The ID of the main datepicker division
    this._inlineClass = 'ui-datepicker-inline';
    // The name of the inline marker class
    this._appendClass = 'ui-datepicker-append';
    // The name of the append marker class
    this._triggerClass = 'ui-datepicker-trigger';
    // The name of the trigger marker class
    this._dialogClass = 'ui-datepicker-dialog';
    // The name of the dialog marker class
    this._disableClass = 'ui-datepicker-disabled';
    // The name of the disabled covering marker class
    this._unselectableClass = 'ui-datepicker-unselectable';
    // The name of the unselectable cell marker class
    this._currentClass = 'ui-datepicker-current-day';
    // The name of the current day marker class
    this._dayOverClass = 'ui-datepicker-days-cell-over';
    // The name of the day hover marker class
    this.regional = [];
    // Available regional settings, indexed by language code
    this.regional[''] = {
      closeText: 'Done',
      prevText: 'Prev',
      nextText: 'Next',
      currentText: 'Today',
      monthNames: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      monthNamesShort: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ],
      dayNames: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
      ],
      dayNamesShort: [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
      ],
      dayNamesMin: [
        'Su',
        'Mo',
        'Tu',
        'We',
        'Th',
        'Fr',
        'Sa'
      ],
      weekHeader: 'Wk',
      dateFormat: 'mm/dd/yy',
      firstDay: 0,
      isRTL: false,
      showMonthAfterYear: false,
      yearSuffix: ''
    };
    this._defaults = {
      showOn: 'focus',
      showAnim: 'fadeIn',
      showOptions: {},
      defaultDate: null,
      appendText: '',
      buttonText: '...',
      buttonImage: '',
      buttonImageOnly: false,
      hideIfNoPrevNext: false,
      navigationAsDateFormat: false,
      gotoCurrent: false,
      changeMonth: false,
      changeYear: false,
      yearRange: 'c-10:c+10',
      showOtherMonths: false,
      selectOtherMonths: false,
      showWeek: false,
      calculateWeek: this.iso8601Week,
      shortYearCutoff: '+10',
      minDate: null,
      maxDate: null,
      duration: 'fast',
      beforeShowDay: null,
      beforeShow: null,
      onSelect: null,
      onChangeMonthYear: null,
      onClose: null,
      numberOfMonths: 1,
      showCurrentAtPos: 0,
      stepMonths: 1,
      stepBigMonths: 12,
      altField: '',
      altFormat: '',
      constrainInput: true,
      showButtonPanel: false,
      autoSize: false,
      disabled: false
    };
    $.extend(this._defaults, this.regional['']);
    this.regional.en = $.extend(true, {}, this.regional['']);
    this.regional['en-US'] = $.extend(true, {}, this.regional.en);
    this.dpDiv = datepicker_bindHover($('<div id=\'' + this._mainDivId + '\' class=\'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'));
  }
  $.extend(Datepicker.prototype, {
    markerClassName: 'hasDatepicker',
    maxRows: 4,
    _widgetDatepicker: function () {
      return this.dpDiv;
    },
    setDefaults: function (settings) {
      datepicker_extendRemove(this._defaults, settings || {});
      return this;
    },
    _attachDatepicker: function (target, settings) {
      var nodeName, inline, inst;
      nodeName = target.nodeName.toLowerCase();
      inline = nodeName === 'div' || nodeName === 'span';
      if (!target.id) {
        this.uuid += 1;
        target.id = 'dp' + this.uuid;
      }
      inst = this._newInst($(target), inline);
      inst.settings = $.extend({}, settings || {});
      if (nodeName === 'input') {
        this._connectDatepicker(target, inst);
      } else if (inline) {
        this._inlineDatepicker(target, inst);
      }
    },
    _newInst: function (target, inline) {
      var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, '\\\\$1');
      // escape jQuery meta chars
      return {
        id: id,
        input: target,
        selectedDay: 0,
        selectedMonth: 0,
        selectedYear: 0,
        drawMonth: 0,
        drawYear: 0,
        inline: inline,
        dpDiv: !inline ? this.dpDiv : datepicker_bindHover($('<div class=\'' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'))
      };
    },
    _connectDatepicker: function (target, inst) {
      var input = $(target);
      inst.append = $([]);
      inst.trigger = $([]);
      if (input.hasClass(this.markerClassName)) {
        return;
      }
      this._attachments(input, inst);
      input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
      this._autoSize(inst);
      $.data(target, 'datepicker', inst);
      //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
    },
    _attachments: function (input, inst) {
      var showOn, buttonText, buttonImage, appendText = this._get(inst, 'appendText'), isRTL = this._get(inst, 'isRTL');
      if (inst.append) {
        inst.append.remove();
      }
      if (appendText) {
        inst.append = $('<span class=\'' + this._appendClass + '\'>' + appendText + '</span>');
        input[isRTL ? 'before' : 'after'](inst.append);
      }
      input.unbind('focus', this._showDatepicker);
      if (inst.trigger) {
        inst.trigger.remove();
      }
      showOn = this._get(inst, 'showOn');
      if (showOn === 'focus' || showOn === 'both') {
        // pop-up date picker when in the marked field
        input.focus(this._showDatepicker);
      }
      if (showOn === 'button' || showOn === 'both') {
        // pop-up date picker when button clicked
        buttonText = this._get(inst, 'buttonText');
        buttonImage = this._get(inst, 'buttonImage');
        inst.trigger = $(this._get(inst, 'buttonImageOnly') ? $('<img/>').addClass(this._triggerClass).attr({
          src: buttonImage,
          alt: buttonText,
          title: buttonText
        }) : $('<button type=\'button\'></button>').addClass(this._triggerClass).html(!buttonImage ? buttonText : $('<img/>').attr({
          src: buttonImage,
          alt: buttonText,
          title: buttonText
        })));
        input[isRTL ? 'before' : 'after'](inst.trigger);
        inst.trigger.click(function () {
          if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
            $.datepicker._hideDatepicker();
          } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
            $.datepicker._hideDatepicker();
            $.datepicker._showDatepicker(input[0]);
          } else {
            $.datepicker._showDatepicker(input[0]);
          }
          return false;
        });
      }
    },
    _autoSize: function (inst) {
      if (this._get(inst, 'autoSize') && !inst.inline) {
        var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20),
          // Ensure double digits
          dateFormat = this._get(inst, 'dateFormat');
        if (dateFormat.match(/[DM]/)) {
          findMax = function (names) {
            max = 0;
            maxI = 0;
            for (i = 0; i < names.length; i++) {
              if (names[i].length > max) {
                max = names[i].length;
                maxI = i;
              }
            }
            return maxI;
          };
          date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')));
          date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort')) + 20 - date.getDay());
        }
        inst.input.attr('size', this._formatDate(inst, date).length);
      }
    },
    _inlineDatepicker: function (target, inst) {
      var divSpan = $(target);
      if (divSpan.hasClass(this.markerClassName)) {
        return;
      }
      divSpan.addClass(this.markerClassName).append(inst.dpDiv);
      $.data(target, 'datepicker', inst);
      this._setDate(inst, this._getDefaultDate(inst), true);
      this._updateDatepicker(inst);
      this._updateAlternate(inst);
      //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
      // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
      inst.dpDiv.css('display', 'block');
    },
    _dialogDatepicker: function (input, date, onSelect, settings, pos) {
      var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
      // internal instance
      if (!inst) {
        this.uuid += 1;
        id = 'dp' + this.uuid;
        this._dialogInput = $('<input type=\'text\' id=\'' + id + '\' style=\'position: absolute; top: -100px; width: 0px;\'/>');
        this._dialogInput.keydown(this._doKeyDown);
        $('body').append(this._dialogInput);
        inst = this._dialogInst = this._newInst(this._dialogInput, false);
        inst.settings = {};
        $.data(this._dialogInput[0], 'datepicker', inst);
      }
      datepicker_extendRemove(inst.settings, settings || {});
      date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
      this._dialogInput.val(date);
      this._pos = pos ? pos.length ? pos : [
        pos.pageX,
        pos.pageY
      ] : null;
      if (!this._pos) {
        browserWidth = document.documentElement.clientWidth;
        browserHeight = document.documentElement.clientHeight;
        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        this._pos = [
          browserWidth / 2 - 100 + scrollX,
          browserHeight / 2 - 150 + scrollY
        ];
      }
      // move input on screen for focus, but hidden behind dialog
      this._dialogInput.css('left', this._pos[0] + 20 + 'px').css('top', this._pos[1] + 'px');
      inst.settings.onSelect = onSelect;
      this._inDialog = true;
      this.dpDiv.addClass(this._dialogClass);
      this._showDatepicker(this._dialogInput[0]);
      if ($.blockUI) {
        $.blockUI(this.dpDiv);
      }
      $.data(this._dialogInput[0], 'datepicker', inst);
      return this;
    },
    _destroyDatepicker: function (target) {
      var nodeName, $target = $(target), inst = $.data(target, 'datepicker');
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      $.removeData(target, 'datepicker');
      if (nodeName === 'input') {
        inst.append.remove();
        inst.trigger.remove();
        $target.removeClass(this.markerClassName).unbind('focus', this._showDatepicker).unbind('keydown', this._doKeyDown).unbind('keypress', this._doKeyPress).unbind('keyup', this._doKeyUp);
      } else if (nodeName === 'div' || nodeName === 'span') {
        $target.removeClass(this.markerClassName).empty();
      }
      if (datepicker_instActive === inst) {
        datepicker_instActive = null;
      }
    },
    _enableDatepicker: function (target) {
      var nodeName, inline, $target = $(target), inst = $.data(target, 'datepicker');
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = false;
        inst.trigger.filter('button').each(function () {
          this.disabled = false;
        }).end().filter('img').css({
          opacity: '1.0',
          cursor: ''
        });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().removeClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', false);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (value) {
        return value === target ? null : value;
      });  // delete entry
    },
    _disableDatepicker: function (target) {
      var nodeName, inline, $target = $(target), inst = $.data(target, 'datepicker');
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = true;
        inst.trigger.filter('button').each(function () {
          this.disabled = true;
        }).end().filter('img').css({
          opacity: '0.5',
          cursor: 'default'
        });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().addClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', true);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (value) {
        return value === target ? null : value;
      });
      // delete entry
      this._disabledInputs[this._disabledInputs.length] = target;
    },
    _isDisabledDatepicker: function (target) {
      if (!target) {
        return false;
      }
      for (var i = 0; i < this._disabledInputs.length; i++) {
        if (this._disabledInputs[i] === target) {
          return true;
        }
      }
      return false;
    },
    _getInst: function (target) {
      try {
        return $.data(target, 'datepicker');
      } catch (err) {
        throw 'Missing instance data for this datepicker';
      }
    },
    _optionDatepicker: function (target, name, value) {
      var settings, date, minDate, maxDate, inst = this._getInst(target);
      if (arguments.length === 2 && typeof name === 'string') {
        return name === 'defaults' ? $.extend({}, $.datepicker._defaults) : inst ? name === 'all' ? $.extend({}, inst.settings) : this._get(inst, name) : null;
      }
      settings = name || {};
      if (typeof name === 'string') {
        settings = {};
        settings[name] = value;
      }
      if (inst) {
        if (this._curInst === inst) {
          this._hideDatepicker();
        }
        date = this._getDateDatepicker(target, true);
        minDate = this._getMinMaxDate(inst, 'min');
        maxDate = this._getMinMaxDate(inst, 'max');
        datepicker_extendRemove(inst.settings, settings);
        // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
          inst.settings.minDate = this._formatDate(inst, minDate);
        }
        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
          inst.settings.maxDate = this._formatDate(inst, maxDate);
        }
        if ('disabled' in settings) {
          if (settings.disabled) {
            this._disableDatepicker(target);
          } else {
            this._enableDatepicker(target);
          }
        }
        this._attachments($(target), inst);
        this._autoSize(inst);
        this._setDate(inst, date);
        this._updateAlternate(inst);
        this._updateDatepicker(inst);
      }
    },
    _changeDatepicker: function (target, name, value) {
      this._optionDatepicker(target, name, value);
    },
    _refreshDatepicker: function (target) {
      var inst = this._getInst(target);
      if (inst) {
        this._updateDatepicker(inst);
      }
    },
    _setDateDatepicker: function (target, date) {
      var inst = this._getInst(target);
      if (inst) {
        this._setDate(inst, date);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
      }
    },
    _getDateDatepicker: function (target, noDefault) {
      var inst = this._getInst(target);
      if (inst && !inst.inline) {
        this._setDateFromField(inst, noDefault);
      }
      return inst ? this._getDate(inst) : null;
    },
    _doKeyDown: function (event) {
      var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
      inst._keyEvent = true;
      if ($.datepicker._datepickerShowing) {
        switch (event.keyCode) {
        case 9:
          $.datepicker._hideDatepicker();
          handled = false;
          break;
        // hide on tab out
        case 13:
          sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv);
          if (sel[0]) {
            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
          }
          onSelect = $.datepicker._get(inst, 'onSelect');
          if (onSelect) {
            dateStr = $.datepicker._formatDate(inst);
            // trigger custom callback
            onSelect.apply(inst.input ? inst.input[0] : null, [
              dateStr,
              inst
            ]);
          } else {
            $.datepicker._hideDatepicker();
          }
          return false;
        // don't submit the form
        case 27:
          $.datepicker._hideDatepicker();
          break;
        // hide on escape
        case 33:
          $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
          break;
        // previous month/year on page up/+ ctrl
        case 34:
          $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
          break;
        // next month/year on page down/+ ctrl
        case 35:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._clearDate(event.target);
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // clear on ctrl or command +end
        case 36:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._gotoToday(event.target);
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // current on ctrl or command +home
        case 37:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          // -1 day on ctrl or command +left
          if (event.originalEvent.altKey) {
            $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
          }
          // next month/year on alt +left on Mac
          break;
        case 38:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, -7, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // -1 week on ctrl or command +up
        case 39:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          // +1 day on ctrl or command +right
          if (event.originalEvent.altKey) {
            $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
          }
          // next month/year on alt +right
          break;
        case 40:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, +7, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // +1 week on ctrl or command +down
        default:
          handled = false;
        }
      } else if (event.keyCode === 36 && event.ctrlKey) {
        // display the date picker on ctrl+home
        $.datepicker._showDatepicker(this);
      } else {
        handled = false;
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
    _doKeyPress: function (event) {
      var chars, chr, inst = $.datepicker._getInst(event.target);
      if ($.datepicker._get(inst, 'constrainInput')) {
        chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
        return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
      }
    },
    _doKeyUp: function (event) {
      var date, inst = $.datepicker._getInst(event.target);
      if (inst.input.val() !== inst.lastVal) {
        try {
          date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
          if (date) {
            // only if valid
            $.datepicker._setDateFromField(inst);
            $.datepicker._updateAlternate(inst);
            $.datepicker._updateDatepicker(inst);
          }
        } catch (err) {
        }
      }
      return true;
    },
    _showDatepicker: function (input) {
      input = input.target || input;
      if (input.nodeName.toLowerCase() !== 'input') {
        // find from button/image trigger
        input = $('input', input.parentNode)[0];
      }
      if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
        // already here
        return;
      }
      var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
      inst = $.datepicker._getInst(input);
      if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
        $.datepicker._curInst.dpDiv.stop(true, true);
        if (inst && $.datepicker._datepickerShowing) {
          $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
        }
      }
      beforeShow = $.datepicker._get(inst, 'beforeShow');
      beforeShowSettings = beforeShow ? beforeShow.apply(input, [
        input,
        inst
      ]) : {};
      if (beforeShowSettings === false) {
        return;
      }
      datepicker_extendRemove(inst.settings, beforeShowSettings);
      inst.lastVal = null;
      $.datepicker._lastInput = input;
      $.datepicker._setDateFromField(inst);
      if ($.datepicker._inDialog) {
        // hide cursor
        input.value = '';
      }
      if (!$.datepicker._pos) {
        // position below input
        $.datepicker._pos = $.datepicker._findPos(input);
        $.datepicker._pos[1] += input.offsetHeight;  // add the height
      }
      isFixed = false;
      $(input).parents().each(function () {
        isFixed |= $(this).css('position') === 'fixed';
        return !isFixed;
      });
      offset = {
        left: $.datepicker._pos[0],
        top: $.datepicker._pos[1]
      };
      $.datepicker._pos = null;
      //to avoid flashes on Firefox
      inst.dpDiv.empty();
      // determine sizing offscreen
      inst.dpDiv.css({
        position: 'absolute',
        display: 'block',
        top: '-1000px'
      });
      $.datepicker._updateDatepicker(inst);
      // fix width for dynamic number of date pickers
      // and adjust position before showing
      offset = $.datepicker._checkOffset(inst, offset, isFixed);
      inst.dpDiv.css({
        position: $.datepicker._inDialog && $.blockUI ? 'static' : isFixed ? 'fixed' : 'absolute',
        display: 'none',
        left: offset.left + 'px',
        top: offset.top + 'px'
      });
      if (!inst.inline) {
        showAnim = $.datepicker._get(inst, 'showAnim');
        duration = $.datepicker._get(inst, 'duration');
        inst.dpDiv.css('z-index', datepicker_getZindex($(input)) + 1);
        $.datepicker._datepickerShowing = true;
        if ($.effects && $.effects.effect[showAnim]) {
          inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration);
        } else {
          inst.dpDiv[showAnim || 'show'](showAnim ? duration : null);
        }
        if ($.datepicker._shouldFocusInput(inst)) {
          inst.input.focus();
        }
        $.datepicker._curInst = inst;
      }
    },
    _updateDatepicker: function (inst) {
      this.maxRows = 4;
      //Reset the max number of rows being displayed (see #7043)
      datepicker_instActive = inst;
      // for delegate hover events
      inst.dpDiv.empty().append(this._generateHTML(inst));
      this._attachHandlers(inst);
      var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find('.' + this._dayOverClass + ' a');
      if (activeCell.length > 0) {
        datepicker_handleMouseover.apply(activeCell.get(0));
      }
      inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
      if (cols > 1) {
        inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', width * cols + 'em');
      }
      inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi');
      inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl');
      if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
        inst.input.focus();
      }
      // deffered render of the years select (to avoid flashes on Firefox)
      if (inst.yearshtml) {
        origyearshtml = inst.yearshtml;
        setTimeout(function () {
          //assure that inst.yearshtml didn't change.
          if (origyearshtml === inst.yearshtml && inst.yearshtml) {
            inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
          }
          origyearshtml = inst.yearshtml = null;
        }, 0);
      }
    },
    _shouldFocusInput: function (inst) {
      return inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && !inst.input.is(':focus');
    },
    _checkOffset: function (inst, offset, isFixed) {
      var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
      offset.left -= this._get(inst, 'isRTL') ? dpWidth - inputWidth : 0;
      offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
      offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
      // now check if datepicker is showing outside window viewport - move to a better place if so.
      offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
      offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
      return offset;
    },
    _findPos: function (obj) {
      var position, inst = this._getInst(obj), isRTL = this._get(inst, 'isRTL');
      while (obj && (obj.type === 'hidden' || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
        obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
      }
      position = $(obj).offset();
      return [
        position.left,
        position.top
      ];
    },
    _hideDatepicker: function (input) {
      var showAnim, duration, postProcess, onClose, inst = this._curInst;
      if (!inst || input && inst !== $.data(input, 'datepicker')) {
        return;
      }
      if (this._datepickerShowing) {
        showAnim = this._get(inst, 'showAnim');
        duration = this._get(inst, 'duration');
        postProcess = function () {
          $.datepicker._tidyDialog(inst);
        };
        // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
        if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
          inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
        } else {
          inst.dpDiv[showAnim === 'slideDown' ? 'slideUp' : showAnim === 'fadeIn' ? 'fadeOut' : 'hide'](showAnim ? duration : null, postProcess);
        }
        if (!showAnim) {
          postProcess();
        }
        this._datepickerShowing = false;
        onClose = this._get(inst, 'onClose');
        if (onClose) {
          onClose.apply(inst.input ? inst.input[0] : null, [
            inst.input ? inst.input.val() : '',
            inst
          ]);
        }
        this._lastInput = null;
        if (this._inDialog) {
          this._dialogInput.css({
            position: 'absolute',
            left: '0',
            top: '-100px'
          });
          if ($.blockUI) {
            $.unblockUI();
            $('body').append(this.dpDiv);
          }
        }
        this._inDialog = false;
      }
    },
    _tidyDialog: function (inst) {
      inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
    },
    _checkExternalClick: function (event) {
      if (!$.datepicker._curInst) {
        return;
      }
      var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
      if ($target[0].id !== $.datepicker._mainDivId && $target.parents('#' + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest('.' + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
        $.datepicker._hideDatepicker();
      }
    },
    _adjustDate: function (id, offset, period) {
      var target = $(id), inst = this._getInst(target[0]);
      if (this._isDisabledDatepicker(target[0])) {
        return;
      }
      this._adjustInstDate(inst, offset + (period === 'M' ? this._get(inst, 'showCurrentAtPos') : 0), period);
      this._updateDatepicker(inst);
    },
    _gotoToday: function (id) {
      var date, target = $(id), inst = this._getInst(target[0]);
      if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
        inst.selectedDay = inst.currentDay;
        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
        inst.drawYear = inst.selectedYear = inst.currentYear;
      } else {
        date = new Date();
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
      }
      this._notifyChange(inst);
      this._adjustDate(target);
    },
    _selectMonthYear: function (id, select, period) {
      var target = $(id), inst = this._getInst(target[0]);
      inst['selected' + (period === 'M' ? 'Month' : 'Year')] = inst['draw' + (period === 'M' ? 'Month' : 'Year')] = parseInt(select.options[select.selectedIndex].value, 10);
      this._notifyChange(inst);
      this._adjustDate(target);
    },
    _selectDay: function (id, month, year, td) {
      var inst, target = $(id);
      if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
        return;
      }
      inst = this._getInst(target[0]);
      inst.selectedDay = inst.currentDay = $('a', td).html();
      inst.selectedMonth = inst.currentMonth = month;
      inst.selectedYear = inst.currentYear = year;
      this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
    },
    _clearDate: function (id) {
      var target = $(id);
      this._selectDate(target, '');
    },
    _selectDate: function (id, dateStr) {
      var onSelect, target = $(id), inst = this._getInst(target[0]);
      dateStr = dateStr != null ? dateStr : this._formatDate(inst);
      if (inst.input) {
        inst.input.val(dateStr);
      }
      this._updateAlternate(inst);
      onSelect = this._get(inst, 'onSelect');
      if (onSelect) {
        onSelect.apply(inst.input ? inst.input[0] : null, [
          dateStr,
          inst
        ]);  // trigger custom callback
      } else if (inst.input) {
        inst.input.trigger('change');  // fire the change event
      }
      if (inst.inline) {
        this._updateDatepicker(inst);
      } else {
        this._hideDatepicker();
        this._lastInput = inst.input[0];
        if (typeof inst.input[0] !== 'object') {
          inst.input.focus();  // restore focus
        }
        this._lastInput = null;
      }
    },
    _updateAlternate: function (inst) {
      var altFormat, date, dateStr, altField = this._get(inst, 'altField');
      if (altField) {
        // update alternate field too
        altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
        date = this._getDate(inst);
        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
        $(altField).each(function () {
          $(this).val(dateStr);
        });
      }
    },
    noWeekends: function (date) {
      var day = date.getDay();
      return [
        day > 0 && day < 6,
        ''
      ];
    },
    iso8601Week: function (date) {
      var time, checkDate = new Date(date.getTime());
      // Find Thursday of this week starting on Monday
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      time = checkDate.getTime();
      checkDate.setMonth(0);
      // Compare with Jan 1
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    },
    parseDate: function (format, value, settings) {
      if (format == null || value == null) {
        throw 'Invalid arguments';
      }
      value = typeof value === 'object' ? value.toString() : value + '';
      if (value === '') {
        return null;
      }
      var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== 'string' ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date,
        // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Extract a number from the string value
        getNumber = function (match) {
          var isDoubled = lookAhead(match), size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2, minSize = match === 'y' ? size : 1, digits = new RegExp('^\\d{' + minSize + ',' + size + '}'), num = value.substring(iValue).match(digits);
          if (!num) {
            throw 'Missing number at position ' + iValue;
          }
          iValue += num[0].length;
          return parseInt(num[0], 10);
        },
        // Extract a name from the string value and convert to an index
        getName = function (match, shortNames, longNames) {
          var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
              return [[
                  k,
                  v
                ]];
            }).sort(function (a, b) {
              return -(a[1].length - b[1].length);
            });
          $.each(names, function (i, pair) {
            var name = pair[1];
            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
              index = pair[0];
              iValue += name.length;
              return false;
            }
          });
          if (index !== -1) {
            return index + 1;
          } else {
            throw 'Unknown name at position ' + iValue;
          }
        },
        // Confirm that a literal character matches the string value
        checkLiteral = function () {
          if (value.charAt(iValue) !== format.charAt(iFormat)) {
            throw 'Unexpected literal at position ' + iValue;
          }
          iValue++;
        };
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
          case 'd':
            day = getNumber('d');
            break;
          case 'D':
            getName('D', dayNamesShort, dayNames);
            break;
          case 'o':
            doy = getNumber('o');
            break;
          case 'm':
            month = getNumber('m');
            break;
          case 'M':
            month = getName('M', monthNamesShort, monthNames);
            break;
          case 'y':
            year = getNumber('y');
            break;
          case '@':
            date = new Date(getNumber('@'));
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '!':
            date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '\'':
            if (lookAhead('\'')) {
              checkLiteral();
            } else {
              literal = true;
            }
            break;
          default:
            checkLiteral();
          }
        }
      }
      if (iValue < value.length) {
        extra = value.substr(iValue);
        if (!/^\s+/.test(extra)) {
          throw 'Extra/unparsed characters found in date: ' + extra;
        }
      }
      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
      }
      if (doy > -1) {
        month = 1;
        day = doy;
        do {
          dim = this._getDaysInMonth(year, month - 1);
          if (day <= dim) {
            break;
          }
          month++;
          day -= dim;
        } while (true);
      }
      date = this._daylightSavingAdjust(new Date(year, month - 1, day));
      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw 'Invalid date';  // E.g. 31/02/00
      }
      return date;
    },
    ATOM: 'yy-mm-dd',
    COOKIE: 'D, dd M yy',
    ISO_8601: 'yy-mm-dd',
    RFC_822: 'D, d M y',
    RFC_850: 'DD, dd-M-y',
    RFC_1036: 'D, d M y',
    RFC_1123: 'D, d M yy',
    RFC_2822: 'D, d M yy',
    RSS: 'D, d M y',
    TICKS: '!',
    TIMESTAMP: '@',
    W3C: 'yy-mm-dd',
    _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,
    formatDate: function (format, date, settings) {
      if (!date) {
        return '';
      }
      var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
        // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Format a number, with leading zero if necessary
        formatNumber = function (match, value, len) {
          var num = '' + value;
          if (lookAhead(match)) {
            while (num.length < len) {
              num = '0' + num;
            }
          }
          return num;
        },
        // Format a name, short or long as requested
        formatName = function (match, value, shortNames, longNames) {
          return lookAhead(match) ? longNames[value] : shortNames[value];
        }, output = '', literal = false;
      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
            case 'd':
              output += formatNumber('d', date.getDate(), 2);
              break;
            case 'D':
              output += formatName('D', date.getDay(), dayNamesShort, dayNames);
              break;
            case 'o':
              output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
              break;
            case 'm':
              output += formatNumber('m', date.getMonth() + 1, 2);
              break;
            case 'M':
              output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
              break;
            case 'y':
              output += lookAhead('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100;
              break;
            case '@':
              output += date.getTime();
              break;
            case '!':
              output += date.getTime() * 10000 + this._ticksTo1970;
              break;
            case '\'':
              if (lookAhead('\'')) {
                output += '\'';
              } else {
                literal = true;
              }
              break;
            default:
              output += format.charAt(iFormat);
            }
          }
        }
      }
      return output;
    },
    _possibleChars: function (format) {
      var iFormat, chars = '', literal = false,
        // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        };
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
            literal = false;
          } else {
            chars += format.charAt(iFormat);
          }
        } else {
          switch (format.charAt(iFormat)) {
          case 'd':
          case 'm':
          case 'y':
          case '@':
            chars += '0123456789';
            break;
          case 'D':
          case 'M':
            return null;
          // Accept anything
          case '\'':
            if (lookAhead('\'')) {
              chars += '\'';
            } else {
              literal = true;
            }
            break;
          default:
            chars += format.charAt(iFormat);
          }
        }
      }
      return chars;
    },
    _get: function (inst, name) {
      return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
    },
    _setDateFromField: function (inst, noDefault) {
      if (inst.input.val() === inst.lastVal) {
        return;
      }
      var dateFormat = this._get(inst, 'dateFormat'), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
      try {
        date = this.parseDate(dateFormat, dates, settings) || defaultDate;
      } catch (event) {
        dates = noDefault ? '' : dates;
      }
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      inst.currentDay = dates ? date.getDate() : 0;
      inst.currentMonth = dates ? date.getMonth() : 0;
      inst.currentYear = dates ? date.getFullYear() : 0;
      this._adjustInstDate(inst);
    },
    _getDefaultDate: function (inst) {
      return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
    },
    _determineDate: function (inst, date, defaultDate) {
      var offsetNumeric = function (offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        }, offsetString = function (offset) {
          try {
            return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), offset, $.datepicker._getFormatConfig(inst));
          } catch (e) {
          }
          var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
          while (matches) {
            switch (matches[2] || 'd') {
            case 'd':
            case 'D':
              day += parseInt(matches[1], 10);
              break;
            case 'w':
            case 'W':
              day += parseInt(matches[1], 10) * 7;
              break;
            case 'm':
            case 'M':
              month += parseInt(matches[1], 10);
              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
              break;
            case 'y':
            case 'Y':
              year += parseInt(matches[1], 10);
              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
              break;
            }
            matches = pattern.exec(offset);
          }
          return new Date(year, month, day);
        }, newDate = date == null || date === '' ? defaultDate : typeof date === 'string' ? offsetString(date) : typeof date === 'number' ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
      newDate = newDate && newDate.toString() === 'Invalid Date' ? defaultDate : newDate;
      if (newDate) {
        newDate.setHours(0);
        newDate.setMinutes(0);
        newDate.setSeconds(0);
        newDate.setMilliseconds(0);
      }
      return this._daylightSavingAdjust(newDate);
    },
    _daylightSavingAdjust: function (date) {
      if (!date) {
        return null;
      }
      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    },
    _setDate: function (inst, date, noChange) {
      var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
      inst.selectedDay = inst.currentDay = newDate.getDate();
      inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
      inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
      if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
        this._notifyChange(inst);
      }
      this._adjustInstDate(inst);
      if (inst.input) {
        inst.input.val(clear ? '' : this._formatDate(inst));
      }
    },
    _getDate: function (inst) {
      var startDate = !inst.currentYear || inst.input && inst.input.val() === '' ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return startDate;
    },
    _attachHandlers: function (inst) {
      var stepMonths = this._get(inst, 'stepMonths'), id = '#' + inst.id.replace(/\\\\/g, '\\');
      inst.dpDiv.find('[data-handler]').map(function () {
        var handler = {
            prev: function () {
              $.datepicker._adjustDate(id, -stepMonths, 'M');
            },
            next: function () {
              $.datepicker._adjustDate(id, +stepMonths, 'M');
            },
            hide: function () {
              $.datepicker._hideDatepicker();
            },
            today: function () {
              $.datepicker._gotoToday(id);
            },
            selectDay: function () {
              $.datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
              return false;
            },
            selectMonth: function () {
              $.datepicker._selectMonthYear(id, this, 'M');
              return false;
            },
            selectYear: function () {
              $.datepicker._selectMonthYear(id, this, 'Y');
              return false;
            }
          };
        $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
      });
    },
    _generateHTML: function (inst) {
      var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
        // clear time
        isRTL = this._get(inst, 'isRTL'), showButtonPanel = this._get(inst, 'showButtonPanel'), hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'), navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, 'showCurrentAtPos'), stepMonths = this._get(inst, 'stepMonths'), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
      if (drawMonth < 0) {
        drawMonth += 12;
        drawYear--;
      }
      if (maxDate) {
        maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
        maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
          drawMonth--;
          if (drawMonth < 0) {
            drawMonth = 11;
            drawYear--;
          }
        }
      }
      inst.drawMonth = drawMonth;
      inst.drawYear = drawYear;
      prevText = this._get(inst, 'prevText');
      prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
      prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-prev ui-corner-all\' data-handler=\'prev\' data-event=\'click\'' + ' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-prev ui-corner-all ui-state-disabled\' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>';
      nextText = this._get(inst, 'nextText');
      nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
      next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-next ui-corner-all\' data-handler=\'next\' data-event=\'click\'' + ' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-next ui-corner-all ui-state-disabled\' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>';
      currentText = this._get(inst, 'currentText');
      gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;
      currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
      controls = !inst.inline ? '<button type=\'button\' class=\'ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\' data-handler=\'hide\' data-event=\'click\'>' + this._get(inst, 'closeText') + '</button>' : '';
      buttonPanel = showButtonPanel ? '<div class=\'ui-datepicker-buttonpane ui-widget-content\'>' + (isRTL ? controls : '') + (this._isInRange(inst, gotoDate) ? '<button type=\'button\' class=\'ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\' data-handler=\'today\' data-event=\'click\'' + '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
      firstDay = parseInt(this._get(inst, 'firstDay'), 10);
      firstDay = isNaN(firstDay) ? 0 : firstDay;
      showWeek = this._get(inst, 'showWeek');
      dayNames = this._get(inst, 'dayNames');
      dayNamesMin = this._get(inst, 'dayNamesMin');
      monthNames = this._get(inst, 'monthNames');
      monthNamesShort = this._get(inst, 'monthNamesShort');
      beforeShowDay = this._get(inst, 'beforeShowDay');
      showOtherMonths = this._get(inst, 'showOtherMonths');
      selectOtherMonths = this._get(inst, 'selectOtherMonths');
      defaultDate = this._getDefaultDate(inst);
      html = '';
      dow;
      for (row = 0; row < numMonths[0]; row++) {
        group = '';
        this.maxRows = 4;
        for (col = 0; col < numMonths[1]; col++) {
          selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
          cornerClass = ' ui-corner-all';
          calender = '';
          if (isMultiMonth) {
            calender += '<div class=\'ui-datepicker-group';
            if (numMonths[1] > 1) {
              switch (col) {
              case 0:
                calender += ' ui-datepicker-group-first';
                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');
                break;
              case numMonths[1] - 1:
                calender += ' ui-datepicker-group-last';
                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');
                break;
              default:
                calender += ' ui-datepicker-group-middle';
                cornerClass = '';
                break;
              }
            }
            calender += '\'>';
          }
          calender += '<div class=\'ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '\'>' + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : '') + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : '') + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + '</div><table class=\'ui-datepicker-calendar\'><thead>' + '<tr>';
          thead = showWeek ? '<th class=\'ui-datepicker-week-col\'>' + this._get(inst, 'weekHeader') + '</th>' : '';
          for (dow = 0; dow < 7; dow++) {
            // days of the week
            day = (dow + firstDay) % 7;
            thead += '<th scope=\'col\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' class=\'ui-datepicker-week-end\'' : '') + '>' + '<span title=\'' + dayNames[day] + '\'>' + dayNamesMin[day] + '</span></th>';
          }
          calender += thead + '</tr></thead><tbody>';
          daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
          if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
          }
          leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
          curRows = Math.ceil((leadDays + daysInMonth) / 7);
          // calculate the number of rows to generate
          numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
          //If multiple months, use the higher number of rows (see #7043)
          this.maxRows = numRows;
          printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
          for (dRow = 0; dRow < numRows; dRow++) {
            // create date picker rows
            calender += '<tr>';
            tbody = !showWeek ? '' : '<td class=\'ui-datepicker-week-col\'>' + this._get(inst, 'calculateWeek')(printDate) + '</td>';
            for (dow = 0; dow < 7; dow++) {
              // create date picker days
              daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [
                true,
                ''
              ];
              otherMonth = printDate.getMonth() !== drawMonth;
              unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
              tbody += '<td class=\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + (otherMonth ? ' ui-datepicker-other-month' : '') + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? ' ' + this._dayOverClass : '') + (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') + (printDate.getTime() === today.getTime() ? ' ui-datepicker-today' : '')) + '\'' + ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title=\'' + daySettings[2].replace(/'/g, '&#39;') + '\'' : '') + (unselectable ? '' : ' data-handler=\'selectDay\' data-event=\'click\' data-month=\'' + printDate.getMonth() + '\' data-year=\'' + printDate.getFullYear() + '\'') + '>' + (otherMonth && !showOtherMonths ? '&#xa0;' : unselectable ? '<span class=\'ui-state-default\'>' + printDate.getDate() + '</span>' : '<a class=\'ui-state-default' + (printDate.getTime() === today.getTime() ? ' ui-state-highlight' : '') + (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') + (otherMonth ? ' ui-priority-secondary' : '') + '\' href=\'#\'>' + printDate.getDate() + '</a>') + '</td>';
              // display selectable date
              printDate.setDate(printDate.getDate() + 1);
              printDate = this._daylightSavingAdjust(printDate);
            }
            calender += tbody + '</tr>';
          }
          drawMonth++;
          if (drawMonth > 11) {
            drawMonth = 0;
            drawYear++;
          }
          calender += '</tbody></table>' + (isMultiMonth ? '</div>' + (numMonths[0] > 0 && col === numMonths[1] - 1 ? '<div class=\'ui-datepicker-row-break\'></div>' : '') : '');
          group += calender;
        }
        html += group;
      }
      html += buttonPanel;
      inst._keyEvent = false;
      return html;
    },
    _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
      var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, 'changeMonth'), changeYear = this._get(inst, 'changeYear'), showMonthAfterYear = this._get(inst, 'showMonthAfterYear'), html = '<div class=\'ui-datepicker-title\'>', monthHtml = '';
      // month selection
      if (secondary || !changeMonth) {
        monthHtml += '<span class=\'ui-datepicker-month\'>' + monthNames[drawMonth] + '</span>';
      } else {
        inMinYear = minDate && minDate.getFullYear() === drawYear;
        inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
        monthHtml += '<select class=\'ui-datepicker-month\' data-handler=\'selectMonth\' data-event=\'change\'>';
        for (month = 0; month < 12; month++) {
          if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
            monthHtml += '<option value=\'' + month + '\'' + (month === drawMonth ? ' selected=\'selected\'' : '') + '>' + monthNamesShort[month] + '</option>';
          }
        }
        monthHtml += '</select>';
      }
      if (!showMonthAfterYear) {
        html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
      }
      // year selection
      if (!inst.yearshtml) {
        inst.yearshtml = '';
        if (secondary || !changeYear) {
          html += '<span class=\'ui-datepicker-year\'>' + drawYear + '</span>';
        } else {
          // determine range of years to display
          years = this._get(inst, 'yearRange').split(':');
          thisYear = new Date().getFullYear();
          determineYear = function (value) {
            var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
            return isNaN(year) ? thisYear : year;
          };
          year = determineYear(years[0]);
          endYear = Math.max(year, determineYear(years[1] || ''));
          year = minDate ? Math.max(year, minDate.getFullYear()) : year;
          endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
          inst.yearshtml += '<select class=\'ui-datepicker-year\' data-handler=\'selectYear\' data-event=\'change\'>';
          for (; year <= endYear; year++) {
            inst.yearshtml += '<option value=\'' + year + '\'' + (year === drawYear ? ' selected=\'selected\'' : '') + '>' + year + '</option>';
          }
          inst.yearshtml += '</select>';
          html += inst.yearshtml;
          inst.yearshtml = null;
        }
      }
      html += this._get(inst, 'yearSuffix');
      if (showMonthAfterYear) {
        html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
      }
      html += '</div>';
      // Close datepicker_header
      return html;
    },
    _adjustInstDate: function (inst, offset, period) {
      var year = inst.drawYear + (period === 'Y' ? offset : 0), month = inst.drawMonth + (period === 'M' ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === 'D' ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      if (period === 'M' || period === 'Y') {
        this._notifyChange(inst);
      }
    },
    _restrictMinMax: function (inst, date) {
      var minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), newDate = minDate && date < minDate ? minDate : date;
      return maxDate && newDate > maxDate ? maxDate : newDate;
    },
    _notifyChange: function (inst) {
      var onChange = this._get(inst, 'onChangeMonthYear');
      if (onChange) {
        onChange.apply(inst.input ? inst.input[0] : null, [
          inst.selectedYear,
          inst.selectedMonth + 1,
          inst
        ]);
      }
    },
    _getNumberOfMonths: function (inst) {
      var numMonths = this._get(inst, 'numberOfMonths');
      return numMonths == null ? [
        1,
        1
      ] : typeof numMonths === 'number' ? [
        1,
        numMonths
      ] : numMonths;
    },
    _getMinMaxDate: function (inst, minMax) {
      return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
    },
    _getDaysInMonth: function (year, month) {
      return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },
    _getFirstDayOfMonth: function (year, month) {
      return new Date(year, month, 1).getDay();
    },
    _canAdjustMonth: function (inst, offset, curYear, curMonth) {
      var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
      if (offset < 0) {
        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
      }
      return this._isInRange(inst, date);
    },
    _isInRange: function (inst, date) {
      var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), minYear = null, maxYear = null, years = this._get(inst, 'yearRange');
      if (years) {
        yearSplit = years.split(':');
        currentYear = new Date().getFullYear();
        minYear = parseInt(yearSplit[0], 10);
        maxYear = parseInt(yearSplit[1], 10);
        if (yearSplit[0].match(/[+\-].*/)) {
          minYear += currentYear;
        }
        if (yearSplit[1].match(/[+\-].*/)) {
          maxYear += currentYear;
        }
      }
      return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
    },
    _getFormatConfig: function (inst) {
      var shortYearCutoff = this._get(inst, 'shortYearCutoff');
      shortYearCutoff = typeof shortYearCutoff !== 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
      return {
        shortYearCutoff: shortYearCutoff,
        dayNamesShort: this._get(inst, 'dayNamesShort'),
        dayNames: this._get(inst, 'dayNames'),
        monthNamesShort: this._get(inst, 'monthNamesShort'),
        monthNames: this._get(inst, 'monthNames')
      };
    },
    _formatDate: function (inst, day, month, year) {
      if (!day) {
        inst.currentDay = inst.selectedDay;
        inst.currentMonth = inst.selectedMonth;
        inst.currentYear = inst.selectedYear;
      }
      var date = day ? typeof day === 'object' ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
    }
  });
  /*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
  function datepicker_bindHover(dpDiv) {
    var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
    return dpDiv.delegate(selector, 'mouseout', function () {
      $(this).removeClass('ui-state-hover');
      if (this.className.indexOf('ui-datepicker-prev') !== -1) {
        $(this).removeClass('ui-datepicker-prev-hover');
      }
      if (this.className.indexOf('ui-datepicker-next') !== -1) {
        $(this).removeClass('ui-datepicker-next-hover');
      }
    }).delegate(selector, 'mouseover', datepicker_handleMouseover);
  }
  function datepicker_handleMouseover() {
    if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
      $(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
      $(this).addClass('ui-state-hover');
      if (this.className.indexOf('ui-datepicker-prev') !== -1) {
        $(this).addClass('ui-datepicker-prev-hover');
      }
      if (this.className.indexOf('ui-datepicker-next') !== -1) {
        $(this).addClass('ui-datepicker-next-hover');
      }
    }
  }
  /* jQuery extend now ignores nulls! */
  function datepicker_extendRemove(target, props) {
    $.extend(target, props);
    for (var name in props) {
      if (props[name] == null) {
        target[name] = props[name];
      }
    }
    return target;
  }
  /* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
  $.fn.datepicker = function (options) {
    /* Verify an empty collection wasn't passed - Fixes #6976 */
    if (!this.length) {
      return this;
    }
    /* Initialise the date picker. */
    if (!$.datepicker.initialized) {
      $(document).mousedown($.datepicker._checkExternalClick);
      $.datepicker.initialized = true;
    }
    /* Append datepicker main container to body if not exist. */
    if ($('#' + $.datepicker._mainDivId).length === 0) {
      $('body').append($.datepicker.dpDiv);
    }
    var otherArgs = Array.prototype.slice.call(arguments, 1);
    if (typeof options === 'string' && (options === 'isDisabled' || options === 'getDate' || options === 'widget')) {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    if (options === 'option' && arguments.length === 2 && typeof arguments[1] === 'string') {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    return this.each(function () {
      typeof options === 'string' ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
    });
  };
  $.datepicker = new Datepicker();
  // singleton instance
  $.datepicker.initialized = false;
  $.datepicker.uuid = new Date().getTime();
  $.datepicker.version = '1.11.4';
  var datepicker = $.datepicker;
  /*!
 * jQuery UI Draggable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */
  $.widget('ui.draggable', $.ui.mouse, {
    version: '1.11.4',
    widgetEventPrefix: 'drag',
    options: {
      addClasses: true,
      appendTo: 'parent',
      axis: false,
      connectToSortable: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      grid: false,
      handle: false,
      helper: 'original',
      iframeFix: false,
      opacity: false,
      refreshPositions: false,
      revert: false,
      revertDuration: 500,
      scope: 'default',
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: false,
      snapMode: 'both',
      snapTolerance: 20,
      stack: false,
      zIndex: false,
      drag: null,
      start: null,
      stop: null
    },
    _create: function () {
      if (this.options.helper === 'original') {
        this._setPositionRelative();
      }
      if (this.options.addClasses) {
        this.element.addClass('ui-draggable');
      }
      if (this.options.disabled) {
        this.element.addClass('ui-draggable-disabled');
      }
      this._setHandleClassName();
      this._mouseInit();
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'handle') {
        this._removeHandleClassName();
        this._setHandleClassName();
      }
    },
    _destroy: function () {
      if ((this.helper || this.element).is('.ui-draggable-dragging')) {
        this.destroyOnClear = true;
        return;
      }
      this.element.removeClass('ui-draggable ui-draggable-dragging ui-draggable-disabled');
      this._removeHandleClassName();
      this._mouseDestroy();
    },
    _mouseCapture: function (event) {
      var o = this.options;
      this._blurActiveElement(event);
      // among others, prevent a drag on a resizable-handle
      if (this.helper || o.disabled || $(event.target).closest('.ui-resizable-handle').length > 0) {
        return false;
      }
      //Quit if we're not on a valid handle
      this.handle = this._getHandle(event);
      if (!this.handle) {
        return false;
      }
      this._blockFrames(o.iframeFix === true ? 'iframe' : o.iframeFix);
      return true;
    },
    _blockFrames: function (selector) {
      this.iframeBlocks = this.document.find(selector).map(function () {
        var iframe = $(this);
        return $('<div>').css('position', 'absolute').appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
      });
    },
    _unblockFrames: function () {
      if (this.iframeBlocks) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },
    _blurActiveElement: function (event) {
      var document = this.document[0];
      // Only need to blur if the event occurred on the draggable itself, see #10527
      if (!this.handleElement.is(event.target)) {
        return;
      }
      // support: IE9
      // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
      try {
        // Support: IE9, IE10
        // If the <body> is blurred, IE will switch windows, see #9520
        if (document.activeElement && document.activeElement.nodeName.toLowerCase() !== 'body') {
          // Blur any element that currently has focus, see #4261
          $(document.activeElement).blur();
        }
      } catch (error) {
      }
    },
    _mouseStart: function (event) {
      var o = this.options;
      //Create and append the visible helper
      this.helper = this._createHelper(event);
      this.helper.addClass('ui-draggable-dragging');
      //Cache the helper size
      this._cacheHelperProportions();
      //If ddmanager is used for droppables, set the global draggable
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
      /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
      //Cache the margins of the original element
      this._cacheMargins();
      //Store the helper's css position
      this.cssPosition = this.helper.css('position');
      this.scrollParent = this.helper.scrollParent(true);
      this.offsetParent = this.helper.offsetParent();
      this.hasFixedAncestor = this.helper.parents().filter(function () {
        return $(this).css('position') === 'fixed';
      }).length > 0;
      //The element's absolute position on the page minus margins
      this.positionAbs = this.element.offset();
      this._refreshOffsets(event);
      //Generate the original position
      this.originalPosition = this.position = this._generatePosition(event, false);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
      //Set a containment if given in the options
      this._setContainment();
      //Trigger event + callbacks
      if (this._trigger('start', event) === false) {
        this._clear();
        return false;
      }
      //Recache the helper size
      this._cacheHelperProportions();
      //Prepare the droppable offsets
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
      // Reset helper's right/bottom css if they're set and set explicit width/height instead
      // as this prevents resizing of elements with right/bottom set (see #7772)
      this._normalizeRightBottom();
      this._mouseDrag(event, true);
      //Execute the drag once - this causes the helper not to be visible before getting its correct position
      //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStart(this, event);
      }
      return true;
    },
    _refreshOffsets: function (event) {
      this.offset = {
        top: this.positionAbs.top - this.margins.top,
        left: this.positionAbs.left - this.margins.left,
        scroll: false,
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      };
      this.offset.click = {
        left: event.pageX - this.offset.left,
        top: event.pageY - this.offset.top
      };
    },
    _mouseDrag: function (event, noPropagation) {
      // reset any necessary cached properties (see #5009)
      if (this.hasFixedAncestor) {
        this.offset.parent = this._getParentOffset();
      }
      //Compute the helpers position
      this.position = this._generatePosition(event, true);
      this.positionAbs = this._convertPositionTo('absolute');
      //Call plugins and callbacks and use the resulting position if something is returned
      if (!noPropagation) {
        var ui = this._uiHash();
        if (this._trigger('drag', event, ui) === false) {
          this._mouseUp({});
          return false;
        }
        this.position = ui.position;
      }
      this.helper[0].style.left = this.position.left + 'px';
      this.helper[0].style.top = this.position.top + 'px';
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
      return false;
    },
    _mouseStop: function (event) {
      //If we are using droppables, inform the manager about the drop
      var that = this, dropped = false;
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        dropped = $.ui.ddmanager.drop(this, event);
      }
      //if a drop comes from outside (a sortable)
      if (this.dropped) {
        dropped = this.dropped;
        this.dropped = false;
      }
      if (this.options.revert === 'invalid' && !dropped || this.options.revert === 'valid' && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
          if (that._trigger('stop', event) !== false) {
            that._clear();
          }
        });
      } else {
        if (this._trigger('stop', event) !== false) {
          this._clear();
        }
      }
      return false;
    },
    _mouseUp: function (event) {
      this._unblockFrames();
      //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStop(this, event);
      }
      // Only need to focus if the event occurred on the draggable itself, see #10527
      if (this.handleElement.is(event.target)) {
        // The interaction is over; whether or not the click resulted in a drag, focus the element
        this.element.focus();
      }
      return $.ui.mouse.prototype._mouseUp.call(this, event);
    },
    cancel: function () {
      if (this.helper.is('.ui-draggable-dragging')) {
        this._mouseUp({});
      } else {
        this._clear();
      }
      return this;
    },
    _getHandle: function (event) {
      return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
    },
    _setHandleClassName: function () {
      this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
      this.handleElement.addClass('ui-draggable-handle');
    },
    _removeHandleClassName: function () {
      this.handleElement.removeClass('ui-draggable-handle');
    },
    _createHelper: function (event) {
      var o = this.options, helperIsFunction = $.isFunction(o.helper), helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : o.helper === 'clone' ? this.element.clone().removeAttr('id') : this.element;
      if (!helper.parents('body').length) {
        helper.appendTo(o.appendTo === 'parent' ? this.element[0].parentNode : o.appendTo);
      }
      // http://bugs.jqueryui.com/ticket/9446
      // a helper function can return the original element
      // which wouldn't have been set to relative in _create
      if (helperIsFunction && helper[0] === this.element[0]) {
        this._setPositionRelative();
      }
      if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css('position'))) {
        helper.css('position', 'absolute');
      }
      return helper;
    },
    _setPositionRelative: function () {
      if (!/^(?:r|a|f)/.test(this.element.css('position'))) {
        this.element[0].style.position = 'relative';
      }
    },
    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = {
          left: +obj[0],
          top: +obj[1] || 0
        };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
    _isRootNode: function (element) {
      return /(html|body)/i.test(element.tagName) || element === this.document[0];
    },
    _getParentOffset: function () {
      //Get the offsetParent and cache its position
      var po = this.offsetParent.offset(), document = this.document[0];
      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (this.cssPosition === 'absolute' && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
      if (this._isRootNode(this.offsetParent[0])) {
        po = {
          top: 0,
          left: 0
        };
      }
      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if (this.cssPosition !== 'relative') {
        return {
          top: 0,
          left: 0
        };
      }
      var p = this.element.position(), scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
      return {
        top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
        left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
      };
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.element.css('marginLeft'), 10) || 0,
        top: parseInt(this.element.css('marginTop'), 10) || 0,
        right: parseInt(this.element.css('marginRight'), 10) || 0,
        bottom: parseInt(this.element.css('marginBottom'), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var isUserScrollable, c, ce, o = this.options, document = this.document[0];
      this.relativeContainer = null;
      if (!o.containment) {
        this.containment = null;
        return;
      }
      if (o.containment === 'window') {
        this.containment = [
          $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
          $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
          $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left,
          $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
      if (o.containment === 'document') {
        this.containment = [
          0,
          0,
          $(document).width() - this.helperProportions.width - this.margins.left,
          ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
      if (o.containment.constructor === Array) {
        this.containment = o.containment;
        return;
      }
      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }
      c = $(o.containment);
      ce = c[0];
      if (!ce) {
        return;
      }
      isUserScrollable = /(scroll|auto)/.test(c.css('overflow'));
      this.containment = [
        (parseInt(c.css('borderLeftWidth'), 10) || 0) + (parseInt(c.css('paddingLeft'), 10) || 0),
        (parseInt(c.css('borderTopWidth'), 10) || 0) + (parseInt(c.css('paddingTop'), 10) || 0),
        (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css('borderRightWidth'), 10) || 0) - (parseInt(c.css('paddingRight'), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
        (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css('borderBottomWidth'), 10) || 0) - (parseInt(c.css('paddingBottom'), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom
      ];
      this.relativeContainer = c;
    },
    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === 'absolute' ? 1 : -1, scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
      return {
        top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === 'fixed' ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
        left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === 'fixed' ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
      };
    },
    _generatePosition: function (event, constrainPosition) {
      var containment, co, top, left, o = this.options, scrollIsRootNode = this._isRootNode(this.scrollParent[0]), pageX = event.pageX, pageY = event.pageY;
      // Cache the scroll
      if (!scrollIsRootNode || !this.offset.scroll) {
        this.offset.scroll = {
          top: this.scrollParent.scrollTop(),
          left: this.scrollParent.scrollLeft()
        };
      }
      /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
      // If we are not dragging yet, we won't check for options
      if (constrainPosition) {
        if (this.containment) {
          if (this.relativeContainer) {
            co = this.relativeContainer.offset();
            containment = [
              this.containment[0] + co.left,
              this.containment[1] + co.top,
              this.containment[2] + co.left,
              this.containment[3] + co.top
            ];
          } else {
            containment = this.containment;
          }
          if (event.pageX - this.offset.click.left < containment[0]) {
            pageX = containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < containment[1]) {
            pageY = containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > containment[2]) {
            pageX = containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > containment[3]) {
            pageY = containment[3] + this.offset.click.top;
          }
        }
        if (o.grid) {
          //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
          top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
          pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
          left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
          pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
        }
        if (o.axis === 'y') {
          pageX = this.originalPageX;
        }
        if (o.axis === 'x') {
          pageY = this.originalPageY;
        }
      }
      return {
        top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === 'fixed' ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
        left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === 'fixed' ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
      };
    },
    _clear: function () {
      this.helper.removeClass('ui-draggable-dragging');
      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
        this.helper.remove();
      }
      this.helper = null;
      this.cancelHelperRemoval = false;
      if (this.destroyOnClear) {
        this.destroy();
      }
    },
    _normalizeRightBottom: function () {
      if (this.options.axis !== 'y' && this.helper.css('right') !== 'auto') {
        this.helper.width(this.helper.width());
        this.helper.css('right', 'auto');
      }
      if (this.options.axis !== 'x' && this.helper.css('bottom') !== 'auto') {
        this.helper.height(this.helper.height());
        this.helper.css('bottom', 'auto');
      }
    },
    _trigger: function (type, event, ui) {
      ui = ui || this._uiHash();
      $.ui.plugin.call(this, type, [
        event,
        ui,
        this
      ], true);
      // Absolute position and offset (see #6884 ) have to be recalculated after plugins
      if (/^(drag|start|stop)/.test(type)) {
        this.positionAbs = this._convertPositionTo('absolute');
        ui.offset = this.positionAbs;
      }
      return $.Widget.prototype._trigger.call(this, type, event, ui);
    },
    plugins: {},
    _uiHash: function () {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  });
  $.ui.plugin.add('draggable', 'connectToSortable', {
    start: function (event, ui, draggable) {
      var uiSortable = $.extend({}, ui, { item: draggable.element });
      draggable.sortables = [];
      $(draggable.options.connectToSortable).each(function () {
        var sortable = $(this).sortable('instance');
        if (sortable && !sortable.options.disabled) {
          draggable.sortables.push(sortable);
          // refreshPositions is called at drag start to refresh the containerCache
          // which is used in drag. This ensures it's initialized and synchronized
          // with any changes that might have happened on the page since initialization.
          sortable.refreshPositions();
          sortable._trigger('activate', event, uiSortable);
        }
      });
    },
    stop: function (event, ui, draggable) {
      var uiSortable = $.extend({}, ui, { item: draggable.element });
      draggable.cancelHelperRemoval = false;
      $.each(draggable.sortables, function () {
        var sortable = this;
        if (sortable.isOver) {
          sortable.isOver = 0;
          // Allow this sortable to handle removing the helper
          draggable.cancelHelperRemoval = true;
          sortable.cancelHelperRemoval = false;
          // Use _storedCSS To restore properties in the sortable,
          // as this also handles revert (#9675) since the draggable
          // may have modified them in unexpected ways (#8809)
          sortable._storedCSS = {
            position: sortable.placeholder.css('position'),
            top: sortable.placeholder.css('top'),
            left: sortable.placeholder.css('left')
          };
          sortable._mouseStop(event);
          // Once drag has ended, the sortable should return to using
          // its original helper, not the shared helper from draggable
          sortable.options.helper = sortable.options._helper;
        } else {
          // Prevent this Sortable from removing the helper.
          // However, don't set the draggable to remove the helper
          // either as another connected Sortable may yet handle the removal.
          sortable.cancelHelperRemoval = true;
          sortable._trigger('deactivate', event, uiSortable);
        }
      });
    },
    drag: function (event, ui, draggable) {
      $.each(draggable.sortables, function () {
        var innermostIntersecting = false, sortable = this;
        // Copy over variables that sortable's _intersectsWith uses
        sortable.positionAbs = draggable.positionAbs;
        sortable.helperProportions = draggable.helperProportions;
        sortable.offset.click = draggable.offset.click;
        if (sortable._intersectsWith(sortable.containerCache)) {
          innermostIntersecting = true;
          $.each(draggable.sortables, function () {
            // Copy over variables that sortable's _intersectsWith uses
            this.positionAbs = draggable.positionAbs;
            this.helperProportions = draggable.helperProportions;
            this.offset.click = draggable.offset.click;
            if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {
              innermostIntersecting = false;
            }
            return innermostIntersecting;
          });
        }
        if (innermostIntersecting) {
          // If it intersects, we use a little isOver variable and set it once,
          // so that the move-in stuff gets fired only once.
          if (!sortable.isOver) {
            sortable.isOver = 1;
            // Store draggable's parent in case we need to reappend to it later.
            draggable._parent = ui.helper.parent();
            sortable.currentItem = ui.helper.appendTo(sortable.element).data('ui-sortable-item', true);
            // Store helper option to later restore it
            sortable.options._helper = sortable.options.helper;
            sortable.options.helper = function () {
              return ui.helper[0];
            };
            // Fire the start events of the sortable with our passed browser event,
            // and our own helper (so it doesn't create a new one)
            event.target = sortable.currentItem[0];
            sortable._mouseCapture(event, true);
            sortable._mouseStart(event, true, true);
            // Because the browser event is way off the new appended portlet,
            // modify necessary variables to reflect the changes
            sortable.offset.click.top = draggable.offset.click.top;
            sortable.offset.click.left = draggable.offset.click.left;
            sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
            sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
            draggable._trigger('toSortable', event);
            // Inform draggable that the helper is in a valid drop zone,
            // used solely in the revert option to handle "valid/invalid".
            draggable.dropped = sortable.element;
            // Need to refreshPositions of all sortables in the case that
            // adding to one sortable changes the location of the other sortables (#9675)
            $.each(draggable.sortables, function () {
              this.refreshPositions();
            });
            // hack so receive/update callbacks work (mostly)
            draggable.currentItem = draggable.element;
            sortable.fromOutside = draggable;
          }
          if (sortable.currentItem) {
            sortable._mouseDrag(event);
            // Copy the sortable's position because the draggable's can potentially reflect
            // a relative position, while sortable is always absolute, which the dragged
            // element has now become. (#8809)
            ui.position = sortable.position;
          }
        } else {
          // If it doesn't intersect with the sortable, and it intersected before,
          // we fake the drag stop of the sortable, but make sure it doesn't remove
          // the helper by using cancelHelperRemoval.
          if (sortable.isOver) {
            sortable.isOver = 0;
            sortable.cancelHelperRemoval = true;
            // Calling sortable's mouseStop would trigger a revert,
            // so revert must be temporarily false until after mouseStop is called.
            sortable.options._revert = sortable.options.revert;
            sortable.options.revert = false;
            sortable._trigger('out', event, sortable._uiHash(sortable));
            sortable._mouseStop(event, true);
            // restore sortable behaviors that were modfied
            // when the draggable entered the sortable area (#9481)
            sortable.options.revert = sortable.options._revert;
            sortable.options.helper = sortable.options._helper;
            if (sortable.placeholder) {
              sortable.placeholder.remove();
            }
            // Restore and recalculate the draggable's offset considering the sortable
            // may have modified them in unexpected ways. (#8809, #10669)
            ui.helper.appendTo(draggable._parent);
            draggable._refreshOffsets(event);
            ui.position = draggable._generatePosition(event, true);
            draggable._trigger('fromSortable', event);
            // Inform draggable that the helper is no longer in a valid drop zone
            draggable.dropped = false;
            // Need to refreshPositions of all sortables just in case removing
            // from one sortable changes the location of other sortables (#9675)
            $.each(draggable.sortables, function () {
              this.refreshPositions();
            });
          }
        }
      });
    }
  });
  $.ui.plugin.add('draggable', 'cursor', {
    start: function (event, ui, instance) {
      var t = $('body'), o = instance.options;
      if (t.css('cursor')) {
        o._cursor = t.css('cursor');
      }
      t.css('cursor', o.cursor);
    },
    stop: function (event, ui, instance) {
      var o = instance.options;
      if (o._cursor) {
        $('body').css('cursor', o._cursor);
      }
    }
  });
  $.ui.plugin.add('draggable', 'opacity', {
    start: function (event, ui, instance) {
      var t = $(ui.helper), o = instance.options;
      if (t.css('opacity')) {
        o._opacity = t.css('opacity');
      }
      t.css('opacity', o.opacity);
    },
    stop: function (event, ui, instance) {
      var o = instance.options;
      if (o._opacity) {
        $(ui.helper).css('opacity', o._opacity);
      }
    }
  });
  $.ui.plugin.add('draggable', 'scroll', {
    start: function (event, ui, i) {
      if (!i.scrollParentNotHidden) {
        i.scrollParentNotHidden = i.helper.scrollParent(false);
      }
      if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== 'HTML') {
        i.overflowOffset = i.scrollParentNotHidden.offset();
      }
    },
    drag: function (event, ui, i) {
      var o = i.options, scrolled = false, scrollParent = i.scrollParentNotHidden[0], document = i.document[0];
      if (scrollParent !== document && scrollParent.tagName !== 'HTML') {
        if (!o.axis || o.axis !== 'x') {
          if (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {
            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
          } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
          }
        }
        if (!o.axis || o.axis !== 'y') {
          if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {
            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
          } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
          }
        }
      } else {
        if (!o.axis || o.axis !== 'x') {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
        }
        if (!o.axis || o.axis !== 'y') {
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
      }
      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(i, event);
      }
    }
  });
  $.ui.plugin.add('draggable', 'snap', {
    start: function (event, ui, i) {
      var o = i.options;
      i.snapElements = [];
      $(o.snap.constructor !== String ? o.snap.items || ':data(ui-draggable)' : o.snap).each(function () {
        var $t = $(this), $o = $t.offset();
        if (this !== i.element[0]) {
          i.snapElements.push({
            item: this,
            width: $t.outerWidth(),
            height: $t.outerHeight(),
            top: $o.top,
            left: $o.left
          });
        }
      });
    },
    drag: function (event, ui, inst) {
      var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
      for (i = inst.snapElements.length - 1; i >= 0; i--) {
        l = inst.snapElements[i].left - inst.margins.left;
        r = l + inst.snapElements[i].width;
        t = inst.snapElements[i].top - inst.margins.top;
        b = t + inst.snapElements[i].height;
        if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
          if (inst.snapElements[i].snapping) {
            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));
          }
          inst.snapElements[i].snapping = false;
          continue;
        }
        if (o.snapMode !== 'inner') {
          ts = Math.abs(t - y2) <= d;
          bs = Math.abs(b - y1) <= d;
          ls = Math.abs(l - x2) <= d;
          rs = Math.abs(r - x1) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: t - inst.helperProportions.height,
              left: 0
            }).top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: b,
              left: 0
            }).top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: l - inst.helperProportions.width
            }).left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: r
            }).left;
          }
        }
        first = ts || bs || ls || rs;
        if (o.snapMode !== 'outer') {
          ts = Math.abs(t - y1) <= d;
          bs = Math.abs(b - y2) <= d;
          ls = Math.abs(l - x1) <= d;
          rs = Math.abs(r - x2) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: t,
              left: 0
            }).top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: b - inst.helperProportions.height,
              left: 0
            }).top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: l
            }).left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: r - inst.helperProportions.width
            }).left;
          }
        }
        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
          inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));
        }
        inst.snapElements[i].snapping = ts || bs || ls || rs || first;
      }
    }
  });
  $.ui.plugin.add('draggable', 'stack', {
    start: function (event, ui, instance) {
      var min, o = instance.options, group = $.makeArray($(o.stack)).sort(function (a, b) {
          return (parseInt($(a).css('zIndex'), 10) || 0) - (parseInt($(b).css('zIndex'), 10) || 0);
        });
      if (!group.length) {
        return;
      }
      min = parseInt($(group[0]).css('zIndex'), 10) || 0;
      $(group).each(function (i) {
        $(this).css('zIndex', min + i);
      });
      this.css('zIndex', min + group.length);
    }
  });
  $.ui.plugin.add('draggable', 'zIndex', {
    start: function (event, ui, instance) {
      var t = $(ui.helper), o = instance.options;
      if (t.css('zIndex')) {
        o._zIndex = t.css('zIndex');
      }
      t.css('zIndex', o.zIndex);
    },
    stop: function (event, ui, instance) {
      var o = instance.options;
      if (o._zIndex) {
        $(ui.helper).css('zIndex', o._zIndex);
      }
    }
  });
  var draggable = $.ui.draggable;
  /*!
 * jQuery UI Resizable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */
  $.widget('ui.resizable', $.ui.mouse, {
    version: '1.11.4',
    widgetEventPrefix: 'resize',
    options: {
      alsoResize: false,
      animate: false,
      animateDuration: 'slow',
      animateEasing: 'swing',
      aspectRatio: false,
      autoHide: false,
      containment: false,
      ghost: false,
      grid: false,
      handles: 'e,s,se',
      helper: false,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      zIndex: 90,
      resize: null,
      start: null,
      stop: null
    },
    _num: function (value) {
      return parseInt(value, 10) || 0;
    },
    _isNumber: function (value) {
      return !isNaN(parseInt(value, 10));
    },
    _hasScroll: function (el, a) {
      if ($(el).css('overflow') === 'hidden') {
        return false;
      }
      var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop', has = false;
      if (el[scroll] > 0) {
        return true;
      }
      // TODO: determine which cases actually cause this to happen
      // if the element doesn't have the scroll set, see if it's possible to
      // set the scroll
      el[scroll] = 1;
      has = el[scroll] > 0;
      el[scroll] = 0;
      return has;
    },
    _create: function () {
      var n, i, handle, axis, hname, that = this, o = this.options;
      this.element.addClass('ui-resizable');
      $.extend(this, {
        _aspectRatio: !!o.aspectRatio,
        aspectRatio: o.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
      });
      // Wrap the element if it cannot hold child nodes
      if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
        this.element.wrap($('<div class=\'ui-wrapper\' style=\'overflow: hidden;\'></div>').css({
          position: this.element.css('position'),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css('top'),
          left: this.element.css('left')
        }));
        this.element = this.element.parent().data('ui-resizable', this.element.resizable('instance'));
        this.elementIsWrapper = true;
        this.element.css({
          marginLeft: this.originalElement.css('marginLeft'),
          marginTop: this.originalElement.css('marginTop'),
          marginRight: this.originalElement.css('marginRight'),
          marginBottom: this.originalElement.css('marginBottom')
        });
        this.originalElement.css({
          marginLeft: 0,
          marginTop: 0,
          marginRight: 0,
          marginBottom: 0
        });
        // support: Safari
        // Prevent Safari textarea resize
        this.originalResizeStyle = this.originalElement.css('resize');
        this.originalElement.css('resize', 'none');
        this._proportionallyResizeElements.push(this.originalElement.css({
          position: 'static',
          zoom: 1,
          display: 'block'
        }));
        // support: IE9
        // avoid IE jump (hard set the margin)
        this.originalElement.css({ margin: this.originalElement.css('margin') });
        this._proportionallyResize();
      }
      this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? 'e,s,se' : {
        n: '.ui-resizable-n',
        e: '.ui-resizable-e',
        s: '.ui-resizable-s',
        w: '.ui-resizable-w',
        se: '.ui-resizable-se',
        sw: '.ui-resizable-sw',
        ne: '.ui-resizable-ne',
        nw: '.ui-resizable-nw'
      });
      this._handles = $();
      if (this.handles.constructor === String) {
        if (this.handles === 'all') {
          this.handles = 'n,e,s,w,se,sw,ne,nw';
        }
        n = this.handles.split(',');
        this.handles = {};
        for (i = 0; i < n.length; i++) {
          handle = $.trim(n[i]);
          hname = 'ui-resizable-' + handle;
          axis = $('<div class=\'ui-resizable-handle ' + hname + '\'></div>');
          axis.css({ zIndex: o.zIndex });
          // TODO : What's going on here?
          if ('se' === handle) {
            axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
          }
          this.handles[handle] = '.ui-resizable-' + handle;
          this.element.append(axis);
        }
      }
      this._renderAxis = function (target) {
        var i, axis, padPos, padWrapper;
        target = target || this.element;
        for (i in this.handles) {
          if (this.handles[i].constructor === String) {
            this.handles[i] = this.element.children(this.handles[i]).first().show();
          } else if (this.handles[i].jquery || this.handles[i].nodeType) {
            this.handles[i] = $(this.handles[i]);
            this._on(this.handles[i], { 'mousedown': that._mouseDown });
          }
          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
            axis = $(this.handles[i], this.element);
            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
            padPos = [
              'padding',
              /ne|nw|n/.test(i) ? 'Top' : /se|sw|s/.test(i) ? 'Bottom' : /^e$/.test(i) ? 'Right' : 'Left'
            ].join('');
            target.css(padPos, padWrapper);
            this._proportionallyResize();
          }
          this._handles = this._handles.add(this.handles[i]);
        }
      };
      // TODO: make renderAxis a prototype function
      this._renderAxis(this.element);
      this._handles = this._handles.add(this.element.find('.ui-resizable-handle'));
      this._handles.disableSelection();
      this._handles.mouseover(function () {
        if (!that.resizing) {
          if (this.className) {
            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          }
          that.axis = axis && axis[1] ? axis[1] : 'se';
        }
      });
      if (o.autoHide) {
        this._handles.hide();
        $(this.element).addClass('ui-resizable-autohide').mouseenter(function () {
          if (o.disabled) {
            return;
          }
          $(this).removeClass('ui-resizable-autohide');
          that._handles.show();
        }).mouseleave(function () {
          if (o.disabled) {
            return;
          }
          if (!that.resizing) {
            $(this).addClass('ui-resizable-autohide');
            that._handles.hide();
          }
        });
      }
      this._mouseInit();
    },
    _destroy: function () {
      this._mouseDestroy();
      var wrapper, _destroy = function (exp) {
          $(exp).removeClass('ui-resizable ui-resizable-disabled ui-resizable-resizing').removeData('resizable').removeData('ui-resizable').unbind('.resizable').find('.ui-resizable-handle').remove();
        };
      // TODO: Unwrap at same DOM position
      if (this.elementIsWrapper) {
        _destroy(this.element);
        wrapper = this.element;
        this.originalElement.css({
          position: wrapper.css('position'),
          width: wrapper.outerWidth(),
          height: wrapper.outerHeight(),
          top: wrapper.css('top'),
          left: wrapper.css('left')
        }).insertAfter(wrapper);
        wrapper.remove();
      }
      this.originalElement.css('resize', this.originalResizeStyle);
      _destroy(this.originalElement);
      return this;
    },
    _mouseCapture: function (event) {
      var i, handle, capture = false;
      for (i in this.handles) {
        handle = $(this.handles[i])[0];
        if (handle === event.target || $.contains(handle, event.target)) {
          capture = true;
        }
      }
      return !this.options.disabled && capture;
    },
    _mouseStart: function (event) {
      var curleft, curtop, cursor, o = this.options, el = this.element;
      this.resizing = true;
      this._renderProxy();
      curleft = this._num(this.helper.css('left'));
      curtop = this._num(this.helper.css('top'));
      if (o.containment) {
        curleft += $(o.containment).scrollLeft() || 0;
        curtop += $(o.containment).scrollTop() || 0;
      }
      this.offset = this.helper.offset();
      this.position = {
        left: curleft,
        top: curtop
      };
      this.size = this._helper ? {
        width: this.helper.width(),
        height: this.helper.height()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.originalSize = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.sizeDiff = {
        width: el.outerWidth() - el.width(),
        height: el.outerHeight() - el.height()
      };
      this.originalPosition = {
        left: curleft,
        top: curtop
      };
      this.originalMousePosition = {
        left: event.pageX,
        top: event.pageY
      };
      this.aspectRatio = typeof o.aspectRatio === 'number' ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
      cursor = $('.ui-resizable-' + this.axis).css('cursor');
      $('body').css('cursor', cursor === 'auto' ? this.axis + '-resize' : cursor);
      el.addClass('ui-resizable-resizing');
      this._propagate('start', event);
      return true;
    },
    _mouseDrag: function (event) {
      var data, props, smp = this.originalMousePosition, a = this.axis, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
      this._updatePrevProperties();
      if (!trigger) {
        return false;
      }
      data = trigger.apply(this, [
        event,
        dx,
        dy
      ]);
      this._updateVirtualBoundaries(event.shiftKey);
      if (this._aspectRatio || event.shiftKey) {
        data = this._updateRatio(data, event);
      }
      data = this._respectSize(data, event);
      this._updateCache(data);
      this._propagate('resize', event);
      props = this._applyChanges();
      if (!this._helper && this._proportionallyResizeElements.length) {
        this._proportionallyResize();
      }
      if (!$.isEmptyObject(props)) {
        this._updatePrevProperties();
        this._trigger('resize', event, this.ui());
        this._applyChanges();
      }
      return false;
    },
    _mouseStop: function (event) {
      this.resizing = false;
      var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
      if (this._helper) {
        pr = this._proportionallyResizeElements;
        ista = pr.length && /textarea/i.test(pr[0].nodeName);
        soffseth = ista && this._hasScroll(pr[0], 'left') ? 0 : that.sizeDiff.height;
        soffsetw = ista ? 0 : that.sizeDiff.width;
        s = {
          width: that.helper.width() - soffsetw,
          height: that.helper.height() - soffseth
        };
        left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null;
        top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;
        if (!o.animate) {
          this.element.css($.extend(s, {
            top: top,
            left: left
          }));
        }
        that.helper.height(that.size.height);
        that.helper.width(that.size.width);
        if (this._helper && !o.animate) {
          this._proportionallyResize();
        }
      }
      $('body').css('cursor', 'auto');
      this.element.removeClass('ui-resizable-resizing');
      this._propagate('stop', event);
      if (this._helper) {
        this.helper.remove();
      }
      return false;
    },
    _updatePrevProperties: function () {
      this.prevPosition = {
        top: this.position.top,
        left: this.position.left
      };
      this.prevSize = {
        width: this.size.width,
        height: this.size.height
      };
    },
    _applyChanges: function () {
      var props = {};
      if (this.position.top !== this.prevPosition.top) {
        props.top = this.position.top + 'px';
      }
      if (this.position.left !== this.prevPosition.left) {
        props.left = this.position.left + 'px';
      }
      if (this.size.width !== this.prevSize.width) {
        props.width = this.size.width + 'px';
      }
      if (this.size.height !== this.prevSize.height) {
        props.height = this.size.height + 'px';
      }
      this.helper.css(props);
      return props;
    },
    _updateVirtualBoundaries: function (forceAspectRatio) {
      var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
      b = {
        minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
        maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
        minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
        maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
      };
      if (this._aspectRatio || forceAspectRatio) {
        pMinWidth = b.minHeight * this.aspectRatio;
        pMinHeight = b.minWidth / this.aspectRatio;
        pMaxWidth = b.maxHeight * this.aspectRatio;
        pMaxHeight = b.maxWidth / this.aspectRatio;
        if (pMinWidth > b.minWidth) {
          b.minWidth = pMinWidth;
        }
        if (pMinHeight > b.minHeight) {
          b.minHeight = pMinHeight;
        }
        if (pMaxWidth < b.maxWidth) {
          b.maxWidth = pMaxWidth;
        }
        if (pMaxHeight < b.maxHeight) {
          b.maxHeight = pMaxHeight;
        }
      }
      this._vBoundaries = b;
    },
    _updateCache: function (data) {
      this.offset = this.helper.offset();
      if (this._isNumber(data.left)) {
        this.position.left = data.left;
      }
      if (this._isNumber(data.top)) {
        this.position.top = data.top;
      }
      if (this._isNumber(data.height)) {
        this.size.height = data.height;
      }
      if (this._isNumber(data.width)) {
        this.size.width = data.width;
      }
    },
    _updateRatio: function (data) {
      var cpos = this.position, csize = this.size, a = this.axis;
      if (this._isNumber(data.height)) {
        data.width = data.height * this.aspectRatio;
      } else if (this._isNumber(data.width)) {
        data.height = data.width / this.aspectRatio;
      }
      if (a === 'sw') {
        data.left = cpos.left + (csize.width - data.width);
        data.top = null;
      }
      if (a === 'nw') {
        data.top = cpos.top + (csize.height - data.height);
        data.left = cpos.left + (csize.width - data.width);
      }
      return data;
    },
    _respectSize: function (data) {
      var o = this._vBoundaries, a = this.axis, ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
      if (isminw) {
        data.width = o.minWidth;
      }
      if (isminh) {
        data.height = o.minHeight;
      }
      if (ismaxw) {
        data.width = o.maxWidth;
      }
      if (ismaxh) {
        data.height = o.maxHeight;
      }
      if (isminw && cw) {
        data.left = dw - o.minWidth;
      }
      if (ismaxw && cw) {
        data.left = dw - o.maxWidth;
      }
      if (isminh && ch) {
        data.top = dh - o.minHeight;
      }
      if (ismaxh && ch) {
        data.top = dh - o.maxHeight;
      }
      // Fixing jump error on top/left - bug #2330
      if (!data.width && !data.height && !data.left && data.top) {
        data.top = null;
      } else if (!data.width && !data.height && !data.top && data.left) {
        data.left = null;
      }
      return data;
    },
    _getPaddingPlusBorderDimensions: function (element) {
      var i = 0, widths = [], borders = [
          element.css('borderTopWidth'),
          element.css('borderRightWidth'),
          element.css('borderBottomWidth'),
          element.css('borderLeftWidth')
        ], paddings = [
          element.css('paddingTop'),
          element.css('paddingRight'),
          element.css('paddingBottom'),
          element.css('paddingLeft')
        ];
      for (; i < 4; i++) {
        widths[i] = parseInt(borders[i], 10) || 0;
        widths[i] += parseInt(paddings[i], 10) || 0;
      }
      return {
        height: widths[0] + widths[2],
        width: widths[1] + widths[3]
      };
    },
    _proportionallyResize: function () {
      if (!this._proportionallyResizeElements.length) {
        return;
      }
      var prel, i = 0, element = this.helper || this.element;
      for (; i < this._proportionallyResizeElements.length; i++) {
        prel = this._proportionallyResizeElements[i];
        // TODO: Seems like a bug to cache this.outerDimensions
        // considering that we are in a loop.
        if (!this.outerDimensions) {
          this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
        }
        prel.css({
          height: element.height() - this.outerDimensions.height || 0,
          width: element.width() - this.outerDimensions.width || 0
        });
      }
    },
    _renderProxy: function () {
      var el = this.element, o = this.options;
      this.elementOffset = el.offset();
      if (this._helper) {
        this.helper = this.helper || $('<div style=\'overflow:hidden;\'></div>');
        this.helper.addClass(this._helper).css({
          width: this.element.outerWidth() - 1,
          height: this.element.outerHeight() - 1,
          position: 'absolute',
          left: this.elementOffset.left + 'px',
          top: this.elementOffset.top + 'px',
          zIndex: ++o.zIndex
        });
        this.helper.appendTo('body').disableSelection();
      } else {
        this.helper = this.element;
      }
    },
    _change: {
      e: function (event, dx) {
        return { width: this.originalSize.width + dx };
      },
      w: function (event, dx) {
        var cs = this.originalSize, sp = this.originalPosition;
        return {
          left: sp.left + dx,
          width: cs.width - dx
        };
      },
      n: function (event, dx, dy) {
        var cs = this.originalSize, sp = this.originalPosition;
        return {
          top: sp.top + dy,
          height: cs.height - dy
        };
      },
      s: function (event, dx, dy) {
        return { height: this.originalSize.height + dy };
      },
      se: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      sw: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      ne: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      nw: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [
          event,
          dx,
          dy
        ]));
      }
    },
    _propagate: function (n, event) {
      $.ui.plugin.call(this, n, [
        event,
        this.ui()
      ]);
      n !== 'resize' && this._trigger(n, event, this.ui());
    },
    plugins: {},
    ui: function () {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  });
  /*
 * Resizable Extensions
 */
  $.ui.plugin.add('resizable', 'animate', {
    stop: function (event) {
      var that = $(this).resizable('instance'), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && that._hasScroll(pr[0], 'left') ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
          width: that.size.width - soffsetw,
          height: that.size.height - soffseth
        }, left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;
      that.element.animate($.extend(style, top && left ? {
        top: top,
        left: left
      } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function () {
          var data = {
              width: parseInt(that.element.css('width'), 10),
              height: parseInt(that.element.css('height'), 10),
              top: parseInt(that.element.css('top'), 10),
              left: parseInt(that.element.css('left'), 10)
            };
          if (pr && pr.length) {
            $(pr[0]).css({
              width: data.width,
              height: data.height
            });
          }
          // propagating resize, and updating values for each animation step
          that._updateCache(data);
          that._propagate('resize', event);
        }
      });
    }
  });
  $.ui.plugin.add('resizable', 'containment', {
    start: function () {
      var element, p, co, ch, cw, width, height, that = $(this).resizable('instance'), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
      if (!ce) {
        return;
      }
      that.containerElement = $(ce);
      if (/document/.test(oc) || oc === document) {
        that.containerOffset = {
          left: 0,
          top: 0
        };
        that.containerPosition = {
          left: 0,
          top: 0
        };
        that.parentData = {
          element: $(document),
          left: 0,
          top: 0,
          width: $(document).width(),
          height: $(document).height() || document.body.parentNode.scrollHeight
        };
      } else {
        element = $(ce);
        p = [];
        $([
          'Top',
          'Right',
          'Left',
          'Bottom'
        ]).each(function (i, name) {
          p[i] = that._num(element.css('padding' + name));
        });
        that.containerOffset = element.offset();
        that.containerPosition = element.position();
        that.containerSize = {
          height: element.innerHeight() - p[3],
          width: element.innerWidth() - p[1]
        };
        co = that.containerOffset;
        ch = that.containerSize.height;
        cw = that.containerSize.width;
        width = that._hasScroll(ce, 'left') ? ce.scrollWidth : cw;
        height = that._hasScroll(ce) ? ce.scrollHeight : ch;
        that.parentData = {
          element: ce,
          left: co.left,
          top: co.top,
          width: width,
          height: height
        };
      }
    },
    resize: function (event) {
      var woset, hoset, isParent, isOffsetRelative, that = $(this).resizable('instance'), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
          top: 0,
          left: 0
        }, ce = that.containerElement, continueResize = true;
      if (ce[0] !== document && /static/.test(ce.css('position'))) {
        cop = co;
      }
      if (cp.left < (that._helper ? co.left : 0)) {
        that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
          continueResize = false;
        }
        that.position.left = o.helper ? co.left : 0;
      }
      if (cp.top < (that._helper ? co.top : 0)) {
        that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
          continueResize = false;
        }
        that.position.top = that._helper ? co.top : 0;
      }
      isParent = that.containerElement.get(0) === that.element.parent().get(0);
      isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));
      if (isParent && isOffsetRelative) {
        that.offset.left = that.parentData.left + that.position.left;
        that.offset.top = that.parentData.top + that.position.top;
      } else {
        that.offset.left = that.element.offset().left;
        that.offset.top = that.element.offset().top;
      }
      woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
      hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
      if (woset + that.size.width >= that.parentData.width) {
        that.size.width = that.parentData.width - woset;
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
          continueResize = false;
        }
      }
      if (hoset + that.size.height >= that.parentData.height) {
        that.size.height = that.parentData.height - hoset;
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
          continueResize = false;
        }
      }
      if (!continueResize) {
        that.position.left = that.prevPosition.left;
        that.position.top = that.prevPosition.top;
        that.size.width = that.prevSize.width;
        that.size.height = that.prevSize.height;
      }
    },
    stop: function () {
      var that = $(this).resizable('instance'), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
      if (that._helper && !o.animate && /relative/.test(ce.css('position'))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
      if (that._helper && !o.animate && /static/.test(ce.css('position'))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
    }
  });
  $.ui.plugin.add('resizable', 'alsoResize', {
    start: function () {
      var that = $(this).resizable('instance'), o = that.options;
      $(o.alsoResize).each(function () {
        var el = $(this);
        el.data('ui-resizable-alsoresize', {
          width: parseInt(el.width(), 10),
          height: parseInt(el.height(), 10),
          left: parseInt(el.css('left'), 10),
          top: parseInt(el.css('top'), 10)
        });
      });
    },
    resize: function (event, ui) {
      var that = $(this).resizable('instance'), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
          height: that.size.height - os.height || 0,
          width: that.size.width - os.width || 0,
          top: that.position.top - op.top || 0,
          left: that.position.left - op.left || 0
        };
      $(o.alsoResize).each(function () {
        var el = $(this), start = $(this).data('ui-resizable-alsoresize'), style = {}, css = el.parents(ui.originalElement[0]).length ? [
            'width',
            'height'
          ] : [
            'width',
            'height',
            'top',
            'left'
          ];
        $.each(css, function (i, prop) {
          var sum = (start[prop] || 0) + (delta[prop] || 0);
          if (sum && sum >= 0) {
            style[prop] = sum || null;
          }
        });
        el.css(style);
      });
    },
    stop: function () {
      $(this).removeData('resizable-alsoresize');
    }
  });
  $.ui.plugin.add('resizable', 'ghost', {
    start: function () {
      var that = $(this).resizable('instance'), o = that.options, cs = that.size;
      that.ghost = that.originalElement.clone();
      that.ghost.css({
        opacity: 0.25,
        display: 'block',
        position: 'relative',
        height: cs.height,
        width: cs.width,
        margin: 0,
        left: 0,
        top: 0
      }).addClass('ui-resizable-ghost').addClass(typeof o.ghost === 'string' ? o.ghost : '');
      that.ghost.appendTo(that.helper);
    },
    resize: function () {
      var that = $(this).resizable('instance');
      if (that.ghost) {
        that.ghost.css({
          position: 'relative',
          height: that.size.height,
          width: that.size.width
        });
      }
    },
    stop: function () {
      var that = $(this).resizable('instance');
      if (that.ghost && that.helper) {
        that.helper.get(0).removeChild(that.ghost.get(0));
      }
    }
  });
  $.ui.plugin.add('resizable', 'grid', {
    resize: function () {
      var outerDimensions, that = $(this).resizable('instance'), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === 'number' ? [
          o.grid,
          o.grid
        ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
      o.grid = grid;
      if (isMinWidth) {
        newWidth += gridX;
      }
      if (isMinHeight) {
        newHeight += gridY;
      }
      if (isMaxWidth) {
        newWidth -= gridX;
      }
      if (isMaxHeight) {
        newHeight -= gridY;
      }
      if (/^(se|s|e)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
      } else if (/^(ne)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else if (/^(sw)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.left = op.left - ox;
      } else {
        if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
          outerDimensions = that._getPaddingPlusBorderDimensions(this);
        }
        if (newHeight - gridY > 0) {
          that.size.height = newHeight;
          that.position.top = op.top - oy;
        } else {
          newHeight = gridY - outerDimensions.height;
          that.size.height = newHeight;
          that.position.top = op.top + os.height - newHeight;
        }
        if (newWidth - gridX > 0) {
          that.size.width = newWidth;
          that.position.left = op.left - ox;
        } else {
          newWidth = gridX - outerDimensions.width;
          that.size.width = newWidth;
          that.position.left = op.left + os.width - newWidth;
        }
      }
    }
  });
  var resizable = $.ui.resizable;
  /*!
 * jQuery UI Dialog 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/dialog/
 */
  var dialog = $.widget('ui.dialog', {
      version: '1.11.4',
      options: {
        appendTo: 'body',
        autoOpen: true,
        buttons: [],
        closeOnEscape: true,
        closeText: 'Close',
        dialogClass: '',
        draggable: true,
        hide: null,
        height: 'auto',
        maxHeight: null,
        maxWidth: null,
        minHeight: 150,
        minWidth: 150,
        modal: false,
        position: {
          my: 'center',
          at: 'center',
          of: window,
          collision: 'fit',
          using: function (pos) {
            var topOffset = $(this).css(pos).offset().top;
            if (topOffset < 0) {
              $(this).css('top', pos.top - topOffset);
            }
          }
        },
        resizable: true,
        show: null,
        title: null,
        width: 300,
        beforeClose: null,
        close: null,
        drag: null,
        dragStart: null,
        dragStop: null,
        focus: null,
        open: null,
        resize: null,
        resizeStart: null,
        resizeStop: null
      },
      sizeRelatedOptions: {
        buttons: true,
        height: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        width: true
      },
      resizableRelatedOptions: {
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true
      },
      _create: function () {
        this.originalCss = {
          display: this.element[0].style.display,
          width: this.element[0].style.width,
          minHeight: this.element[0].style.minHeight,
          maxHeight: this.element[0].style.maxHeight,
          height: this.element[0].style.height
        };
        this.originalPosition = {
          parent: this.element.parent(),
          index: this.element.parent().children().index(this.element)
        };
        this.originalTitle = this.element.attr('title');
        this.options.title = this.options.title || this.originalTitle;
        this._createWrapper();
        this.element.show().removeAttr('title').addClass('ui-dialog-content ui-widget-content').appendTo(this.uiDialog);
        this._createTitlebar();
        this._createButtonPane();
        if (this.options.draggable && $.fn.draggable) {
          this._makeDraggable();
        }
        if (this.options.resizable && $.fn.resizable) {
          this._makeResizable();
        }
        this._isOpen = false;
        this._trackFocus();
      },
      _init: function () {
        if (this.options.autoOpen) {
          this.open();
        }
      },
      _appendTo: function () {
        var element = this.options.appendTo;
        if (element && (element.jquery || element.nodeType)) {
          return $(element);
        }
        return this.document.find(element || 'body').eq(0);
      },
      _destroy: function () {
        var next, originalPosition = this.originalPosition;
        this._untrackInstance();
        this._destroyOverlay();
        this.element.removeUniqueId().removeClass('ui-dialog-content ui-widget-content').css(this.originalCss).detach();
        this.uiDialog.stop(true, true).remove();
        if (this.originalTitle) {
          this.element.attr('title', this.originalTitle);
        }
        next = originalPosition.parent.children().eq(originalPosition.index);
        // Don't try to place the dialog next to itself (#8613)
        if (next.length && next[0] !== this.element[0]) {
          next.before(this.element);
        } else {
          originalPosition.parent.append(this.element);
        }
      },
      widget: function () {
        return this.uiDialog;
      },
      disable: $.noop,
      enable: $.noop,
      close: function (event) {
        var activeElement, that = this;
        if (!this._isOpen || this._trigger('beforeClose', event) === false) {
          return;
        }
        this._isOpen = false;
        this._focusedElement = null;
        this._destroyOverlay();
        this._untrackInstance();
        if (!this.opener.filter(':focusable').focus().length) {
          // support: IE9
          // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
          try {
            activeElement = this.document[0].activeElement;
            // Support: IE9, IE10
            // If the <body> is blurred, IE will switch windows, see #4520
            if (activeElement && activeElement.nodeName.toLowerCase() !== 'body') {
              // Hiding a focused element doesn't trigger blur in WebKit
              // so in case we have nothing to focus on, explicitly blur the active element
              // https://bugs.webkit.org/show_bug.cgi?id=47182
              $(activeElement).blur();
            }
          } catch (error) {
          }
        }
        this._hide(this.uiDialog, this.options.hide, function () {
          that._trigger('close', event);
        });
      },
      isOpen: function () {
        return this._isOpen;
      },
      moveToTop: function () {
        this._moveToTop();
      },
      _moveToTop: function (event, silent) {
        var moved = false, zIndices = this.uiDialog.siblings('.ui-front:visible').map(function () {
            return +$(this).css('z-index');
          }).get(), zIndexMax = Math.max.apply(null, zIndices);
        if (zIndexMax >= +this.uiDialog.css('z-index')) {
          this.uiDialog.css('z-index', zIndexMax + 1);
          moved = true;
        }
        if (moved && !silent) {
          this._trigger('focus', event);
        }
        return moved;
      },
      open: function () {
        var that = this;
        if (this._isOpen) {
          if (this._moveToTop()) {
            this._focusTabbable();
          }
          return;
        }
        this._isOpen = true;
        this.opener = $(this.document[0].activeElement);
        this._size();
        this._position();
        this._createOverlay();
        this._moveToTop(null, true);
        // Ensure the overlay is moved to the top with the dialog, but only when
        // opening. The overlay shouldn't move after the dialog is open so that
        // modeless dialogs opened after the modal dialog stack properly.
        if (this.overlay) {
          this.overlay.css('z-index', this.uiDialog.css('z-index') - 1);
        }
        this._show(this.uiDialog, this.options.show, function () {
          that._focusTabbable();
          that._trigger('focus');
        });
        // Track the dialog immediately upon openening in case a focus event
        // somehow occurs outside of the dialog before an element inside the
        // dialog is focused (#10152)
        this._makeFocusTarget();
        this._trigger('open');
      },
      _focusTabbable: function () {
        // Set focus to the first match:
        // 1. An element that was focused previously
        // 2. First element inside the dialog matching [autofocus]
        // 3. Tabbable element inside the content element
        // 4. Tabbable element inside the buttonpane
        // 5. The close button
        // 6. The dialog itself
        var hasFocus = this._focusedElement;
        if (!hasFocus) {
          hasFocus = this.element.find('[autofocus]');
        }
        if (!hasFocus.length) {
          hasFocus = this.element.find(':tabbable');
        }
        if (!hasFocus.length) {
          hasFocus = this.uiDialogButtonPane.find(':tabbable');
        }
        if (!hasFocus.length) {
          hasFocus = this.uiDialogTitlebarClose.filter(':tabbable');
        }
        if (!hasFocus.length) {
          hasFocus = this.uiDialog;
        }
        hasFocus.eq(0).focus();
      },
      _keepFocus: function (event) {
        function checkFocus() {
          var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
          if (!isActive) {
            this._focusTabbable();
          }
        }
        event.preventDefault();
        checkFocus.call(this);
        // support: IE
        // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
        // so we check again later
        this._delay(checkFocus);
      },
      _createWrapper: function () {
        this.uiDialog = $('<div>').addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front ' + this.options.dialogClass).hide().attr({
          tabIndex: -1,
          role: 'dialog'
        }).appendTo(this._appendTo());
        this._on(this.uiDialog, {
          keydown: function (event) {
            if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
              event.preventDefault();
              this.close(event);
              return;
            }
            // prevent tabbing out of dialogs
            if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
              return;
            }
            var tabbables = this.uiDialog.find(':tabbable'), first = tabbables.filter(':first'), last = tabbables.filter(':last');
            if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
              this._delay(function () {
                first.focus();
              });
              event.preventDefault();
            } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
              this._delay(function () {
                last.focus();
              });
              event.preventDefault();
            }
          },
          mousedown: function (event) {
            if (this._moveToTop(event)) {
              this._focusTabbable();
            }
          }
        });
        // We assume that any existing aria-describedby attribute means
        // that the dialog content is marked up properly
        // otherwise we brute force the content as the description
        if (!this.element.find('[aria-describedby]').length) {
          this.uiDialog.attr({ 'aria-describedby': this.element.uniqueId().attr('id') });
        }
      },
      _createTitlebar: function () {
        var uiDialogTitle;
        this.uiDialogTitlebar = $('<div>').addClass('ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix').prependTo(this.uiDialog);
        this._on(this.uiDialogTitlebar, {
          mousedown: function (event) {
            // Don't prevent click on close button (#8838)
            // Focusing a dialog that is partially scrolled out of view
            // causes the browser to scroll it into view, preventing the click event
            if (!$(event.target).closest('.ui-dialog-titlebar-close')) {
              // Dialog isn't getting focus when dragging (#8063)
              this.uiDialog.focus();
            }
          }
        });
        // support: IE
        // Use type="button" to prevent enter keypresses in textboxes from closing the
        // dialog in IE (#9312)
        this.uiDialogTitlebarClose = $('<button type=\'button\'></button>').button({
          label: this.options.closeText,
          icons: { primary: 'ui-icon-closethick' },
          text: false
        }).addClass('ui-dialog-titlebar-close').appendTo(this.uiDialogTitlebar);
        this._on(this.uiDialogTitlebarClose, {
          click: function (event) {
            event.preventDefault();
            this.close(event);
          }
        });
        uiDialogTitle = $('<span>').uniqueId().addClass('ui-dialog-title').prependTo(this.uiDialogTitlebar);
        this._title(uiDialogTitle);
        this.uiDialog.attr({ 'aria-labelledby': uiDialogTitle.attr('id') });
      },
      _title: function (title) {
        if (!this.options.title) {
          title.html('&#160;');
        }
        title.text(this.options.title);
      },
      _createButtonPane: function () {
        this.uiDialogButtonPane = $('<div>').addClass('ui-dialog-buttonpane ui-widget-content ui-helper-clearfix');
        this.uiButtonSet = $('<div>').addClass('ui-dialog-buttonset').appendTo(this.uiDialogButtonPane);
        this._createButtons();
      },
      _createButtons: function () {
        var that = this, buttons = this.options.buttons;
        // if we already have a button pane, remove it
        this.uiDialogButtonPane.remove();
        this.uiButtonSet.empty();
        if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
          this.uiDialog.removeClass('ui-dialog-buttons');
          return;
        }
        $.each(buttons, function (name, props) {
          var click, buttonOptions;
          props = $.isFunction(props) ? {
            click: props,
            text: name
          } : props;
          // Default to a non-submitting button
          props = $.extend({ type: 'button' }, props);
          // Change the context for the click callback to be the main element
          click = props.click;
          props.click = function () {
            click.apply(that.element[0], arguments);
          };
          buttonOptions = {
            icons: props.icons,
            text: props.showText
          };
          delete props.icons;
          delete props.showText;
          $('<button></button>', props).button(buttonOptions).appendTo(that.uiButtonSet);
        });
        this.uiDialog.addClass('ui-dialog-buttons');
        this.uiDialogButtonPane.appendTo(this.uiDialog);
      },
      _makeDraggable: function () {
        var that = this, options = this.options;
        function filteredUi(ui) {
          return {
            position: ui.position,
            offset: ui.offset
          };
        }
        this.uiDialog.draggable({
          cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
          handle: '.ui-dialog-titlebar',
          containment: 'document',
          start: function (event, ui) {
            $(this).addClass('ui-dialog-dragging');
            that._blockFrames();
            that._trigger('dragStart', event, filteredUi(ui));
          },
          drag: function (event, ui) {
            that._trigger('drag', event, filteredUi(ui));
          },
          stop: function (event, ui) {
            var left = ui.offset.left - that.document.scrollLeft(), top = ui.offset.top - that.document.scrollTop();
            options.position = {
              my: 'left top',
              at: 'left' + (left >= 0 ? '+' : '') + left + ' ' + 'top' + (top >= 0 ? '+' : '') + top,
              of: that.window
            };
            $(this).removeClass('ui-dialog-dragging');
            that._unblockFrames();
            that._trigger('dragStop', event, filteredUi(ui));
          }
        });
      },
      _makeResizable: function () {
        var that = this, options = this.options, handles = options.resizable,
          // .ui-resizable has position: relative defined in the stylesheet
          // but dialogs have to use absolute or fixed positioning
          position = this.uiDialog.css('position'), resizeHandles = typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw';
        function filteredUi(ui) {
          return {
            originalPosition: ui.originalPosition,
            originalSize: ui.originalSize,
            position: ui.position,
            size: ui.size
          };
        }
        this.uiDialog.resizable({
          cancel: '.ui-dialog-content',
          containment: 'document',
          alsoResize: this.element,
          maxWidth: options.maxWidth,
          maxHeight: options.maxHeight,
          minWidth: options.minWidth,
          minHeight: this._minHeight(),
          handles: resizeHandles,
          start: function (event, ui) {
            $(this).addClass('ui-dialog-resizing');
            that._blockFrames();
            that._trigger('resizeStart', event, filteredUi(ui));
          },
          resize: function (event, ui) {
            that._trigger('resize', event, filteredUi(ui));
          },
          stop: function (event, ui) {
            var offset = that.uiDialog.offset(), left = offset.left - that.document.scrollLeft(), top = offset.top - that.document.scrollTop();
            options.height = that.uiDialog.height();
            options.width = that.uiDialog.width();
            options.position = {
              my: 'left top',
              at: 'left' + (left >= 0 ? '+' : '') + left + ' ' + 'top' + (top >= 0 ? '+' : '') + top,
              of: that.window
            };
            $(this).removeClass('ui-dialog-resizing');
            that._unblockFrames();
            that._trigger('resizeStop', event, filteredUi(ui));
          }
        }).css('position', position);
      },
      _trackFocus: function () {
        this._on(this.widget(), {
          focusin: function (event) {
            this._makeFocusTarget();
            this._focusedElement = $(event.target);
          }
        });
      },
      _makeFocusTarget: function () {
        this._untrackInstance();
        this._trackingInstances().unshift(this);
      },
      _untrackInstance: function () {
        var instances = this._trackingInstances(), exists = $.inArray(this, instances);
        if (exists !== -1) {
          instances.splice(exists, 1);
        }
      },
      _trackingInstances: function () {
        var instances = this.document.data('ui-dialog-instances');
        if (!instances) {
          instances = [];
          this.document.data('ui-dialog-instances', instances);
        }
        return instances;
      },
      _minHeight: function () {
        var options = this.options;
        return options.height === 'auto' ? options.minHeight : Math.min(options.minHeight, options.height);
      },
      _position: function () {
        // Need to show the dialog to get the actual offset in the position plugin
        var isVisible = this.uiDialog.is(':visible');
        if (!isVisible) {
          this.uiDialog.show();
        }
        this.uiDialog.position(this.options.position);
        if (!isVisible) {
          this.uiDialog.hide();
        }
      },
      _setOptions: function (options) {
        var that = this, resize = false, resizableOptions = {};
        $.each(options, function (key, value) {
          that._setOption(key, value);
          if (key in that.sizeRelatedOptions) {
            resize = true;
          }
          if (key in that.resizableRelatedOptions) {
            resizableOptions[key] = value;
          }
        });
        if (resize) {
          this._size();
          this._position();
        }
        if (this.uiDialog.is(':data(ui-resizable)')) {
          this.uiDialog.resizable('option', resizableOptions);
        }
      },
      _setOption: function (key, value) {
        var isDraggable, isResizable, uiDialog = this.uiDialog;
        if (key === 'dialogClass') {
          uiDialog.removeClass(this.options.dialogClass).addClass(value);
        }
        if (key === 'disabled') {
          return;
        }
        this._super(key, value);
        if (key === 'appendTo') {
          this.uiDialog.appendTo(this._appendTo());
        }
        if (key === 'buttons') {
          this._createButtons();
        }
        if (key === 'closeText') {
          this.uiDialogTitlebarClose.button({ label: '' + value });
        }
        if (key === 'draggable') {
          isDraggable = uiDialog.is(':data(ui-draggable)');
          if (isDraggable && !value) {
            uiDialog.draggable('destroy');
          }
          if (!isDraggable && value) {
            this._makeDraggable();
          }
        }
        if (key === 'position') {
          this._position();
        }
        if (key === 'resizable') {
          // currently resizable, becoming non-resizable
          isResizable = uiDialog.is(':data(ui-resizable)');
          if (isResizable && !value) {
            uiDialog.resizable('destroy');
          }
          // currently resizable, changing handles
          if (isResizable && typeof value === 'string') {
            uiDialog.resizable('option', 'handles', value);
          }
          // currently non-resizable, becoming resizable
          if (!isResizable && value !== false) {
            this._makeResizable();
          }
        }
        if (key === 'title') {
          this._title(this.uiDialogTitlebar.find('.ui-dialog-title'));
        }
      },
      _size: function () {
        // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
        // divs will both have width and height set, so we need to reset them
        var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
        // Reset content sizing
        this.element.show().css({
          width: 'auto',
          minHeight: 0,
          maxHeight: 'none',
          height: 0
        });
        if (options.minWidth > options.width) {
          options.width = options.minWidth;
        }
        // reset wrapper sizing
        // determine the height of all the non-content elements
        nonContentHeight = this.uiDialog.css({
          height: 'auto',
          width: options.width
        }).outerHeight();
        minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
        maxContentHeight = typeof options.maxHeight === 'number' ? Math.max(0, options.maxHeight - nonContentHeight) : 'none';
        if (options.height === 'auto') {
          this.element.css({
            minHeight: minContentHeight,
            maxHeight: maxContentHeight,
            height: 'auto'
          });
        } else {
          this.element.height(Math.max(0, options.height - nonContentHeight));
        }
        if (this.uiDialog.is(':data(ui-resizable)')) {
          this.uiDialog.resizable('option', 'minHeight', this._minHeight());
        }
      },
      _blockFrames: function () {
        this.iframeBlocks = this.document.find('iframe').map(function () {
          var iframe = $(this);
          return $('<div>').css({
            position: 'absolute',
            width: iframe.outerWidth(),
            height: iframe.outerHeight()
          }).appendTo(iframe.parent()).offset(iframe.offset())[0];
        });
      },
      _unblockFrames: function () {
        if (this.iframeBlocks) {
          this.iframeBlocks.remove();
          delete this.iframeBlocks;
        }
      },
      _allowInteraction: function (event) {
        if ($(event.target).closest('.ui-dialog').length) {
          return true;
        }
        // TODO: Remove hack when datepicker implements
        // the .ui-front logic (#8989)
        return !!$(event.target).closest('.ui-datepicker').length;
      },
      _createOverlay: function () {
        if (!this.options.modal) {
          return;
        }
        // We use a delay in case the overlay is created from an
        // event that we're going to be cancelling (#2804)
        var isOpening = true;
        this._delay(function () {
          isOpening = false;
        });
        if (!this.document.data('ui-dialog-overlays')) {
          // Prevent use of anchors and inputs
          // Using _on() for an event handler shared across many instances is
          // safe because the dialogs stack and must be closed in reverse order
          this._on(this.document, {
            focusin: function (event) {
              if (isOpening) {
                return;
              }
              if (!this._allowInteraction(event)) {
                event.preventDefault();
                this._trackingInstances()[0]._focusTabbable();
              }
            }
          });
        }
        this.overlay = $('<div>').addClass('ui-widget-overlay ui-front').appendTo(this._appendTo());
        this._on(this.overlay, { mousedown: '_keepFocus' });
        this.document.data('ui-dialog-overlays', (this.document.data('ui-dialog-overlays') || 0) + 1);
      },
      _destroyOverlay: function () {
        if (!this.options.modal) {
          return;
        }
        if (this.overlay) {
          var overlays = this.document.data('ui-dialog-overlays') - 1;
          if (!overlays) {
            this.document.unbind('focusin').removeData('ui-dialog-overlays');
          } else {
            this.document.data('ui-dialog-overlays', overlays);
          }
          this.overlay.remove();
          this.overlay = null;
        }
      }
    });
  /*!
 * jQuery UI Droppable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */
  $.widget('ui.droppable', {
    version: '1.11.4',
    widgetEventPrefix: 'drop',
    options: {
      accept: '*',
      activeClass: false,
      addClasses: true,
      greedy: false,
      hoverClass: false,
      scope: 'default',
      tolerance: 'intersect',
      activate: null,
      deactivate: null,
      drop: null,
      out: null,
      over: null
    },
    _create: function () {
      var proportions, o = this.options, accept = o.accept;
      this.isover = false;
      this.isout = true;
      this.accept = $.isFunction(accept) ? accept : function (d) {
        return d.is(accept);
      };
      this.proportions = function () {
        if (arguments.length) {
          // Store the droppable's proportions
          proportions = arguments[0];
        } else {
          // Retrieve or derive the droppable's proportions
          return proportions ? proportions : proportions = {
            width: this.element[0].offsetWidth,
            height: this.element[0].offsetHeight
          };
        }
      };
      this._addToManager(o.scope);
      o.addClasses && this.element.addClass('ui-droppable');
    },
    _addToManager: function (scope) {
      // Add the reference and positions to the manager
      $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
      $.ui.ddmanager.droppables[scope].push(this);
    },
    _splice: function (drop) {
      var i = 0;
      for (; i < drop.length; i++) {
        if (drop[i] === this) {
          drop.splice(i, 1);
        }
      }
    },
    _destroy: function () {
      var drop = $.ui.ddmanager.droppables[this.options.scope];
      this._splice(drop);
      this.element.removeClass('ui-droppable ui-droppable-disabled');
    },
    _setOption: function (key, value) {
      if (key === 'accept') {
        this.accept = $.isFunction(value) ? value : function (d) {
          return d.is(value);
        };
      } else if (key === 'scope') {
        var drop = $.ui.ddmanager.droppables[this.options.scope];
        this._splice(drop);
        this._addToManager(value);
      }
      this._super(key, value);
    },
    _activate: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.addClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('activate', event, this.ui(draggable));
      }
    },
    _deactivate: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.removeClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('deactivate', event, this.ui(draggable));
      }
    },
    _over: function (event) {
      var draggable = $.ui.ddmanager.current;
      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.addClass(this.options.hoverClass);
        }
        this._trigger('over', event, this.ui(draggable));
      }
    },
    _out: function (event) {
      var draggable = $.ui.ddmanager.current;
      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('out', event, this.ui(draggable));
      }
    },
    _drop: function (event, custom) {
      var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return false;
      }
      this.element.find(':data(ui-droppable)').not('.ui-draggable-dragging').each(function () {
        var inst = $(this).droppable('instance');
        if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance, event)) {
          childrenIntersection = true;
          return false;
        }
      });
      if (childrenIntersection) {
        return false;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.activeClass) {
          this.element.removeClass(this.options.activeClass);
        }
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('drop', event, this.ui(draggable));
        return this.element;
      }
      return false;
    },
    ui: function (c) {
      return {
        draggable: c.currentItem || c.element,
        helper: c.helper,
        position: c.position,
        offset: c.positionAbs
      };
    }
  });
  $.ui.intersect = function () {
    function isOverAxis(x, reference, size) {
      return x >= reference && x < reference + size;
    }
    return function (draggable, droppable, toleranceMode, event) {
      if (!droppable.offset) {
        return false;
      }
      var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left, y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top, x2 = x1 + draggable.helperProportions.width, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, t = droppable.offset.top, r = l + droppable.proportions().width, b = t + droppable.proportions().height;
      switch (toleranceMode) {
      case 'fit':
        return l <= x1 && x2 <= r && t <= y1 && y2 <= b;
      case 'intersect':
        return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;
      // Top Half
      case 'pointer':
        return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);
      case 'touch':
        return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);
      default:
        return false;
      }
    };
  }();
  /*
	This manager tracks offsets of draggables and droppables
*/
  $.ui.ddmanager = {
    current: null,
    droppables: { 'default': [] },
    prepareOffsets: function (t, event) {
      var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null,
        // workaround for #2317
        list = (t.currentItem || t.element).find(':data(ui-droppable)').addBack();
      droppablesLoop:
        for (i = 0; i < m.length; i++) {
          // No disabled and non-accepted
          if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
            continue;
          }
          // Filter out elements in the current dragged item
          for (j = 0; j < list.length; j++) {
            if (list[j] === m[i].element[0]) {
              m[i].proportions().height = 0;
              continue droppablesLoop;
            }
          }
          m[i].visible = m[i].element.css('display') !== 'none';
          if (!m[i].visible) {
            continue;
          }
          // Activate the droppable if used directly from draggables
          if (type === 'mousedown') {
            m[i]._activate.call(m[i], event);
          }
          m[i].offset = m[i].element.offset();
          m[i].proportions({
            width: m[i].element[0].offsetWidth,
            height: m[i].element[0].offsetHeight
          });
        }
    },
    drop: function (draggable, event) {
      var dropped = false;
      // Create a copy of the droppables in case the list changes during the drop (#9116)
      $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {
        if (!this.options) {
          return;
        }
        if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {
          dropped = this._drop.call(this, event) || dropped;
        }
        if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
          this.isout = true;
          this.isover = false;
          this._deactivate.call(this, event);
        }
      });
      return dropped;
    },
    dragStart: function (draggable, event) {
      // Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
      draggable.element.parentsUntil('body').bind('scroll.droppable', function () {
        if (!draggable.options.refreshPositions) {
          $.ui.ddmanager.prepareOffsets(draggable, event);
        }
      });
    },
    drag: function (draggable, event) {
      // If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
      if (draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
      // Run through all droppables and check their positions based on specific tolerance options
      $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {
        if (this.options.disabled || this.greedyChild || !this.visible) {
          return;
        }
        var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance, event), c = !intersects && this.isover ? 'isout' : intersects && !this.isover ? 'isover' : null;
        if (!c) {
          return;
        }
        if (this.options.greedy) {
          // find droppable parents with same scope
          scope = this.options.scope;
          parent = this.element.parents(':data(ui-droppable)').filter(function () {
            return $(this).droppable('instance').options.scope === scope;
          });
          if (parent.length) {
            parentInstance = $(parent[0]).droppable('instance');
            parentInstance.greedyChild = c === 'isover';
          }
        }
        // we just moved into a greedy child
        if (parentInstance && c === 'isover') {
          parentInstance.isover = false;
          parentInstance.isout = true;
          parentInstance._out.call(parentInstance, event);
        }
        this[c] = true;
        this[c === 'isout' ? 'isover' : 'isout'] = false;
        this[c === 'isover' ? '_over' : '_out'].call(this, event);
        // we just moved out of a greedy child
        if (parentInstance && c === 'isout') {
          parentInstance.isout = false;
          parentInstance.isover = true;
          parentInstance._over.call(parentInstance, event);
        }
      });
    },
    dragStop: function (draggable, event) {
      draggable.element.parentsUntil('body').unbind('scroll.droppable');
      // Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
      if (!draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
    }
  };
  var droppable = $.ui.droppable;
  /*!
 * jQuery UI Effects 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */
  var dataSpace = 'ui-effects-',
    // Create a local jQuery because jQuery Color relies on it and the
    // global may not exist with AMD and a custom build (#10199)
    jQuery = $;
  $.effects = { effect: {} };
  /*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
  (function (jQuery, undefined) {
    var stepHooks = 'backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor',
      // plusequals test for += 100 -= 100
      rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
      // a set of RE's that can match strings and generate color tuples.
      stringParsers = [
        {
          re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2],
              execResult[3],
              execResult[4]
            ];
          }
        },
        {
          re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1] * 2.55,
              execResult[2] * 2.55,
              execResult[3] * 2.55,
              execResult[4]
            ];
          }
        },
        {
          re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1], 16),
              parseInt(execResult[2], 16),
              parseInt(execResult[3], 16)
            ];
          }
        },
        {
          re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1] + execResult[1], 16),
              parseInt(execResult[2] + execResult[2], 16),
              parseInt(execResult[3] + execResult[3], 16)
            ];
          }
        },
        {
          re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          space: 'hsla',
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2] / 100,
              execResult[3] / 100,
              execResult[4]
            ];
          }
        }
      ],
      // jQuery.Color( )
      color = jQuery.Color = function (color, green, blue, alpha) {
        return new jQuery.Color.fn.parse(color, green, blue, alpha);
      }, spaces = {
        rgba: {
          props: {
            red: {
              idx: 0,
              type: 'byte'
            },
            green: {
              idx: 1,
              type: 'byte'
            },
            blue: {
              idx: 2,
              type: 'byte'
            }
          }
        },
        hsla: {
          props: {
            hue: {
              idx: 0,
              type: 'degrees'
            },
            saturation: {
              idx: 1,
              type: 'percent'
            },
            lightness: {
              idx: 2,
              type: 'percent'
            }
          }
        }
      }, propTypes = {
        'byte': {
          floor: true,
          max: 255
        },
        'percent': { max: 1 },
        'degrees': {
          mod: 360,
          floor: true
        }
      }, support = color.support = {},
      // element for support tests
      supportElem = jQuery('<p>')[0],
      // colors = jQuery.Color.names
      colors,
      // local aliases of functions called often
      each = jQuery.each;
    // determine rgba support immediately
    supportElem.style.cssText = 'background-color:rgba(1,1,1,.5)';
    support.rgba = supportElem.style.backgroundColor.indexOf('rgba') > -1;
    // define cache name and alpha properties
    // for rgba and hsla spaces
    each(spaces, function (spaceName, space) {
      space.cache = '_' + spaceName;
      space.props.alpha = {
        idx: 3,
        type: 'percent',
        def: 1
      };
    });
    function clamp(value, prop, allowEmpty) {
      var type = propTypes[prop.type] || {};
      if (value == null) {
        return allowEmpty || !prop.def ? null : prop.def;
      }
      // ~~ is an short way of doing floor for positive numbers
      value = type.floor ? ~~value : parseFloat(value);
      // IE will pass in empty strings as value for alpha,
      // which will hit this case
      if (isNaN(value)) {
        return prop.def;
      }
      if (type.mod) {
        // we add mod before modding to make sure that negatives values
        // get converted properly: -10 -> 350
        return (value + type.mod) % type.mod;
      }
      // for now all property types without mod have min and max
      return 0 > value ? 0 : type.max < value ? type.max : value;
    }
    function stringParse(string) {
      var inst = color(), rgba = inst._rgba = [];
      string = string.toLowerCase();
      each(stringParsers, function (i, parser) {
        var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || 'rgba';
        if (values) {
          parsed = inst[spaceName](values);
          // if this was an rgba parse the assignment might happen twice
          // oh well....
          inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
          rgba = inst._rgba = parsed._rgba;
          // exit each( stringParsers ) here because we matched
          return false;
        }
      });
      // Found a stringParser that handled it
      if (rgba.length) {
        // if this came from a parsed string, force "transparent" when alpha is 0
        // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
        if (rgba.join() === '0,0,0,0') {
          jQuery.extend(rgba, colors.transparent);
        }
        return inst;
      }
      // named colors
      return colors[string];
    }
    color.fn = jQuery.extend(color.prototype, {
      parse: function (red, green, blue, alpha) {
        if (red === undefined) {
          this._rgba = [
            null,
            null,
            null,
            null
          ];
          return this;
        }
        if (red.jquery || red.nodeType) {
          red = jQuery(red).css(green);
          green = undefined;
        }
        var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
        // more than 1 argument specified - assume ( red, green, blue, alpha )
        if (green !== undefined) {
          red = [
            red,
            green,
            blue,
            alpha
          ];
          type = 'array';
        }
        if (type === 'string') {
          return this.parse(stringParse(red) || colors._default);
        }
        if (type === 'array') {
          each(spaces.rgba.props, function (key, prop) {
            rgba[prop.idx] = clamp(red[prop.idx], prop);
          });
          return this;
        }
        if (type === 'object') {
          if (red instanceof color) {
            each(spaces, function (spaceName, space) {
              if (red[space.cache]) {
                inst[space.cache] = red[space.cache].slice();
              }
            });
          } else {
            each(spaces, function (spaceName, space) {
              var cache = space.cache;
              each(space.props, function (key, prop) {
                // if the cache doesn't exist, and we know how to convert
                if (!inst[cache] && space.to) {
                  // if the value was null, we don't need to copy it
                  // if the key was alpha, we don't need to copy it either
                  if (key === 'alpha' || red[key] == null) {
                    return;
                  }
                  inst[cache] = space.to(inst._rgba);
                }
                // this is the only case where we allow nulls for ALL properties.
                // call clamp with alwaysAllowEmpty
                inst[cache][prop.idx] = clamp(red[key], prop, true);
              });
              // everything defined but alpha?
              if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                // use the default of 1
                inst[cache][3] = 1;
                if (space.from) {
                  inst._rgba = space.from(inst[cache]);
                }
              }
            });
          }
          return this;
        }
      },
      is: function (compare) {
        var is = color(compare), same = true, inst = this;
        each(spaces, function (_, space) {
          var localCache, isCache = is[space.cache];
          if (isCache) {
            localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
            each(space.props, function (_, prop) {
              if (isCache[prop.idx] != null) {
                same = isCache[prop.idx] === localCache[prop.idx];
                return same;
              }
            });
          }
          return same;
        });
        return same;
      },
      _space: function () {
        var used = [], inst = this;
        each(spaces, function (spaceName, space) {
          if (inst[space.cache]) {
            used.push(spaceName);
          }
        });
        return used.pop();
      },
      transition: function (other, distance) {
        var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color('transparent') : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
        end = end[space.cache];
        each(space.props, function (key, prop) {
          var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
          // if null, don't override start value
          if (endValue === null) {
            return;
          }
          // if null - use end
          if (startValue === null) {
            result[index] = endValue;
          } else {
            if (type.mod) {
              if (endValue - startValue > type.mod / 2) {
                startValue += type.mod;
              } else if (startValue - endValue > type.mod / 2) {
                startValue -= type.mod;
              }
            }
            result[index] = clamp((endValue - startValue) * distance + startValue, prop);
          }
        });
        return this[spaceName](result);
      },
      blend: function (opaque) {
        // if we are already opaque - return ourself
        if (this._rgba[3] === 1) {
          return this;
        }
        var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
        return color(jQuery.map(rgb, function (v, i) {
          return (1 - a) * blend[i] + a * v;
        }));
      },
      toRgbaString: function () {
        var prefix = 'rgba(', rgba = jQuery.map(this._rgba, function (v, i) {
            return v == null ? i > 2 ? 1 : 0 : v;
          });
        if (rgba[3] === 1) {
          rgba.pop();
          prefix = 'rgb(';
        }
        return prefix + rgba.join() + ')';
      },
      toHslaString: function () {
        var prefix = 'hsla(', hsla = jQuery.map(this.hsla(), function (v, i) {
            if (v == null) {
              v = i > 2 ? 1 : 0;
            }
            // catch 1 and 2
            if (i && i < 3) {
              v = Math.round(v * 100) + '%';
            }
            return v;
          });
        if (hsla[3] === 1) {
          hsla.pop();
          prefix = 'hsl(';
        }
        return prefix + hsla.join() + ')';
      },
      toHexString: function (includeAlpha) {
        var rgba = this._rgba.slice(), alpha = rgba.pop();
        if (includeAlpha) {
          rgba.push(~~(alpha * 255));
        }
        return '#' + jQuery.map(rgba, function (v) {
          // default to 0 when nulls exist
          v = (v || 0).toString(16);
          return v.length === 1 ? '0' + v : v;
        }).join('');
      },
      toString: function () {
        return this._rgba[3] === 0 ? 'transparent' : this.toRgbaString();
      }
    });
    color.fn.parse.prototype = color.fn;
    // hsla conversions adapted from:
    // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
    function hue2rgb(p, q, h) {
      h = (h + 1) % 1;
      if (h * 6 < 1) {
        return p + (q - p) * h * 6;
      }
      if (h * 2 < 1) {
        return q;
      }
      if (h * 3 < 2) {
        return p + (q - p) * (2 / 3 - h) * 6;
      }
      return p;
    }
    spaces.hsla.to = function (rgba) {
      if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
        return [
          null,
          null,
          null,
          rgba[3]
        ];
      }
      var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * 0.5, h, s;
      if (min === max) {
        h = 0;
      } else if (r === max) {
        h = 60 * (g - b) / diff + 360;
      } else if (g === max) {
        h = 60 * (b - r) / diff + 120;
      } else {
        h = 60 * (r - g) / diff + 240;
      }
      // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
      // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
      if (diff === 0) {
        s = 0;
      } else if (l <= 0.5) {
        s = diff / add;
      } else {
        s = diff / (2 - add);
      }
      return [
        Math.round(h) % 360,
        s,
        l,
        a == null ? 1 : a
      ];
    };
    spaces.hsla.from = function (hsla) {
      if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
        return [
          null,
          null,
          null,
          hsla[3]
        ];
      }
      var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
      return [
        Math.round(hue2rgb(p, q, h + 1 / 3) * 255),
        Math.round(hue2rgb(p, q, h) * 255),
        Math.round(hue2rgb(p, q, h - 1 / 3) * 255),
        a
      ];
    };
    each(spaces, function (spaceName, space) {
      var props = space.props, cache = space.cache, to = space.to, from = space.from;
      // makes rgba() and hsla()
      color.fn[spaceName] = function (value) {
        // generate a cache for this space if it doesn't exist
        if (to && !this[cache]) {
          this[cache] = to(this._rgba);
        }
        if (value === undefined) {
          return this[cache].slice();
        }
        var ret, type = jQuery.type(value), arr = type === 'array' || type === 'object' ? value : arguments, local = this[cache].slice();
        each(props, function (key, prop) {
          var val = arr[type === 'object' ? key : prop.idx];
          if (val == null) {
            val = local[prop.idx];
          }
          local[prop.idx] = clamp(val, prop);
        });
        if (from) {
          ret = color(from(local));
          ret[cache] = local;
          return ret;
        } else {
          return color(local);
        }
      };
      // makes red() green() blue() alpha() hue() saturation() lightness()
      each(props, function (key, prop) {
        // alpha is included in more than one space
        if (color.fn[key]) {
          return;
        }
        color.fn[key] = function (value) {
          var vtype = jQuery.type(value), fn = key === 'alpha' ? this._hsla ? 'hsla' : 'rgba' : spaceName, local = this[fn](), cur = local[prop.idx], match;
          if (vtype === 'undefined') {
            return cur;
          }
          if (vtype === 'function') {
            value = value.call(this, cur);
            vtype = jQuery.type(value);
          }
          if (value == null && prop.empty) {
            return this;
          }
          if (vtype === 'string') {
            match = rplusequals.exec(value);
            if (match) {
              value = cur + parseFloat(match[2]) * (match[1] === '+' ? 1 : -1);
            }
          }
          local[prop.idx] = value;
          return this[fn](local);
        };
      });
    });
    // add cssHook and .fx.step function for each named hook.
    // accept a space separated string of properties
    color.hook = function (hook) {
      var hooks = hook.split(' ');
      each(hooks, function (i, hook) {
        jQuery.cssHooks[hook] = {
          set: function (elem, value) {
            var parsed, curElem, backgroundColor = '';
            if (value !== 'transparent' && (jQuery.type(value) !== 'string' || (parsed = stringParse(value)))) {
              value = color(parsed || value);
              if (!support.rgba && value._rgba[3] !== 1) {
                curElem = hook === 'backgroundColor' ? elem.parentNode : elem;
                while ((backgroundColor === '' || backgroundColor === 'transparent') && curElem && curElem.style) {
                  try {
                    backgroundColor = jQuery.css(curElem, 'backgroundColor');
                    curElem = curElem.parentNode;
                  } catch (e) {
                  }
                }
                value = value.blend(backgroundColor && backgroundColor !== 'transparent' ? backgroundColor : '_default');
              }
              value = value.toRgbaString();
            }
            try {
              elem.style[hook] = value;
            } catch (e) {
            }
          }
        };
        jQuery.fx.step[hook] = function (fx) {
          if (!fx.colorInit) {
            fx.start = color(fx.elem, hook);
            fx.end = color(fx.end);
            fx.colorInit = true;
          }
          jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
        };
      });
    };
    color.hook(stepHooks);
    jQuery.cssHooks.borderColor = {
      expand: function (value) {
        var expanded = {};
        each([
          'Top',
          'Right',
          'Bottom',
          'Left'
        ], function (i, part) {
          expanded['border' + part + 'Color'] = value;
        });
        return expanded;
      }
    };
    // Basic color names only.
    // Usage of any of the other color names requires adding yourself or including
    // jquery.color.svg-names.js.
    colors = jQuery.Color.names = {
      aqua: '#00ffff',
      black: '#000000',
      blue: '#0000ff',
      fuchsia: '#ff00ff',
      gray: '#808080',
      green: '#008000',
      lime: '#00ff00',
      maroon: '#800000',
      navy: '#000080',
      olive: '#808000',
      purple: '#800080',
      red: '#ff0000',
      silver: '#c0c0c0',
      teal: '#008080',
      white: '#ffffff',
      yellow: '#ffff00',
      transparent: [
        null,
        null,
        null,
        0
      ],
      _default: '#ffffff'
    };
  }(jQuery));
  /******************************************************************************/
  /****************************** CLASS ANIMATIONS ******************************/
  /******************************************************************************/
  (function () {
    var classAnimationActions = [
        'add',
        'remove',
        'toggle'
      ], shorthandStyles = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1
      };
    $.each([
      'borderLeftStyle',
      'borderRightStyle',
      'borderBottomStyle',
      'borderTopStyle'
    ], function (_, prop) {
      $.fx.step[prop] = function (fx) {
        if (fx.end !== 'none' && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
          jQuery.style(fx.elem, prop, fx.end);
          fx.setAttr = true;
        }
      };
    });
    function getElementStyles(elem) {
      var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
      if (style && style.length && style[0] && style[style[0]]) {
        len = style.length;
        while (len--) {
          key = style[len];
          if (typeof style[key] === 'string') {
            styles[$.camelCase(key)] = style[key];
          }
        }  // support: Opera, IE <9
      } else {
        for (key in style) {
          if (typeof style[key] === 'string') {
            styles[key] = style[key];
          }
        }
      }
      return styles;
    }
    function styleDifference(oldStyle, newStyle) {
      var diff = {}, name, value;
      for (name in newStyle) {
        value = newStyle[name];
        if (oldStyle[name] !== value) {
          if (!shorthandStyles[name]) {
            if ($.fx.step[name] || !isNaN(parseFloat(value))) {
              diff[name] = value;
            }
          }
        }
      }
      return diff;
    }
    // support: jQuery <1.8
    if (!$.fn.addBack) {
      $.fn.addBack = function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    }
    $.effects.animateClass = function (value, duration, easing, callback) {
      var o = $.speed(duration, easing, callback);
      return this.queue(function () {
        var animated = $(this), baseClass = animated.attr('class') || '', applyClassChange, allAnimations = o.children ? animated.find('*').addBack() : animated;
        // map the animated objects to store the original styles.
        allAnimations = allAnimations.map(function () {
          var el = $(this);
          return {
            el: el,
            start: getElementStyles(this)
          };
        });
        // apply class change
        applyClassChange = function () {
          $.each(classAnimationActions, function (i, action) {
            if (value[action]) {
              animated[action + 'Class'](value[action]);
            }
          });
        };
        applyClassChange();
        // map all animated objects again - calculate new styles and diff
        allAnimations = allAnimations.map(function () {
          this.end = getElementStyles(this.el[0]);
          this.diff = styleDifference(this.start, this.end);
          return this;
        });
        // apply original class
        animated.attr('class', baseClass);
        // map all animated objects again - this time collecting a promise
        allAnimations = allAnimations.map(function () {
          var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
              queue: false,
              complete: function () {
                dfd.resolve(styleInfo);
              }
            });
          this.el.animate(this.diff, opts);
          return dfd.promise();
        });
        // once all animations have completed:
        $.when.apply($, allAnimations.get()).done(function () {
          // set the final class
          applyClassChange();
          // for each animated element,
          // clear all css properties that were animated
          $.each(arguments, function () {
            var el = this.el;
            $.each(this.diff, function (key) {
              el.css(key, '');
            });
          });
          // this is guarnteed to be there if you use jQuery.speed()
          // it also handles dequeuing the next anim...
          o.complete.call(animated[0]);
        });
      });
    };
    $.fn.extend({
      addClass: function (orig) {
        return function (classNames, speed, easing, callback) {
          return speed ? $.effects.animateClass.call(this, { add: classNames }, speed, easing, callback) : orig.apply(this, arguments);
        };
      }($.fn.addClass),
      removeClass: function (orig) {
        return function (classNames, speed, easing, callback) {
          return arguments.length > 1 ? $.effects.animateClass.call(this, { remove: classNames }, speed, easing, callback) : orig.apply(this, arguments);
        };
      }($.fn.removeClass),
      toggleClass: function (orig) {
        return function (classNames, force, speed, easing, callback) {
          if (typeof force === 'boolean' || force === undefined) {
            if (!speed) {
              // without speed parameter
              return orig.apply(this, arguments);
            } else {
              return $.effects.animateClass.call(this, force ? { add: classNames } : { remove: classNames }, speed, easing, callback);
            }
          } else {
            // without force parameter
            return $.effects.animateClass.call(this, { toggle: classNames }, force, speed, easing);
          }
        };
      }($.fn.toggleClass),
      switchClass: function (remove, add, speed, easing, callback) {
        return $.effects.animateClass.call(this, {
          add: add,
          remove: remove
        }, speed, easing, callback);
      }
    });
  }());
  /******************************************************************************/
  /*********************************** EFFECTS **********************************/
  /******************************************************************************/
  (function () {
    $.extend($.effects, {
      version: '1.11.4',
      save: function (element, set) {
        for (var i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            element.data(dataSpace + set[i], element[0].style[set[i]]);
          }
        }
      },
      restore: function (element, set) {
        var val, i;
        for (i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            val = element.data(dataSpace + set[i]);
            // support: jQuery 1.6.2
            // http://bugs.jquery.com/ticket/9917
            // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
            // We can't differentiate between "" and 0 here, so we just assume
            // empty string since it's likely to be a more common value...
            if (val === undefined) {
              val = '';
            }
            element.css(set[i], val);
          }
        }
      },
      setMode: function (el, mode) {
        if (mode === 'toggle') {
          mode = el.is(':hidden') ? 'show' : 'hide';
        }
        return mode;
      },
      getBaseline: function (origin, original) {
        var y, x;
        switch (origin[0]) {
        case 'top':
          y = 0;
          break;
        case 'middle':
          y = 0.5;
          break;
        case 'bottom':
          y = 1;
          break;
        default:
          y = origin[0] / original.height;
        }
        switch (origin[1]) {
        case 'left':
          x = 0;
          break;
        case 'center':
          x = 0.5;
          break;
        case 'right':
          x = 1;
          break;
        default:
          x = origin[1] / original.width;
        }
        return {
          x: x,
          y: y
        };
      },
      createWrapper: function (element) {
        // if the element is already wrapped, return it
        if (element.parent().is('.ui-effects-wrapper')) {
          return element.parent();
        }
        // wrap the element
        var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            'float': element.css('float')
          }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({
            fontSize: '100%',
            background: 'transparent',
            border: 'none',
            margin: 0,
            padding: 0
          }),
          // Store the size in case width/height are defined in % - Fixes #5245
          size = {
            width: element.width(),
            height: element.height()
          }, active = document.activeElement;
        // support: Firefox
        // Firefox incorrectly exposes anonymous content
        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
        try {
          active.id;
        } catch (e) {
          active = document.body;
        }
        element.wrap(wrapper);
        // Fixes #7595 - Elements lose focus when wrapped.
        if (element[0] === active || $.contains(element[0], active)) {
          $(active).focus();
        }
        wrapper = element.parent();
        //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
        // transfer positioning properties to the wrapper
        if (element.css('position') === 'static') {
          wrapper.css({ position: 'relative' });
          element.css({ position: 'relative' });
        } else {
          $.extend(props, {
            position: element.css('position'),
            zIndex: element.css('z-index')
          });
          $.each([
            'top',
            'left',
            'bottom',
            'right'
          ], function (i, pos) {
            props[pos] = element.css(pos);
            if (isNaN(parseInt(props[pos], 10))) {
              props[pos] = 'auto';
            }
          });
          element.css({
            position: 'relative',
            top: 0,
            left: 0,
            right: 'auto',
            bottom: 'auto'
          });
        }
        element.css(size);
        return wrapper.css(props).show();
      },
      removeWrapper: function (element) {
        var active = document.activeElement;
        if (element.parent().is('.ui-effects-wrapper')) {
          element.parent().replaceWith(element);
          // Fixes #7595 - Elements lose focus when wrapped.
          if (element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
          }
        }
        return element;
      },
      setTransition: function (element, list, factor, value) {
        value = value || {};
        $.each(list, function (i, x) {
          var unit = element.cssUnit(x);
          if (unit[0] > 0) {
            value[x] = unit[0] * factor + unit[1];
          }
        });
        return value;
      }
    });
    // return an effect options object for the given parameters:
    function _normalizeArguments(effect, options, speed, callback) {
      // allow passing all options as the first parameter
      if ($.isPlainObject(effect)) {
        options = effect;
        effect = effect.effect;
      }
      // convert to an object
      effect = { effect: effect };
      // catch (effect, null, ...)
      if (options == null) {
        options = {};
      }
      // catch (effect, callback)
      if ($.isFunction(options)) {
        callback = options;
        speed = null;
        options = {};
      }
      // catch (effect, speed, ?)
      if (typeof options === 'number' || $.fx.speeds[options]) {
        callback = speed;
        speed = options;
        options = {};
      }
      // catch (effect, options, callback)
      if ($.isFunction(speed)) {
        callback = speed;
        speed = null;
      }
      // add options to effect
      if (options) {
        $.extend(effect, options);
      }
      speed = speed || options.duration;
      effect.duration = $.fx.off ? 0 : typeof speed === 'number' ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
      effect.complete = callback || options.complete;
      return effect;
    }
    function standardAnimationOption(option) {
      // Valid standard speeds (nothing, number, named speed)
      if (!option || typeof option === 'number' || $.fx.speeds[option]) {
        return true;
      }
      // Invalid strings - treat as "normal" speed
      if (typeof option === 'string' && !$.effects.effect[option]) {
        return true;
      }
      // Complete callback
      if ($.isFunction(option)) {
        return true;
      }
      // Options hash (but not naming an effect)
      if (typeof option === 'object' && !option.effect) {
        return true;
      }
      // Didn't match any standard API
      return false;
    }
    $.fn.extend({
      effect: function () {
        var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
        if ($.fx.off || !effectMethod) {
          // delegate to the original method (e.g., .show()) if possible
          if (mode) {
            return this[mode](args.duration, args.complete);
          } else {
            return this.each(function () {
              if (args.complete) {
                args.complete.call(this);
              }
            });
          }
        }
        function run(next) {
          var elem = $(this), complete = args.complete, mode = args.mode;
          function done() {
            if ($.isFunction(complete)) {
              complete.call(elem[0]);
            }
            if ($.isFunction(next)) {
              next();
            }
          }
          // If the element already has the correct final state, delegate to
          // the core methods so the internal tracking of "olddisplay" works.
          if (elem.is(':hidden') ? mode === 'hide' : mode === 'show') {
            elem[mode]();
            done();
          } else {
            effectMethod.call(elem[0], args, done);
          }
        }
        return queue === false ? this.each(run) : this.queue(queue || 'fx', run);
      },
      show: function (orig) {
        return function (option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'show';
            return this.effect.call(this, args);
          }
        };
      }($.fn.show),
      hide: function (orig) {
        return function (option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'hide';
            return this.effect.call(this, args);
          }
        };
      }($.fn.hide),
      toggle: function (orig) {
        return function (option) {
          if (standardAnimationOption(option) || typeof option === 'boolean') {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'toggle';
            return this.effect.call(this, args);
          }
        };
      }($.fn.toggle),
      cssUnit: function (key) {
        var style = this.css(key), val = [];
        $.each([
          'em',
          'px',
          '%',
          'pt'
        ], function (i, unit) {
          if (style.indexOf(unit) > 0) {
            val = [
              parseFloat(style),
              unit
            ];
          }
        });
        return val;
      }
    });
  }());
  /******************************************************************************/
  /*********************************** EASING ***********************************/
  /******************************************************************************/
  (function () {
    // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
    var baseEasings = {};
    $.each([
      'Quad',
      'Cubic',
      'Quart',
      'Quint',
      'Expo'
    ], function (i, name) {
      baseEasings[name] = function (p) {
        return Math.pow(p, i + 2);
      };
    });
    $.extend(baseEasings, {
      Sine: function (p) {
        return 1 - Math.cos(p * Math.PI / 2);
      },
      Circ: function (p) {
        return 1 - Math.sqrt(1 - p * p);
      },
      Elastic: function (p) {
        return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
      },
      Back: function (p) {
        return p * p * (3 * p - 2);
      },
      Bounce: function (p) {
        var pow2, bounce = 4;
        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {
        }
        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
      }
    });
    $.each(baseEasings, function (name, easeIn) {
      $.easing['easeIn' + name] = easeIn;
      $.easing['easeOut' + name] = function (p) {
        return 1 - easeIn(1 - p);
      };
      $.easing['easeInOut' + name] = function (p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
      };
    });
  }());
  var effect = $.effects;
  /*!
 * jQuery UI Effects Blind 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/blind-effect/
 */
  var effectBlind = $.effects.effect.blind = function (o, done) {
      // Create element
      var el = $(this), rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/, props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'height',
          'width'
        ], mode = $.effects.setMode(el, o.mode || 'hide'), direction = o.direction || 'up', vertical = rvertical.test(direction), ref = vertical ? 'height' : 'width', ref2 = vertical ? 'top' : 'left', motion = rpositivemotion.test(direction), animation = {}, show = mode === 'show', wrapper, distance, margin;
      // if already wrapped, the wrapper's properties are my property. #6245
      if (el.parent().is('.ui-effects-wrapper')) {
        $.effects.save(el.parent(), props);
      } else {
        $.effects.save(el, props);
      }
      el.show();
      wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
      distance = wrapper[ref]();
      margin = parseFloat(wrapper.css(ref2)) || 0;
      animation[ref] = show ? distance : 0;
      if (!motion) {
        el.css(vertical ? 'bottom' : 'right', 0).css(vertical ? 'top' : 'left', 'auto').css({ position: 'absolute' });
        animation[ref2] = show ? margin : distance + margin;
      }
      // start at 0 if we are showing
      if (show) {
        wrapper.css(ref, 0);
        if (!motion) {
          wrapper.css(ref2, margin + distance);
        }
      }
      // Animate
      wrapper.animate(animation, {
        duration: o.duration,
        easing: o.easing,
        queue: false,
        complete: function () {
          if (mode === 'hide') {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
  /*!
 * jQuery UI Effects Bounce 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/bounce-effect/
 */
  var effectBounce = $.effects.effect.bounce = function (o, done) {
      var el = $(this), props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'height',
          'width'
        ],
        // defaults:
        mode = $.effects.setMode(el, o.mode || 'effect'), hide = mode === 'hide', show = mode === 'show', direction = o.direction || 'up', distance = o.distance, times = o.times || 5,
        // number of internal animations
        anims = times * 2 + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing,
        // utility:
        ref = direction === 'up' || direction === 'down' ? 'top' : 'left', motion = direction === 'up' || direction === 'left', i, upAnim, downAnim,
        // we will need to re-assemble the queue to stack our animations in place
        queue = el.queue(), queuelen = queue.length;
      // Avoid touching opacity to prevent clearType and PNG issues in IE
      if (show || hide) {
        props.push('opacity');
      }
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      // Create Wrapper
      // default distance for the BIGGEST bounce is the outer Distance / 3
      if (!distance) {
        distance = el[ref === 'top' ? 'outerHeight' : 'outerWidth']() / 3;
      }
      if (show) {
        downAnim = { opacity: 1 };
        downAnim[ref] = 0;
        // if we are showing, force opacity 0 and set the initial position
        // then do the "first" animation
        el.css('opacity', 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
      }
      // start at the smallest distance if we are hiding
      if (hide) {
        distance = distance / Math.pow(2, times - 1);
      }
      downAnim = {};
      downAnim[ref] = 0;
      // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
      for (i = 0; i < times; i++) {
        upAnim = {};
        upAnim[ref] = (motion ? '-=' : '+=') + distance;
        el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
        distance = hide ? distance * 2 : distance / 2;
      }
      // Last Bounce when Hiding
      if (hide) {
        upAnim = { opacity: 0 };
        upAnim[ref] = (motion ? '-=' : '+=') + distance;
        el.animate(upAnim, speed, easing);
      }
      el.queue(function () {
        if (hide) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });
      // inject all the animations we just queued to be first in line (after "inprogress")
      if (queuelen > 1) {
        queue.splice.apply(queue, [
          1,
          0
        ].concat(queue.splice(queuelen, anims + 1)));
      }
      el.dequeue();
    };
  /*!
 * jQuery UI Effects Clip 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/clip-effect/
 */
  var effectClip = $.effects.effect.clip = function (o, done) {
      // Create element
      var el = $(this), props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'height',
          'width'
        ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', direction = o.direction || 'vertical', vert = direction === 'vertical', size = vert ? 'height' : 'width', position = vert ? 'top' : 'left', animation = {}, wrapper, animate, distance;
      // Save & Show
      $.effects.save(el, props);
      el.show();
      // Create Wrapper
      wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
      animate = el[0].tagName === 'IMG' ? wrapper : el;
      distance = animate[size]();
      // Shift
      if (show) {
        animate.css(size, 0);
        animate.css(position, distance / 2);
      }
      // Create Animation Object:
      animation[size] = show ? distance : 0;
      animation[position] = show ? 0 : distance / 2;
      // Animate
      animate.animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function () {
          if (!show) {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
  /*!
 * jQuery UI Effects Drop 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/drop-effect/
 */
  var effectDrop = $.effects.effect.drop = function (o, done) {
      var el = $(this), props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'opacity',
          'height',
          'width'
        ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', direction = o.direction || 'left', ref = direction === 'up' || direction === 'down' ? 'top' : 'left', motion = direction === 'up' || direction === 'left' ? 'pos' : 'neg', animation = { opacity: show ? 1 : 0 }, distance;
      // Adjust
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true) / 2;
      if (show) {
        el.css('opacity', 0).css(ref, motion === 'pos' ? -distance : distance);
      }
      // Animation
      animation[ref] = (show ? motion === 'pos' ? '+=' : '-=' : motion === 'pos' ? '-=' : '+=') + distance;
      // Animate
      el.animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function () {
          if (mode === 'hide') {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
  /*!
 * jQuery UI Effects Explode 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/explode-effect/
 */
  var effectExplode = $.effects.effect.explode = function (o, done) {
      var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show',
        // show and then visibility:hidden the element before calculating offset
        offset = el.show().css('visibility', 'hidden').offset(),
        // width and height of a piece
        width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [],
        // loop
        i, j, left, top, mx, my;
      // children animate complete:
      function childComplete() {
        pieces.push(this);
        if (pieces.length === rows * cells) {
          animComplete();
        }
      }
      // clone the element for each row and cell.
      for (i = 0; i < rows; i++) {
        // ===>
        top = offset.top + i * height;
        my = i - (rows - 1) / 2;
        for (j = 0; j < cells; j++) {
          // |||
          left = offset.left + j * width;
          mx = j - (cells - 1) / 2;
          // Create a clone of the now hidden main element that will be absolute positioned
          // within a wrapper div off the -left and -top equal to size of our pieces
          el.clone().appendTo('body').wrap('<div></div>').css({
            position: 'absolute',
            visibility: 'visible',
            left: -j * width,
            top: -i * height
          }).parent().addClass('ui-effects-explode').css({
            position: 'absolute',
            overflow: 'hidden',
            width: width,
            height: height,
            left: left + (show ? mx * width : 0),
            top: top + (show ? my * height : 0),
            opacity: show ? 0 : 1
          }).animate({
            left: left + (show ? 0 : mx * width),
            top: top + (show ? 0 : my * height),
            opacity: show ? 1 : 0
          }, o.duration || 500, o.easing, childComplete);
        }
      }
      function animComplete() {
        el.css({ visibility: 'visible' });
        $(pieces).remove();
        if (!show) {
          el.hide();
        }
        done();
      }
    };
  /*!
 * jQuery UI Effects Fade 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fade-effect/
 */
  var effectFade = $.effects.effect.fade = function (o, done) {
      var el = $(this), mode = $.effects.setMode(el, o.mode || 'toggle');
      el.animate({ opacity: mode }, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: done
      });
    };
  /*!
 * jQuery UI Effects Fold 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fold-effect/
 */
  var effectFold = $.effects.effect.fold = function (o, done) {
      // Create element
      var el = $(this), props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'height',
          'width'
        ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', hide = mode === 'hide', size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [
          'width',
          'height'
        ] : [
          'height',
          'width'
        ], duration = o.duration / 2, wrapper, distance, animation1 = {}, animation2 = {};
      $.effects.save(el, props);
      el.show();
      // Create Wrapper
      wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
      distance = widthFirst ? [
        wrapper.width(),
        wrapper.height()
      ] : [
        wrapper.height(),
        wrapper.width()
      ];
      if (percent) {
        size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
      }
      if (show) {
        wrapper.css(horizFirst ? {
          height: 0,
          width: size
        } : {
          height: size,
          width: 0
        });
      }
      // Animation
      animation1[ref[0]] = show ? distance[0] : size;
      animation2[ref[1]] = show ? distance[1] : 0;
      // Animate
      wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function () {
        if (hide) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });
    };
  /*!
 * jQuery UI Effects Highlight 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/highlight-effect/
 */
  var effectHighlight = $.effects.effect.highlight = function (o, done) {
      var elem = $(this), props = [
          'backgroundImage',
          'backgroundColor',
          'opacity'
        ], mode = $.effects.setMode(elem, o.mode || 'show'), animation = { backgroundColor: elem.css('backgroundColor') };
      if (mode === 'hide') {
        animation.opacity = 0;
      }
      $.effects.save(elem, props);
      elem.show().css({
        backgroundImage: 'none',
        backgroundColor: o.color || '#ffff99'
      }).animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function () {
          if (mode === 'hide') {
            elem.hide();
          }
          $.effects.restore(elem, props);
          done();
        }
      });
    };
  /*!
 * jQuery UI Effects Size 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/size-effect/
 */
  var effectSize = $.effects.effect.size = function (o, done) {
      // Create element
      var original, baseline, factor, el = $(this), props0 = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'width',
          'height',
          'overflow',
          'opacity'
        ],
        // Always restore
        props1 = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'overflow',
          'opacity'
        ],
        // Copy for children
        props2 = [
          'width',
          'height',
          'overflow'
        ], cProps = ['fontSize'], vProps = [
          'borderTopWidth',
          'borderBottomWidth',
          'paddingTop',
          'paddingBottom'
        ], hProps = [
          'borderLeftWidth',
          'borderRightWidth',
          'paddingLeft',
          'paddingRight'
        ],
        // Set options
        mode = $.effects.setMode(el, o.mode || 'effect'), restore = o.restore || mode !== 'effect', scale = o.scale || 'both', origin = o.origin || [
          'middle',
          'center'
        ], position = el.css('position'), props = restore ? props0 : props1, zero = {
          height: 0,
          width: 0,
          outerHeight: 0,
          outerWidth: 0
        };
      if (mode === 'show') {
        el.show();
      }
      original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth()
      };
      if (o.mode === 'toggle' && mode === 'show') {
        el.from = o.to || zero;
        el.to = o.from || original;
      } else {
        el.from = o.from || (mode === 'show' ? zero : original);
        el.to = o.to || (mode === 'hide' ? zero : original);
      }
      // Set scaling factor
      factor = {
        from: {
          y: el.from.height / original.height,
          x: el.from.width / original.width
        },
        to: {
          y: el.to.height / original.height,
          x: el.to.width / original.width
        }
      };
      // Scale the css box
      if (scale === 'box' || scale === 'both') {
        // Vertical props scaling
        if (factor.from.y !== factor.to.y) {
          props = props.concat(vProps);
          el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
          el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
        }
        // Horizontal props scaling
        if (factor.from.x !== factor.to.x) {
          props = props.concat(hProps);
          el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
          el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
        }
      }
      // Scale the content
      if (scale === 'content' || scale === 'both') {
        // Vertical props scaling
        if (factor.from.y !== factor.to.y) {
          props = props.concat(cProps).concat(props2);
          el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
          el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
        }
      }
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      el.css('overflow', 'hidden').css(el.from);
      // Adjust
      if (origin) {
        // Calculate baseline shifts
        baseline = $.effects.getBaseline(origin, original);
        el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
        el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
        el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
        el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
      }
      el.css(el.from);
      // set top & left
      // Animate
      if (scale === 'content' || scale === 'both') {
        // Scale the children
        // Add margins/font-size
        vProps = vProps.concat([
          'marginTop',
          'marginBottom'
        ]).concat(cProps);
        hProps = hProps.concat([
          'marginLeft',
          'marginRight'
        ]);
        props2 = props0.concat(vProps).concat(hProps);
        el.find('*[width]').each(function () {
          var child = $(this), c_original = {
              height: child.height(),
              width: child.width(),
              outerHeight: child.outerHeight(),
              outerWidth: child.outerWidth()
            };
          if (restore) {
            $.effects.save(child, props2);
          }
          child.from = {
            height: c_original.height * factor.from.y,
            width: c_original.width * factor.from.x,
            outerHeight: c_original.outerHeight * factor.from.y,
            outerWidth: c_original.outerWidth * factor.from.x
          };
          child.to = {
            height: c_original.height * factor.to.y,
            width: c_original.width * factor.to.x,
            outerHeight: c_original.height * factor.to.y,
            outerWidth: c_original.width * factor.to.x
          };
          // Vertical props scaling
          if (factor.from.y !== factor.to.y) {
            child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
            child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
          }
          // Horizontal props scaling
          if (factor.from.x !== factor.to.x) {
            child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
            child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
          }
          // Animate children
          child.css(child.from);
          child.animate(child.to, o.duration, o.easing, function () {
            // Restore children
            if (restore) {
              $.effects.restore(child, props2);
            }
          });
        });
      }
      // Animate
      el.animate(el.to, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function () {
          if (el.to.opacity === 0) {
            el.css('opacity', el.from.opacity);
          }
          if (mode === 'hide') {
            el.hide();
          }
          $.effects.restore(el, props);
          if (!restore) {
            // we need to calculate our new positioning based on the scaling
            if (position === 'static') {
              el.css({
                position: 'relative',
                top: el.to.top,
                left: el.to.left
              });
            } else {
              $.each([
                'top',
                'left'
              ], function (idx, pos) {
                el.css(pos, function (_, str) {
                  var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                  // if original was "auto", recalculate the new value from wrapper
                  if (str === 'auto') {
                    return toRef + 'px';
                  }
                  return val + toRef + 'px';
                });
              });
            }
          }
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
  /*!
 * jQuery UI Effects Scale 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/scale-effect/
 */
  var effectScale = $.effects.effect.scale = function (o, done) {
      // Create element
      var el = $(this), options = $.extend(true, {}, o), mode = $.effects.setMode(el, o.mode || 'effect'), percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === 'hide' ? 0 : 100), direction = o.direction || 'both', origin = o.origin, original = {
          height: el.height(),
          width: el.width(),
          outerHeight: el.outerHeight(),
          outerWidth: el.outerWidth()
        }, factor = {
          y: direction !== 'horizontal' ? percent / 100 : 1,
          x: direction !== 'vertical' ? percent / 100 : 1
        };
      // We are going to pass this effect to the size effect:
      options.effect = 'size';
      options.queue = false;
      options.complete = done;
      // Set default origin and restore for show/hide
      if (mode !== 'effect') {
        options.origin = origin || [
          'middle',
          'center'
        ];
        options.restore = true;
      }
      options.from = o.from || (mode === 'show' ? {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      } : original);
      options.to = {
        height: original.height * factor.y,
        width: original.width * factor.x,
        outerHeight: original.outerHeight * factor.y,
        outerWidth: original.outerWidth * factor.x
      };
      // Fade option to support puff
      if (options.fade) {
        if (mode === 'show') {
          options.from.opacity = 0;
          options.to.opacity = 1;
        }
        if (mode === 'hide') {
          options.from.opacity = 1;
          options.to.opacity = 0;
        }
      }
      // Animate
      el.effect(options);
    };
  /*!
 * jQuery UI Effects Puff 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/puff-effect/
 */
  var effectPuff = $.effects.effect.puff = function (o, done) {
      var elem = $(this), mode = $.effects.setMode(elem, o.mode || 'hide'), hide = mode === 'hide', percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
          height: elem.height(),
          width: elem.width(),
          outerHeight: elem.outerHeight(),
          outerWidth: elem.outerWidth()
        };
      $.extend(o, {
        effect: 'scale',
        queue: false,
        fade: true,
        mode: mode,
        complete: done,
        percent: hide ? percent : 100,
        from: hide ? original : {
          height: original.height * factor,
          width: original.width * factor,
          outerHeight: original.outerHeight * factor,
          outerWidth: original.outerWidth * factor
        }
      });
      elem.effect(o);
    };
  /*!
 * jQuery UI Effects Pulsate 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/pulsate-effect/
 */
  var effectPulsate = $.effects.effect.pulsate = function (o, done) {
      var elem = $(this), mode = $.effects.setMode(elem, o.mode || 'show'), show = mode === 'show', hide = mode === 'hide', showhide = show || mode === 'hide',
        // showing or hiding leaves of the "last" animation
        anims = (o.times || 5) * 2 + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length, i;
      if (show || !elem.is(':visible')) {
        elem.css('opacity', 0).show();
        animateTo = 1;
      }
      // anims - 1 opacity "toggles"
      for (i = 1; i < anims; i++) {
        elem.animate({ opacity: animateTo }, duration, o.easing);
        animateTo = 1 - animateTo;
      }
      elem.animate({ opacity: animateTo }, duration, o.easing);
      elem.queue(function () {
        if (hide) {
          elem.hide();
        }
        done();
      });
      // We just queued up "anims" animations, we need to put them next in the queue
      if (queuelen > 1) {
        queue.splice.apply(queue, [
          1,
          0
        ].concat(queue.splice(queuelen, anims + 1)));
      }
      elem.dequeue();
    };
  /*!
 * jQuery UI Effects Shake 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/shake-effect/
 */
  var effectShake = $.effects.effect.shake = function (o, done) {
      var el = $(this), props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'height',
          'width'
        ], mode = $.effects.setMode(el, o.mode || 'effect'), direction = o.direction || 'left', distance = o.distance || 20, times = o.times || 3, anims = times * 2 + 1, speed = Math.round(o.duration / anims), ref = direction === 'up' || direction === 'down' ? 'top' : 'left', positiveMotion = direction === 'up' || direction === 'left', animation = {}, animation1 = {}, animation2 = {}, i,
        // we will need to re-assemble the queue to stack our animations in place
        queue = el.queue(), queuelen = queue.length;
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      // Animation
      animation[ref] = (positiveMotion ? '-=' : '+=') + distance;
      animation1[ref] = (positiveMotion ? '+=' : '-=') + distance * 2;
      animation2[ref] = (positiveMotion ? '-=' : '+=') + distance * 2;
      // Animate
      el.animate(animation, speed, o.easing);
      // Shakes
      for (i = 1; i < times; i++) {
        el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
      }
      el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });
      // inject all the animations we just queued to be first in line (after "inprogress")
      if (queuelen > 1) {
        queue.splice.apply(queue, [
          1,
          0
        ].concat(queue.splice(queuelen, anims + 1)));
      }
      el.dequeue();
    };
  /*!
 * jQuery UI Effects Slide 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slide-effect/
 */
  var effectSlide = $.effects.effect.slide = function (o, done) {
      // Create element
      var el = $(this), props = [
          'position',
          'top',
          'bottom',
          'left',
          'right',
          'width',
          'height'
        ], mode = $.effects.setMode(el, o.mode || 'show'), show = mode === 'show', direction = o.direction || 'left', ref = direction === 'up' || direction === 'down' ? 'top' : 'left', positiveMotion = direction === 'up' || direction === 'left', distance, animation = {};
      // Adjust
      $.effects.save(el, props);
      el.show();
      distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true);
      $.effects.createWrapper(el).css({ overflow: 'hidden' });
      if (show) {
        el.css(ref, positiveMotion ? isNaN(distance) ? '-' + distance : -distance : distance);
      }
      // Animation
      animation[ref] = (show ? positiveMotion ? '+=' : '-=' : positiveMotion ? '-=' : '+=') + distance;
      // Animate
      el.animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function () {
          if (mode === 'hide') {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
  /*!
 * jQuery UI Effects Transfer 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/transfer-effect/
 */
  var effectTransfer = $.effects.effect.transfer = function (o, done) {
      var elem = $(this), target = $(o.to), targetFixed = target.css('position') === 'fixed', body = $('body'), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
          top: endPosition.top - fixTop,
          left: endPosition.left - fixLeft,
          height: target.innerHeight(),
          width: target.innerWidth()
        }, startPosition = elem.offset(), transfer = $('<div class=\'ui-effects-transfer\'></div>').appendTo(document.body).addClass(o.className).css({
          top: startPosition.top - fixTop,
          left: startPosition.left - fixLeft,
          height: elem.innerHeight(),
          width: elem.innerWidth(),
          position: targetFixed ? 'fixed' : 'absolute'
        }).animate(animation, o.duration, o.easing, function () {
          transfer.remove();
          done();
        });
    };
  /*!
 * jQuery UI Progressbar 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/progressbar/
 */
  var progressbar = $.widget('ui.progressbar', {
      version: '1.11.4',
      options: {
        max: 100,
        value: 0,
        change: null,
        complete: null
      },
      min: 0,
      _create: function () {
        // Constrain initial value
        this.oldValue = this.options.value = this._constrainedValue();
        this.element.addClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').attr({
          role: 'progressbar',
          'aria-valuemin': this.min
        });
        this.valueDiv = $('<div class=\'ui-progressbar-value ui-widget-header ui-corner-left\'></div>').appendTo(this.element);
        this._refreshValue();
      },
      _destroy: function () {
        this.element.removeClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow');
        this.valueDiv.remove();
      },
      value: function (newValue) {
        if (newValue === undefined) {
          return this.options.value;
        }
        this.options.value = this._constrainedValue(newValue);
        this._refreshValue();
      },
      _constrainedValue: function (newValue) {
        if (newValue === undefined) {
          newValue = this.options.value;
        }
        this.indeterminate = newValue === false;
        // sanitize value
        if (typeof newValue !== 'number') {
          newValue = 0;
        }
        return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
      },
      _setOptions: function (options) {
        // Ensure "value" option is set after other values (like max)
        var value = options.value;
        delete options.value;
        this._super(options);
        this.options.value = this._constrainedValue(value);
        this._refreshValue();
      },
      _setOption: function (key, value) {
        if (key === 'max') {
          // Don't allow a max less than min
          value = Math.max(this.min, value);
        }
        if (key === 'disabled') {
          this.element.toggleClass('ui-state-disabled', !!value).attr('aria-disabled', value);
        }
        this._super(key, value);
      },
      _percentage: function () {
        return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
      },
      _refreshValue: function () {
        var value = this.options.value, percentage = this._percentage();
        this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass('ui-corner-right', value === this.options.max).width(percentage.toFixed(0) + '%');
        this.element.toggleClass('ui-progressbar-indeterminate', this.indeterminate);
        if (this.indeterminate) {
          this.element.removeAttr('aria-valuenow');
          if (!this.overlayDiv) {
            this.overlayDiv = $('<div class=\'ui-progressbar-overlay\'></div>').appendTo(this.valueDiv);
          }
        } else {
          this.element.attr({
            'aria-valuemax': this.options.max,
            'aria-valuenow': value
          });
          if (this.overlayDiv) {
            this.overlayDiv.remove();
            this.overlayDiv = null;
          }
        }
        if (this.oldValue !== value) {
          this.oldValue = value;
          this._trigger('change');
        }
        if (value === this.options.max) {
          this._trigger('complete');
        }
      }
    });
  /*!
 * jQuery UI Selectable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectable/
 */
  var selectable = $.widget('ui.selectable', $.ui.mouse, {
      version: '1.11.4',
      options: {
        appendTo: 'body',
        autoRefresh: true,
        distance: 0,
        filter: '*',
        tolerance: 'touch',
        selected: null,
        selecting: null,
        start: null,
        stop: null,
        unselected: null,
        unselecting: null
      },
      _create: function () {
        var selectees, that = this;
        this.element.addClass('ui-selectable');
        this.dragged = false;
        // cache selectee children based on filter
        this.refresh = function () {
          selectees = $(that.options.filter, that.element[0]);
          selectees.addClass('ui-selectee');
          selectees.each(function () {
            var $this = $(this), pos = $this.offset();
            $.data(this, 'selectable-item', {
              element: this,
              $element: $this,
              left: pos.left,
              top: pos.top,
              right: pos.left + $this.outerWidth(),
              bottom: pos.top + $this.outerHeight(),
              startselected: false,
              selected: $this.hasClass('ui-selected'),
              selecting: $this.hasClass('ui-selecting'),
              unselecting: $this.hasClass('ui-unselecting')
            });
          });
        };
        this.refresh();
        this.selectees = selectees.addClass('ui-selectee');
        this._mouseInit();
        this.helper = $('<div class=\'ui-selectable-helper\'></div>');
      },
      _destroy: function () {
        this.selectees.removeClass('ui-selectee').removeData('selectable-item');
        this.element.removeClass('ui-selectable ui-selectable-disabled');
        this._mouseDestroy();
      },
      _mouseStart: function (event) {
        var that = this, options = this.options;
        this.opos = [
          event.pageX,
          event.pageY
        ];
        if (this.options.disabled) {
          return;
        }
        this.selectees = $(options.filter, this.element[0]);
        this._trigger('start', event);
        $(options.appendTo).append(this.helper);
        // position helper (lasso)
        this.helper.css({
          'left': event.pageX,
          'top': event.pageY,
          'width': 0,
          'height': 0
        });
        if (options.autoRefresh) {
          this.refresh();
        }
        this.selectees.filter('.ui-selected').each(function () {
          var selectee = $.data(this, 'selectable-item');
          selectee.startselected = true;
          if (!event.metaKey && !event.ctrlKey) {
            selectee.$element.removeClass('ui-selected');
            selectee.selected = false;
            selectee.$element.addClass('ui-unselecting');
            selectee.unselecting = true;
            // selectable UNSELECTING callback
            that._trigger('unselecting', event, { unselecting: selectee.element });
          }
        });
        $(event.target).parents().addBack().each(function () {
          var doSelect, selectee = $.data(this, 'selectable-item');
          if (selectee) {
            doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass('ui-selected');
            selectee.$element.removeClass(doSelect ? 'ui-unselecting' : 'ui-selected').addClass(doSelect ? 'ui-selecting' : 'ui-unselecting');
            selectee.unselecting = !doSelect;
            selectee.selecting = doSelect;
            selectee.selected = doSelect;
            // selectable (UN)SELECTING callback
            if (doSelect) {
              that._trigger('selecting', event, { selecting: selectee.element });
            } else {
              that._trigger('unselecting', event, { unselecting: selectee.element });
            }
            return false;
          }
        });
      },
      _mouseDrag: function (event) {
        this.dragged = true;
        if (this.options.disabled) {
          return;
        }
        var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
        if (x1 > x2) {
          tmp = x2;
          x2 = x1;
          x1 = tmp;
        }
        if (y1 > y2) {
          tmp = y2;
          y2 = y1;
          y1 = tmp;
        }
        this.helper.css({
          left: x1,
          top: y1,
          width: x2 - x1,
          height: y2 - y1
        });
        this.selectees.each(function () {
          var selectee = $.data(this, 'selectable-item'), hit = false;
          //prevent helper from being selected if appendTo: selectable
          if (!selectee || selectee.element === that.element[0]) {
            return;
          }
          if (options.tolerance === 'touch') {
            hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
          } else if (options.tolerance === 'fit') {
            hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
          }
          if (hit) {
            // SELECT
            if (selectee.selected) {
              selectee.$element.removeClass('ui-selected');
              selectee.selected = false;
            }
            if (selectee.unselecting) {
              selectee.$element.removeClass('ui-unselecting');
              selectee.unselecting = false;
            }
            if (!selectee.selecting) {
              selectee.$element.addClass('ui-selecting');
              selectee.selecting = true;
              // selectable SELECTING callback
              that._trigger('selecting', event, { selecting: selectee.element });
            }
          } else {
            // UNSELECT
            if (selectee.selecting) {
              if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                selectee.$element.removeClass('ui-selecting');
                selectee.selecting = false;
                selectee.$element.addClass('ui-selected');
                selectee.selected = true;
              } else {
                selectee.$element.removeClass('ui-selecting');
                selectee.selecting = false;
                if (selectee.startselected) {
                  selectee.$element.addClass('ui-unselecting');
                  selectee.unselecting = true;
                }
                // selectable UNSELECTING callback
                that._trigger('unselecting', event, { unselecting: selectee.element });
              }
            }
            if (selectee.selected) {
              if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                selectee.$element.removeClass('ui-selected');
                selectee.selected = false;
                selectee.$element.addClass('ui-unselecting');
                selectee.unselecting = true;
                // selectable UNSELECTING callback
                that._trigger('unselecting', event, { unselecting: selectee.element });
              }
            }
          }
        });
        return false;
      },
      _mouseStop: function (event) {
        var that = this;
        this.dragged = false;
        $('.ui-unselecting', this.element[0]).each(function () {
          var selectee = $.data(this, 'selectable-item');
          selectee.$element.removeClass('ui-unselecting');
          selectee.unselecting = false;
          selectee.startselected = false;
          that._trigger('unselected', event, { unselected: selectee.element });
        });
        $('.ui-selecting', this.element[0]).each(function () {
          var selectee = $.data(this, 'selectable-item');
          selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
          selectee.selecting = false;
          selectee.selected = true;
          selectee.startselected = true;
          that._trigger('selected', event, { selected: selectee.element });
        });
        this._trigger('stop', event);
        this.helper.remove();
        return false;
      }
    });
  /*!
 * jQuery UI Selectmenu 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectmenu
 */
  var selectmenu = $.widget('ui.selectmenu', {
      version: '1.11.4',
      defaultElement: '<select>',
      options: {
        appendTo: null,
        disabled: null,
        icons: { button: 'ui-icon-triangle-1-s' },
        position: {
          my: 'left top',
          at: 'left bottom',
          collision: 'none'
        },
        width: null,
        change: null,
        close: null,
        focus: null,
        open: null,
        select: null
      },
      _create: function () {
        var selectmenuId = this.element.uniqueId().attr('id');
        this.ids = {
          element: selectmenuId,
          button: selectmenuId + '-button',
          menu: selectmenuId + '-menu'
        };
        this._drawButton();
        this._drawMenu();
        if (this.options.disabled) {
          this.disable();
        }
      },
      _drawButton: function () {
        var that = this;
        // Associate existing label with the new button
        this.label = $('label[for=\'' + this.ids.element + '\']').attr('for', this.ids.button);
        this._on(this.label, {
          click: function (event) {
            this.button.focus();
            event.preventDefault();
          }
        });
        // Hide original select element
        this.element.hide();
        // Create button
        this.button = $('<span>', {
          'class': 'ui-selectmenu-button ui-widget ui-state-default ui-corner-all',
          tabindex: this.options.disabled ? -1 : 0,
          id: this.ids.button,
          role: 'combobox',
          'aria-expanded': 'false',
          'aria-autocomplete': 'list',
          'aria-owns': this.ids.menu,
          'aria-haspopup': 'true'
        }).insertAfter(this.element);
        $('<span>', { 'class': 'ui-icon ' + this.options.icons.button }).prependTo(this.button);
        this.buttonText = $('<span>', { 'class': 'ui-selectmenu-text' }).appendTo(this.button);
        this._setText(this.buttonText, this.element.find('option:selected').text());
        this._resizeButton();
        this._on(this.button, this._buttonEvents);
        this.button.one('focusin', function () {
          // Delay rendering the menu items until the button receives focus.
          // The menu may have already been rendered via a programmatic open.
          if (!that.menuItems) {
            that._refreshMenu();
          }
        });
        this._hoverable(this.button);
        this._focusable(this.button);
      },
      _drawMenu: function () {
        var that = this;
        // Create menu
        this.menu = $('<ul>', {
          'aria-hidden': 'true',
          'aria-labelledby': this.ids.button,
          id: this.ids.menu
        });
        // Wrap menu
        this.menuWrap = $('<div>', { 'class': 'ui-selectmenu-menu ui-front' }).append(this.menu).appendTo(this._appendTo());
        // Initialize menu widget
        this.menuInstance = this.menu.menu({
          role: 'listbox',
          select: function (event, ui) {
            event.preventDefault();
            // support: IE8
            // If the item was selected via a click, the text selection
            // will be destroyed in IE
            that._setSelection();
            that._select(ui.item.data('ui-selectmenu-item'), event);
          },
          focus: function (event, ui) {
            var item = ui.item.data('ui-selectmenu-item');
            // Prevent inital focus from firing and check if its a newly focused item
            if (that.focusIndex != null && item.index !== that.focusIndex) {
              that._trigger('focus', event, { item: item });
              if (!that.isOpen) {
                that._select(item, event);
              }
            }
            that.focusIndex = item.index;
            that.button.attr('aria-activedescendant', that.menuItems.eq(item.index).attr('id'));
          }
        }).menu('instance');
        // Adjust menu styles to dropdown
        this.menu.addClass('ui-corner-bottom').removeClass('ui-corner-all');
        // Don't close the menu on mouseleave
        this.menuInstance._off(this.menu, 'mouseleave');
        // Cancel the menu's collapseAll on document click
        this.menuInstance._closeOnDocumentClick = function () {
          return false;
        };
        // Selects often contain empty items, but never contain dividers
        this.menuInstance._isDivider = function () {
          return false;
        };
      },
      refresh: function () {
        this._refreshMenu();
        this._setText(this.buttonText, this._getSelectedItem().text());
        if (!this.options.width) {
          this._resizeButton();
        }
      },
      _refreshMenu: function () {
        this.menu.empty();
        var item, options = this.element.find('option');
        if (!options.length) {
          return;
        }
        this._parseOptions(options);
        this._renderMenu(this.menu, this.items);
        this.menuInstance.refresh();
        this.menuItems = this.menu.find('li').not('.ui-selectmenu-optgroup');
        item = this._getSelectedItem();
        // Update the menu to have the correct item focused
        this.menuInstance.focus(null, item);
        this._setAria(item.data('ui-selectmenu-item'));
        // Set disabled state
        this._setOption('disabled', this.element.prop('disabled'));
      },
      open: function (event) {
        if (this.options.disabled) {
          return;
        }
        // If this is the first time the menu is being opened, render the items
        if (!this.menuItems) {
          this._refreshMenu();
        } else {
          // Menu clears focus on close, reset focus to selected item
          this.menu.find('.ui-state-focus').removeClass('ui-state-focus');
          this.menuInstance.focus(null, this._getSelectedItem());
        }
        this.isOpen = true;
        this._toggleAttr();
        this._resizeMenu();
        this._position();
        this._on(this.document, this._documentClick);
        this._trigger('open', event);
      },
      _position: function () {
        this.menuWrap.position($.extend({ of: this.button }, this.options.position));
      },
      close: function (event) {
        if (!this.isOpen) {
          return;
        }
        this.isOpen = false;
        this._toggleAttr();
        this.range = null;
        this._off(this.document);
        this._trigger('close', event);
      },
      widget: function () {
        return this.button;
      },
      menuWidget: function () {
        return this.menu;
      },
      _renderMenu: function (ul, items) {
        var that = this, currentOptgroup = '';
        $.each(items, function (index, item) {
          if (item.optgroup !== currentOptgroup) {
            $('<li>', {
              'class': 'ui-selectmenu-optgroup ui-menu-divider' + (item.element.parent('optgroup').prop('disabled') ? ' ui-state-disabled' : ''),
              text: item.optgroup
            }).appendTo(ul);
            currentOptgroup = item.optgroup;
          }
          that._renderItemData(ul, item);
        });
      },
      _renderItemData: function (ul, item) {
        return this._renderItem(ul, item).data('ui-selectmenu-item', item);
      },
      _renderItem: function (ul, item) {
        var li = $('<li>');
        if (item.disabled) {
          li.addClass('ui-state-disabled');
        }
        this._setText(li, item.label);
        return li.appendTo(ul);
      },
      _setText: function (element, value) {
        if (value) {
          element.text(value);
        } else {
          element.html('&#160;');
        }
      },
      _move: function (direction, event) {
        var item, next, filter = '.ui-menu-item';
        if (this.isOpen) {
          item = this.menuItems.eq(this.focusIndex);
        } else {
          item = this.menuItems.eq(this.element[0].selectedIndex);
          filter += ':not(.ui-state-disabled)';
        }
        if (direction === 'first' || direction === 'last') {
          next = item[direction === 'first' ? 'prevAll' : 'nextAll'](filter).eq(-1);
        } else {
          next = item[direction + 'All'](filter).eq(0);
        }
        if (next.length) {
          this.menuInstance.focus(event, next);
        }
      },
      _getSelectedItem: function () {
        return this.menuItems.eq(this.element[0].selectedIndex);
      },
      _toggle: function (event) {
        this[this.isOpen ? 'close' : 'open'](event);
      },
      _setSelection: function () {
        var selection;
        if (!this.range) {
          return;
        }
        if (window.getSelection) {
          selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(this.range);  // support: IE8
        } else {
          this.range.select();
        }
        // support: IE
        // Setting the text selection kills the button focus in IE, but
        // restoring the focus doesn't kill the selection.
        this.button.focus();
      },
      _documentClick: {
        mousedown: function (event) {
          if (!this.isOpen) {
            return;
          }
          if (!$(event.target).closest('.ui-selectmenu-menu, #' + this.ids.button).length) {
            this.close(event);
          }
        }
      },
      _buttonEvents: {
        mousedown: function () {
          var selection;
          if (window.getSelection) {
            selection = window.getSelection();
            if (selection.rangeCount) {
              this.range = selection.getRangeAt(0);
            }  // support: IE8
          } else {
            this.range = document.selection.createRange();
          }
        },
        click: function (event) {
          this._setSelection();
          this._toggle(event);
        },
        keydown: function (event) {
          var preventDefault = true;
          switch (event.keyCode) {
          case $.ui.keyCode.TAB:
          case $.ui.keyCode.ESCAPE:
            this.close(event);
            preventDefault = false;
            break;
          case $.ui.keyCode.ENTER:
            if (this.isOpen) {
              this._selectFocusedItem(event);
            }
            break;
          case $.ui.keyCode.UP:
            if (event.altKey) {
              this._toggle(event);
            } else {
              this._move('prev', event);
            }
            break;
          case $.ui.keyCode.DOWN:
            if (event.altKey) {
              this._toggle(event);
            } else {
              this._move('next', event);
            }
            break;
          case $.ui.keyCode.SPACE:
            if (this.isOpen) {
              this._selectFocusedItem(event);
            } else {
              this._toggle(event);
            }
            break;
          case $.ui.keyCode.LEFT:
            this._move('prev', event);
            break;
          case $.ui.keyCode.RIGHT:
            this._move('next', event);
            break;
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.PAGE_UP:
            this._move('first', event);
            break;
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_DOWN:
            this._move('last', event);
            break;
          default:
            this.menu.trigger(event);
            preventDefault = false;
          }
          if (preventDefault) {
            event.preventDefault();
          }
        }
      },
      _selectFocusedItem: function (event) {
        var item = this.menuItems.eq(this.focusIndex);
        if (!item.hasClass('ui-state-disabled')) {
          this._select(item.data('ui-selectmenu-item'), event);
        }
      },
      _select: function (item, event) {
        var oldIndex = this.element[0].selectedIndex;
        // Change native select element
        this.element[0].selectedIndex = item.index;
        this._setText(this.buttonText, item.label);
        this._setAria(item);
        this._trigger('select', event, { item: item });
        if (item.index !== oldIndex) {
          this._trigger('change', event, { item: item });
        }
        this.close(event);
      },
      _setAria: function (item) {
        var id = this.menuItems.eq(item.index).attr('id');
        this.button.attr({
          'aria-labelledby': id,
          'aria-activedescendant': id
        });
        this.menu.attr('aria-activedescendant', id);
      },
      _setOption: function (key, value) {
        if (key === 'icons') {
          this.button.find('span.ui-icon').removeClass(this.options.icons.button).addClass(value.button);
        }
        this._super(key, value);
        if (key === 'appendTo') {
          this.menuWrap.appendTo(this._appendTo());
        }
        if (key === 'disabled') {
          this.menuInstance.option('disabled', value);
          this.button.toggleClass('ui-state-disabled', value).attr('aria-disabled', value);
          this.element.prop('disabled', value);
          if (value) {
            this.button.attr('tabindex', -1);
            this.close();
          } else {
            this.button.attr('tabindex', 0);
          }
        }
        if (key === 'width') {
          this._resizeButton();
        }
      },
      _appendTo: function () {
        var element = this.options.appendTo;
        if (element) {
          element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
        }
        if (!element || !element[0]) {
          element = this.element.closest('.ui-front');
        }
        if (!element.length) {
          element = this.document[0].body;
        }
        return element;
      },
      _toggleAttr: function () {
        this.button.toggleClass('ui-corner-top', this.isOpen).toggleClass('ui-corner-all', !this.isOpen).attr('aria-expanded', this.isOpen);
        this.menuWrap.toggleClass('ui-selectmenu-open', this.isOpen);
        this.menu.attr('aria-hidden', !this.isOpen);
      },
      _resizeButton: function () {
        var width = this.options.width;
        if (!width) {
          width = this.element.show().outerWidth();
          this.element.hide();
        }
        this.button.outerWidth(width);
      },
      _resizeMenu: function () {
        this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width('').outerWidth() + 1));
      },
      _getCreateOptions: function () {
        return { disabled: this.element.prop('disabled') };
      },
      _parseOptions: function (options) {
        var data = [];
        options.each(function (index, item) {
          var option = $(item), optgroup = option.parent('optgroup');
          data.push({
            element: option,
            index: index,
            value: option.val(),
            label: option.text(),
            optgroup: optgroup.attr('label') || '',
            disabled: optgroup.prop('disabled') || option.prop('disabled')
          });
        });
        this.items = data;
      },
      _destroy: function () {
        this.menuWrap.remove();
        this.button.remove();
        this.element.show();
        this.element.removeUniqueId();
        this.label.attr('for', this.ids.element);
      }
    });
  /*!
 * jQuery UI Slider 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 */
  var slider = $.widget('ui.slider', $.ui.mouse, {
      version: '1.11.4',
      widgetEventPrefix: 'slide',
      options: {
        animate: false,
        distance: 0,
        max: 100,
        min: 0,
        orientation: 'horizontal',
        range: false,
        step: 1,
        value: 0,
        values: null,
        change: null,
        slide: null,
        start: null,
        stop: null
      },
      numPages: 5,
      _create: function () {
        this._keySliding = false;
        this._mouseSliding = false;
        this._animateOff = true;
        this._handleIndex = null;
        this._detectOrientation();
        this._mouseInit();
        this._calculateNewMax();
        this.element.addClass('ui-slider' + ' ui-slider-' + this.orientation + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all');
        this._refresh();
        this._setOption('disabled', this.options.disabled);
        this._animateOff = false;
      },
      _refresh: function () {
        this._createRange();
        this._createHandles();
        this._setupEvents();
        this._refreshValue();
      },
      _createHandles: function () {
        var i, handleCount, options = this.options, existingHandles = this.element.find('.ui-slider-handle').addClass('ui-state-default ui-corner-all'), handle = '<span class=\'ui-slider-handle ui-state-default ui-corner-all\' tabindex=\'0\'></span>', handles = [];
        handleCount = options.values && options.values.length || 1;
        if (existingHandles.length > handleCount) {
          existingHandles.slice(handleCount).remove();
          existingHandles = existingHandles.slice(0, handleCount);
        }
        for (i = existingHandles.length; i < handleCount; i++) {
          handles.push(handle);
        }
        this.handles = existingHandles.add($(handles.join('')).appendTo(this.element));
        this.handle = this.handles.eq(0);
        this.handles.each(function (i) {
          $(this).data('ui-slider-handle-index', i);
        });
      },
      _createRange: function () {
        var options = this.options, classes = '';
        if (options.range) {
          if (options.range === true) {
            if (!options.values) {
              options.values = [
                this._valueMin(),
                this._valueMin()
              ];
            } else if (options.values.length && options.values.length !== 2) {
              options.values = [
                options.values[0],
                options.values[0]
              ];
            } else if ($.isArray(options.values)) {
              options.values = options.values.slice(0);
            }
          }
          if (!this.range || !this.range.length) {
            this.range = $('<div></div>').appendTo(this.element);
            classes = 'ui-slider-range' + ' ui-widget-header ui-corner-all';
          } else {
            this.range.removeClass('ui-slider-range-min ui-slider-range-max').css({
              'left': '',
              'bottom': ''
            });
          }
          this.range.addClass(classes + (options.range === 'min' || options.range === 'max' ? ' ui-slider-range-' + options.range : ''));
        } else {
          if (this.range) {
            this.range.remove();
          }
          this.range = null;
        }
      },
      _setupEvents: function () {
        this._off(this.handles);
        this._on(this.handles, this._handleEvents);
        this._hoverable(this.handles);
        this._focusable(this.handles);
      },
      _destroy: function () {
        this.handles.remove();
        if (this.range) {
          this.range.remove();
        }
        this.element.removeClass('ui-slider' + ' ui-slider-horizontal' + ' ui-slider-vertical' + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all');
        this._mouseDestroy();
      },
      _mouseCapture: function (event) {
        var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
        if (o.disabled) {
          return false;
        }
        this.elementSize = {
          width: this.element.outerWidth(),
          height: this.element.outerHeight()
        };
        this.elementOffset = this.element.offset();
        position = {
          x: event.pageX,
          y: event.pageY
        };
        normValue = this._normValueFromMouse(position);
        distance = this._valueMax() - this._valueMin() + 1;
        this.handles.each(function (i) {
          var thisDistance = Math.abs(normValue - that.values(i));
          if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
            distance = thisDistance;
            closestHandle = $(this);
            index = i;
          }
        });
        allowed = this._start(event, index);
        if (allowed === false) {
          return false;
        }
        this._mouseSliding = true;
        this._handleIndex = index;
        closestHandle.addClass('ui-state-active').focus();
        offset = closestHandle.offset();
        mouseOverHandle = !$(event.target).parents().addBack().is('.ui-slider-handle');
        this._clickOffset = mouseOverHandle ? {
          left: 0,
          top: 0
        } : {
          left: event.pageX - offset.left - closestHandle.width() / 2,
          top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css('borderTopWidth'), 10) || 0) - (parseInt(closestHandle.css('borderBottomWidth'), 10) || 0) + (parseInt(closestHandle.css('marginTop'), 10) || 0)
        };
        if (!this.handles.hasClass('ui-state-hover')) {
          this._slide(event, index, normValue);
        }
        this._animateOff = true;
        return true;
      },
      _mouseStart: function () {
        return true;
      },
      _mouseDrag: function (event) {
        var position = {
            x: event.pageX,
            y: event.pageY
          }, normValue = this._normValueFromMouse(position);
        this._slide(event, this._handleIndex, normValue);
        return false;
      },
      _mouseStop: function (event) {
        this.handles.removeClass('ui-state-active');
        this._mouseSliding = false;
        this._stop(event, this._handleIndex);
        this._change(event, this._handleIndex);
        this._handleIndex = null;
        this._clickOffset = null;
        this._animateOff = false;
        return false;
      },
      _detectOrientation: function () {
        this.orientation = this.options.orientation === 'vertical' ? 'vertical' : 'horizontal';
      },
      _normValueFromMouse: function (position) {
        var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
        if (this.orientation === 'horizontal') {
          pixelTotal = this.elementSize.width;
          pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
        } else {
          pixelTotal = this.elementSize.height;
          pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
        }
        percentMouse = pixelMouse / pixelTotal;
        if (percentMouse > 1) {
          percentMouse = 1;
        }
        if (percentMouse < 0) {
          percentMouse = 0;
        }
        if (this.orientation === 'vertical') {
          percentMouse = 1 - percentMouse;
        }
        valueTotal = this._valueMax() - this._valueMin();
        valueMouse = this._valueMin() + percentMouse * valueTotal;
        return this._trimAlignValue(valueMouse);
      },
      _start: function (event, index) {
        var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        return this._trigger('start', event, uiHash);
      },
      _slide: function (event, index, newVal) {
        var otherVal, newValues, allowed;
        if (this.options.values && this.options.values.length) {
          otherVal = this.values(index ? 0 : 1);
          if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {
            newVal = otherVal;
          }
          if (newVal !== this.values(index)) {
            newValues = this.values();
            newValues[index] = newVal;
            // A slide can be canceled by returning false from the slide callback
            allowed = this._trigger('slide', event, {
              handle: this.handles[index],
              value: newVal,
              values: newValues
            });
            otherVal = this.values(index ? 0 : 1);
            if (allowed !== false) {
              this.values(index, newVal);
            }
          }
        } else {
          if (newVal !== this.value()) {
            // A slide can be canceled by returning false from the slide callback
            allowed = this._trigger('slide', event, {
              handle: this.handles[index],
              value: newVal
            });
            if (allowed !== false) {
              this.value(newVal);
            }
          }
        }
      },
      _stop: function (event, index) {
        var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        this._trigger('stop', event, uiHash);
      },
      _change: function (event, index) {
        if (!this._keySliding && !this._mouseSliding) {
          var uiHash = {
              handle: this.handles[index],
              value: this.value()
            };
          if (this.options.values && this.options.values.length) {
            uiHash.value = this.values(index);
            uiHash.values = this.values();
          }
          //store the last changed value index for reference when handles overlap
          this._lastChangedValue = index;
          this._trigger('change', event, uiHash);
        }
      },
      value: function (newValue) {
        if (arguments.length) {
          this.options.value = this._trimAlignValue(newValue);
          this._refreshValue();
          this._change(null, 0);
          return;
        }
        return this._value();
      },
      values: function (index, newValue) {
        var vals, newValues, i;
        if (arguments.length > 1) {
          this.options.values[index] = this._trimAlignValue(newValue);
          this._refreshValue();
          this._change(null, index);
          return;
        }
        if (arguments.length) {
          if ($.isArray(arguments[0])) {
            vals = this.options.values;
            newValues = arguments[0];
            for (i = 0; i < vals.length; i += 1) {
              vals[i] = this._trimAlignValue(newValues[i]);
              this._change(null, i);
            }
            this._refreshValue();
          } else {
            if (this.options.values && this.options.values.length) {
              return this._values(index);
            } else {
              return this.value();
            }
          }
        } else {
          return this._values();
        }
      },
      _setOption: function (key, value) {
        var i, valsLength = 0;
        if (key === 'range' && this.options.range === true) {
          if (value === 'min') {
            this.options.value = this._values(0);
            this.options.values = null;
          } else if (value === 'max') {
            this.options.value = this._values(this.options.values.length - 1);
            this.options.values = null;
          }
        }
        if ($.isArray(this.options.values)) {
          valsLength = this.options.values.length;
        }
        if (key === 'disabled') {
          this.element.toggleClass('ui-state-disabled', !!value);
        }
        this._super(key, value);
        switch (key) {
        case 'orientation':
          this._detectOrientation();
          this.element.removeClass('ui-slider-horizontal ui-slider-vertical').addClass('ui-slider-' + this.orientation);
          this._refreshValue();
          // Reset positioning from previous orientation
          this.handles.css(value === 'horizontal' ? 'bottom' : 'left', '');
          break;
        case 'value':
          this._animateOff = true;
          this._refreshValue();
          this._change(null, 0);
          this._animateOff = false;
          break;
        case 'values':
          this._animateOff = true;
          this._refreshValue();
          for (i = 0; i < valsLength; i += 1) {
            this._change(null, i);
          }
          this._animateOff = false;
          break;
        case 'step':
        case 'min':
        case 'max':
          this._animateOff = true;
          this._calculateNewMax();
          this._refreshValue();
          this._animateOff = false;
          break;
        case 'range':
          this._animateOff = true;
          this._refresh();
          this._animateOff = false;
          break;
        }
      },
      _value: function () {
        var val = this.options.value;
        val = this._trimAlignValue(val);
        return val;
      },
      _values: function (index) {
        var val, vals, i;
        if (arguments.length) {
          val = this.options.values[index];
          val = this._trimAlignValue(val);
          return val;
        } else if (this.options.values && this.options.values.length) {
          // .slice() creates a copy of the array
          // this copy gets trimmed by min and max and then returned
          vals = this.options.values.slice();
          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(vals[i]);
          }
          return vals;
        } else {
          return [];
        }
      },
      _trimAlignValue: function (val) {
        if (val <= this._valueMin()) {
          return this._valueMin();
        }
        if (val >= this._valueMax()) {
          return this._valueMax();
        }
        var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
        if (Math.abs(valModStep) * 2 >= step) {
          alignValue += valModStep > 0 ? step : -step;
        }
        // Since JavaScript has problems with large floats, round
        // the final value to 5 digits after the decimal point (see #4124)
        return parseFloat(alignValue.toFixed(5));
      },
      _calculateNewMax: function () {
        var max = this.options.max, min = this._valueMin(), step = this.options.step, aboveMin = Math.floor(+(max - min).toFixed(this._precision()) / step) * step;
        max = aboveMin + min;
        this.max = parseFloat(max.toFixed(this._precision()));
      },
      _precision: function () {
        var precision = this._precisionOf(this.options.step);
        if (this.options.min !== null) {
          precision = Math.max(precision, this._precisionOf(this.options.min));
        }
        return precision;
      },
      _precisionOf: function (num) {
        var str = num.toString(), decimal = str.indexOf('.');
        return decimal === -1 ? 0 : str.length - decimal - 1;
      },
      _valueMin: function () {
        return this.options.min;
      },
      _valueMax: function () {
        return this.max;
      },
      _refreshValue: function () {
        var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
        if (this.options.values && this.options.values.length) {
          this.handles.each(function (i) {
            valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
            _set[that.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
            $(this).stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);
            if (that.options.range === true) {
              if (that.orientation === 'horizontal') {
                if (i === 0) {
                  that.range.stop(1, 1)[animate ? 'animate' : 'css']({ left: valPercent + '%' }, o.animate);
                }
                if (i === 1) {
                  that.range[animate ? 'animate' : 'css']({ width: valPercent - lastValPercent + '%' }, {
                    queue: false,
                    duration: o.animate
                  });
                }
              } else {
                if (i === 0) {
                  that.range.stop(1, 1)[animate ? 'animate' : 'css']({ bottom: valPercent + '%' }, o.animate);
                }
                if (i === 1) {
                  that.range[animate ? 'animate' : 'css']({ height: valPercent - lastValPercent + '%' }, {
                    queue: false,
                    duration: o.animate
                  });
                }
              }
            }
            lastValPercent = valPercent;
          });
        } else {
          value = this.value();
          valueMin = this._valueMin();
          valueMax = this._valueMax();
          valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
          _set[this.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
          this.handle.stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);
          if (oRange === 'min' && this.orientation === 'horizontal') {
            this.range.stop(1, 1)[animate ? 'animate' : 'css']({ width: valPercent + '%' }, o.animate);
          }
          if (oRange === 'max' && this.orientation === 'horizontal') {
            this.range[animate ? 'animate' : 'css']({ width: 100 - valPercent + '%' }, {
              queue: false,
              duration: o.animate
            });
          }
          if (oRange === 'min' && this.orientation === 'vertical') {
            this.range.stop(1, 1)[animate ? 'animate' : 'css']({ height: valPercent + '%' }, o.animate);
          }
          if (oRange === 'max' && this.orientation === 'vertical') {
            this.range[animate ? 'animate' : 'css']({ height: 100 - valPercent + '%' }, {
              queue: false,
              duration: o.animate
            });
          }
        }
      },
      _handleEvents: {
        keydown: function (event) {
          var allowed, curVal, newVal, step, index = $(event.target).data('ui-slider-handle-index');
          switch (event.keyCode) {
          case $.ui.keyCode.HOME:
          case $.ui.keyCode.END:
          case $.ui.keyCode.PAGE_UP:
          case $.ui.keyCode.PAGE_DOWN:
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            event.preventDefault();
            if (!this._keySliding) {
              this._keySliding = true;
              $(event.target).addClass('ui-state-active');
              allowed = this._start(event, index);
              if (allowed === false) {
                return;
              }
            }
            break;
          }
          step = this.options.step;
          if (this.options.values && this.options.values.length) {
            curVal = newVal = this.values(index);
          } else {
            curVal = newVal = this.value();
          }
          switch (event.keyCode) {
          case $.ui.keyCode.HOME:
            newVal = this._valueMin();
            break;
          case $.ui.keyCode.END:
            newVal = this._valueMax();
            break;
          case $.ui.keyCode.PAGE_UP:
            newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);
            break;
          case $.ui.keyCode.PAGE_DOWN:
            newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.RIGHT:
            if (curVal === this._valueMax()) {
              return;
            }
            newVal = this._trimAlignValue(curVal + step);
            break;
          case $.ui.keyCode.DOWN:
          case $.ui.keyCode.LEFT:
            if (curVal === this._valueMin()) {
              return;
            }
            newVal = this._trimAlignValue(curVal - step);
            break;
          }
          this._slide(event, index, newVal);
        },
        keyup: function (event) {
          var index = $(event.target).data('ui-slider-handle-index');
          if (this._keySliding) {
            this._keySliding = false;
            this._stop(event, index);
            this._change(event, index);
            $(event.target).removeClass('ui-state-active');
          }
        }
      }
    });
  /*!
 * jQuery UI Sortable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/sortable/
 */
  var sortable = $.widget('ui.sortable', $.ui.mouse, {
      version: '1.11.4',
      widgetEventPrefix: 'sort',
      ready: false,
      options: {
        appendTo: 'parent',
        axis: false,
        connectWith: false,
        containment: false,
        cursor: 'auto',
        cursorAt: false,
        dropOnEmpty: true,
        forcePlaceholderSize: false,
        forceHelperSize: false,
        grid: false,
        handle: false,
        helper: 'original',
        items: '> *',
        opacity: false,
        placeholder: false,
        revert: false,
        scroll: true,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        scope: 'default',
        tolerance: 'intersect',
        zIndex: 1000,
        activate: null,
        beforeStop: null,
        change: null,
        deactivate: null,
        out: null,
        over: null,
        receive: null,
        remove: null,
        sort: null,
        start: null,
        stop: null,
        update: null
      },
      _isOverAxis: function (x, reference, size) {
        return x >= reference && x < reference + size;
      },
      _isFloating: function (item) {
        return /left|right/.test(item.css('float')) || /inline|table-cell/.test(item.css('display'));
      },
      _create: function () {
        this.containerCache = {};
        this.element.addClass('ui-sortable');
        //Get the items
        this.refresh();
        //Let's determine the parent's offset
        this.offset = this.element.offset();
        //Initialize mouse events for interaction
        this._mouseInit();
        this._setHandleClassName();
        //We're ready to go
        this.ready = true;
      },
      _setOption: function (key, value) {
        this._super(key, value);
        if (key === 'handle') {
          this._setHandleClassName();
        }
      },
      _setHandleClassName: function () {
        this.element.find('.ui-sortable-handle').removeClass('ui-sortable-handle');
        $.each(this.items, function () {
          (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass('ui-sortable-handle');
        });
      },
      _destroy: function () {
        this.element.removeClass('ui-sortable ui-sortable-disabled').find('.ui-sortable-handle').removeClass('ui-sortable-handle');
        this._mouseDestroy();
        for (var i = this.items.length - 1; i >= 0; i--) {
          this.items[i].item.removeData(this.widgetName + '-item');
        }
        return this;
      },
      _mouseCapture: function (event, overrideHandle) {
        var currentItem = null, validHandle = false, that = this;
        if (this.reverting) {
          return false;
        }
        if (this.options.disabled || this.options.type === 'static') {
          return false;
        }
        //We have to refresh the items data once first
        this._refreshItems(event);
        //Find out if the clicked node (or one of its parents) is a actual item in this.items
        $(event.target).parents().each(function () {
          if ($.data(this, that.widgetName + '-item') === that) {
            currentItem = $(this);
            return false;
          }
        });
        if ($.data(event.target, that.widgetName + '-item') === that) {
          currentItem = $(event.target);
        }
        if (!currentItem) {
          return false;
        }
        if (this.options.handle && !overrideHandle) {
          $(this.options.handle, currentItem).find('*').addBack().each(function () {
            if (this === event.target) {
              validHandle = true;
            }
          });
          if (!validHandle) {
            return false;
          }
        }
        this.currentItem = currentItem;
        this._removeCurrentsFromItems();
        return true;
      },
      _mouseStart: function (event, overrideHandle, noActivation) {
        var i, body, o = this.options;
        this.currentContainer = this;
        //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
        this.refreshPositions();
        //Create and append the visible helper
        this.helper = this._createHelper(event);
        //Cache the helper size
        this._cacheHelperProportions();
        /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
        //Cache the margins of the original element
        this._cacheMargins();
        //Get the next scrolling parent
        this.scrollParent = this.helper.scrollParent();
        //The element's absolute position on the page minus margins
        this.offset = this.currentItem.offset();
        this.offset = {
          top: this.offset.top - this.margins.top,
          left: this.offset.left - this.margins.left
        };
        $.extend(this.offset, {
          click: {
            left: event.pageX - this.offset.left,
            top: event.pageY - this.offset.top
          },
          parent: this._getParentOffset(),
          relative: this._getRelativeOffset()
        });
        // Only after we got the offset, we can change the helper's position to absolute
        // TODO: Still need to figure out a way to make relative sorting possible
        this.helper.css('position', 'absolute');
        this.cssPosition = this.helper.css('position');
        //Generate the original position
        this.originalPosition = this._generatePosition(event);
        this.originalPageX = event.pageX;
        this.originalPageY = event.pageY;
        //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
        o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
        //Cache the former DOM position
        this.domPosition = {
          prev: this.currentItem.prev()[0],
          parent: this.currentItem.parent()[0]
        };
        //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
        if (this.helper[0] !== this.currentItem[0]) {
          this.currentItem.hide();
        }
        //Create the placeholder
        this._createPlaceholder();
        //Set a containment if given in the options
        if (o.containment) {
          this._setContainment();
        }
        if (o.cursor && o.cursor !== 'auto') {
          // cursor option
          body = this.document.find('body');
          // support: IE
          this.storedCursor = body.css('cursor');
          body.css('cursor', o.cursor);
          this.storedStylesheet = $('<style>*{ cursor: ' + o.cursor + ' !important; }</style>').appendTo(body);
        }
        if (o.opacity) {
          // opacity option
          if (this.helper.css('opacity')) {
            this._storedOpacity = this.helper.css('opacity');
          }
          this.helper.css('opacity', o.opacity);
        }
        if (o.zIndex) {
          // zIndex option
          if (this.helper.css('zIndex')) {
            this._storedZIndex = this.helper.css('zIndex');
          }
          this.helper.css('zIndex', o.zIndex);
        }
        //Prepare scrolling
        if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== 'HTML') {
          this.overflowOffset = this.scrollParent.offset();
        }
        //Call callbacks
        this._trigger('start', event, this._uiHash());
        //Recache the helper size
        if (!this._preserveHelperProportions) {
          this._cacheHelperProportions();
        }
        //Post "activate" events to possible containers
        if (!noActivation) {
          for (i = this.containers.length - 1; i >= 0; i--) {
            this.containers[i]._trigger('activate', event, this._uiHash(this));
          }
        }
        //Prepare possible droppables
        if ($.ui.ddmanager) {
          $.ui.ddmanager.current = this;
        }
        if ($.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
        this.dragging = true;
        this.helper.addClass('ui-sortable-helper');
        this._mouseDrag(event);
        //Execute the drag once - this causes the helper not to be visible before getting its correct position
        return true;
      },
      _mouseDrag: function (event) {
        var i, item, itemElement, intersection, o = this.options, scrolled = false;
        //Compute the helpers position
        this.position = this._generatePosition(event);
        this.positionAbs = this._convertPositionTo('absolute');
        if (!this.lastPositionAbs) {
          this.lastPositionAbs = this.positionAbs;
        }
        //Do scrolling
        if (this.options.scroll) {
          if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== 'HTML') {
            if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
              this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
            } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
              this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
            }
            if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
              this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
            } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
              this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
            }
          } else {
            if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
              scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
            } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
              scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
            }
            if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
              scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
            } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
              scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
            }
          }
          if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
          }
        }
        //Regenerate the absolute position used for position checks
        this.positionAbs = this._convertPositionTo('absolute');
        //Set the helper position
        if (!this.options.axis || this.options.axis !== 'y') {
          this.helper[0].style.left = this.position.left + 'px';
        }
        if (!this.options.axis || this.options.axis !== 'x') {
          this.helper[0].style.top = this.position.top + 'px';
        }
        //Rearrange
        for (i = this.items.length - 1; i >= 0; i--) {
          //Cache variables and intersection, continue if no intersection
          item = this.items[i];
          itemElement = item.item[0];
          intersection = this._intersectsWithPointer(item);
          if (!intersection) {
            continue;
          }
          // Only put the placeholder inside the current Container, skip all
          // items from other containers. This works because when moving
          // an item from one container to another the
          // currentContainer is switched before the placeholder is moved.
          //
          // Without this, moving items in "sub-sortables" can cause
          // the placeholder to jitter between the outer and inner container.
          if (item.instance !== this.currentContainer) {
            continue;
          }
          // cannot intersect with itself
          // no useless actions that have been done before
          // no action if the item moved is the parent of the item checked
          if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? 'next' : 'prev']()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)) {
            this.direction = intersection === 1 ? 'down' : 'up';
            if (this.options.tolerance === 'pointer' || this._intersectsWithSides(item)) {
              this._rearrange(event, item);
            } else {
              break;
            }
            this._trigger('change', event, this._uiHash());
            break;
          }
        }
        //Post events to containers
        this._contactContainers(event);
        //Interconnect with droppables
        if ($.ui.ddmanager) {
          $.ui.ddmanager.drag(this, event);
        }
        //Call callbacks
        this._trigger('sort', event, this._uiHash());
        this.lastPositionAbs = this.positionAbs;
        return false;
      },
      _mouseStop: function (event, noPropagation) {
        if (!event) {
          return;
        }
        //If we are using droppables, inform the manager about the drop
        if ($.ui.ddmanager && !this.options.dropBehaviour) {
          $.ui.ddmanager.drop(this, event);
        }
        if (this.options.revert) {
          var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
          if (!axis || axis === 'x') {
            animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
          }
          if (!axis || axis === 'y') {
            animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
          }
          this.reverting = true;
          $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
            that._clear(event);
          });
        } else {
          this._clear(event, noPropagation);
        }
        return false;
      },
      cancel: function () {
        if (this.dragging) {
          this._mouseUp({ target: null });
          if (this.options.helper === 'original') {
            this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
          } else {
            this.currentItem.show();
          }
          //Post deactivating events to containers
          for (var i = this.containers.length - 1; i >= 0; i--) {
            this.containers[i]._trigger('deactivate', null, this._uiHash(this));
            if (this.containers[i].containerCache.over) {
              this.containers[i]._trigger('out', null, this._uiHash(this));
              this.containers[i].containerCache.over = 0;
            }
          }
        }
        if (this.placeholder) {
          //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
          if (this.placeholder[0].parentNode) {
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
          }
          if (this.options.helper !== 'original' && this.helper && this.helper[0].parentNode) {
            this.helper.remove();
          }
          $.extend(this, {
            helper: null,
            dragging: false,
            reverting: false,
            _noFinalSort: null
          });
          if (this.domPosition.prev) {
            $(this.domPosition.prev).after(this.currentItem);
          } else {
            $(this.domPosition.parent).prepend(this.currentItem);
          }
        }
        return this;
      },
      serialize: function (o) {
        var items = this._getItemsAsjQuery(o && o.connected), str = [];
        o = o || {};
        $(items).each(function () {
          var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || /(.+)[\-=_](.+)/);
          if (res) {
            str.push((o.key || res[1] + '[]') + '=' + (o.key && o.expression ? res[1] : res[2]));
          }
        });
        if (!str.length && o.key) {
          str.push(o.key + '=');
        }
        return str.join('&');
      },
      toArray: function (o) {
        var items = this._getItemsAsjQuery(o && o.connected), ret = [];
        o = o || {};
        items.each(function () {
          ret.push($(o.item || this).attr(o.attribute || 'id') || '');
        });
        return ret;
      },
      _intersectsWith: function (item) {
        var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === 'x' || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === 'y' || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
        if (this.options.tolerance === 'pointer' || this.options.forcePointerForContainers || this.options.tolerance !== 'pointer' && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height']) {
          return isOverElement;
        } else {
          return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;  // Top Half
        }
      },
      _intersectsWithPointer: function (item) {
        var isOverElementHeight = this.options.axis === 'x' || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === 'y' || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
        if (!isOverElement) {
          return false;
        }
        return this.floating ? horizontalDirection && horizontalDirection === 'right' || verticalDirection === 'down' ? 2 : 1 : verticalDirection && (verticalDirection === 'down' ? 2 : 1);
      },
      _intersectsWithSides: function (item) {
        var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
        if (this.floating && horizontalDirection) {
          return horizontalDirection === 'right' && isOverRightHalf || horizontalDirection === 'left' && !isOverRightHalf;
        } else {
          return verticalDirection && (verticalDirection === 'down' && isOverBottomHalf || verticalDirection === 'up' && !isOverBottomHalf);
        }
      },
      _getDragVerticalDirection: function () {
        var delta = this.positionAbs.top - this.lastPositionAbs.top;
        return delta !== 0 && (delta > 0 ? 'down' : 'up');
      },
      _getDragHorizontalDirection: function () {
        var delta = this.positionAbs.left - this.lastPositionAbs.left;
        return delta !== 0 && (delta > 0 ? 'right' : 'left');
      },
      refresh: function (event) {
        this._refreshItems(event);
        this._setHandleClassName();
        this.refreshPositions();
        return this;
      },
      _connectWith: function () {
        var options = this.options;
        return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
      },
      _getItemsAsjQuery: function (connected) {
        var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
        if (connectWith && connected) {
          for (i = connectWith.length - 1; i >= 0; i--) {
            cur = $(connectWith[i], this.document[0]);
            for (j = cur.length - 1; j >= 0; j--) {
              inst = $.data(cur[j], this.widgetFullName);
              if (inst && inst !== this && !inst.options.disabled) {
                queries.push([
                  $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not('.ui-sortable-helper').not('.ui-sortable-placeholder'),
                  inst
                ]);
              }
            }
          }
        }
        queries.push([
          $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
            options: this.options,
            item: this.currentItem
          }) : $(this.options.items, this.element).not('.ui-sortable-helper').not('.ui-sortable-placeholder'),
          this
        ]);
        function addItems() {
          items.push(this);
        }
        for (i = queries.length - 1; i >= 0; i--) {
          queries[i][0].each(addItems);
        }
        return $(items);
      },
      _removeCurrentsFromItems: function () {
        var list = this.currentItem.find(':data(' + this.widgetName + '-item)');
        this.items = $.grep(this.items, function (item) {
          for (var j = 0; j < list.length; j++) {
            if (list[j] === item.item[0]) {
              return false;
            }
          }
          return true;
        });
      },
      _refreshItems: function (event) {
        this.items = [];
        this.containers = [this];
        var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [[
              $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element),
              this
            ]], connectWith = this._connectWith();
        if (connectWith && this.ready) {
          //Shouldn't be run the first time through due to massive slow-down
          for (i = connectWith.length - 1; i >= 0; i--) {
            cur = $(connectWith[i], this.document[0]);
            for (j = cur.length - 1; j >= 0; j--) {
              inst = $.data(cur[j], this.widgetFullName);
              if (inst && inst !== this && !inst.options.disabled) {
                queries.push([
                  $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element),
                  inst
                ]);
                this.containers.push(inst);
              }
            }
          }
        }
        for (i = queries.length - 1; i >= 0; i--) {
          targetData = queries[i][1];
          _queries = queries[i][0];
          for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
            item = $(_queries[j]);
            item.data(this.widgetName + '-item', targetData);
            // Data for target checking (mouse manager)
            items.push({
              item: item,
              instance: targetData,
              width: 0,
              height: 0,
              left: 0,
              top: 0
            });
          }
        }
      },
      refreshPositions: function (fast) {
        // Determine whether items are being displayed horizontally
        this.floating = this.items.length ? this.options.axis === 'x' || this._isFloating(this.items[0].item) : false;
        //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
        if (this.offsetParent && this.helper) {
          this.offset.parent = this._getParentOffset();
        }
        var i, item, t, p;
        for (i = this.items.length - 1; i >= 0; i--) {
          item = this.items[i];
          //We ignore calculating positions of all connected containers when we're not over them
          if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
            continue;
          }
          t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
          if (!fast) {
            item.width = t.outerWidth();
            item.height = t.outerHeight();
          }
          p = t.offset();
          item.left = p.left;
          item.top = p.top;
        }
        if (this.options.custom && this.options.custom.refreshContainers) {
          this.options.custom.refreshContainers.call(this);
        } else {
          for (i = this.containers.length - 1; i >= 0; i--) {
            p = this.containers[i].element.offset();
            this.containers[i].containerCache.left = p.left;
            this.containers[i].containerCache.top = p.top;
            this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
          }
        }
        return this;
      },
      _createPlaceholder: function (that) {
        that = that || this;
        var className, o = that.options;
        if (!o.placeholder || o.placeholder.constructor === String) {
          className = o.placeholder;
          o.placeholder = {
            element: function () {
              var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $('<' + nodeName + '>', that.document[0]).addClass(className || that.currentItem[0].className + ' ui-sortable-placeholder').removeClass('ui-sortable-helper');
              if (nodeName === 'tbody') {
                that._createTrPlaceholder(that.currentItem.find('tr').eq(0), $('<tr>', that.document[0]).appendTo(element));
              } else if (nodeName === 'tr') {
                that._createTrPlaceholder(that.currentItem, element);
              } else if (nodeName === 'img') {
                element.attr('src', that.currentItem.attr('src'));
              }
              if (!className) {
                element.css('visibility', 'hidden');
              }
              return element;
            },
            update: function (container, p) {
              // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
              // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
              if (className && !o.forcePlaceholderSize) {
                return;
              }
              //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
              if (!p.height()) {
                p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop') || 0, 10) - parseInt(that.currentItem.css('paddingBottom') || 0, 10));
              }
              if (!p.width()) {
                p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft') || 0, 10) - parseInt(that.currentItem.css('paddingRight') || 0, 10));
              }
            }
          };
        }
        //Create the placeholder
        that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
        //Append it after the actual current item
        that.currentItem.after(that.placeholder);
        //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
        o.placeholder.update(that, that.placeholder);
      },
      _createTrPlaceholder: function (sourceTr, targetTr) {
        var that = this;
        sourceTr.children().each(function () {
          $('<td>&#160;</td>', that.document[0]).attr('colspan', $(this).attr('colspan') || 1).appendTo(targetTr);
        });
      },
      _contactContainers: function (event) {
        var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null;
        // get innermost container that intersects with item
        for (i = this.containers.length - 1; i >= 0; i--) {
          // never consider a container that's located within the item itself
          if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
            continue;
          }
          if (this._intersectsWith(this.containers[i].containerCache)) {
            // if we've already found a container and it's more "inner" than this, then continue
            if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
              continue;
            }
            innermostContainer = this.containers[i];
            innermostIndex = i;
          } else {
            // container doesn't intersect. trigger "out" event if necessary
            if (this.containers[i].containerCache.over) {
              this.containers[i]._trigger('out', event, this._uiHash(this));
              this.containers[i].containerCache.over = 0;
            }
          }
        }
        // if no intersecting containers found, return
        if (!innermostContainer) {
          return;
        }
        // move the item into the container if it's not there already
        if (this.containers.length === 1) {
          if (!this.containers[innermostIndex].containerCache.over) {
            this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
            this.containers[innermostIndex].containerCache.over = 1;
          }
        } else {
          //When entering a new container, we will find the item with the least distance and append our item near it
          dist = 10000;
          itemWithLeastDistance = null;
          floating = innermostContainer.floating || this._isFloating(this.currentItem);
          posProperty = floating ? 'left' : 'top';
          sizeProperty = floating ? 'width' : 'height';
          axis = floating ? 'clientX' : 'clientY';
          for (j = this.items.length - 1; j >= 0; j--) {
            if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
              continue;
            }
            if (this.items[j].item[0] === this.currentItem[0]) {
              continue;
            }
            cur = this.items[j].item.offset()[posProperty];
            nearBottom = false;
            if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
              nearBottom = true;
            }
            if (Math.abs(event[axis] - cur) < dist) {
              dist = Math.abs(event[axis] - cur);
              itemWithLeastDistance = this.items[j];
              this.direction = nearBottom ? 'up' : 'down';
            }
          }
          //Check if dropOnEmpty is enabled
          if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
            return;
          }
          if (this.currentContainer === this.containers[innermostIndex]) {
            if (!this.currentContainer.containerCache.over) {
              this.containers[innermostIndex]._trigger('over', event, this._uiHash());
              this.currentContainer.containerCache.over = 1;
            }
            return;
          }
          itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
          this._trigger('change', event, this._uiHash());
          this.containers[innermostIndex]._trigger('change', event, this._uiHash(this));
          this.currentContainer = this.containers[innermostIndex];
          //Update the placeholder
          this.options.placeholder.update(this.currentContainer, this.placeholder);
          this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
          this.containers[innermostIndex].containerCache.over = 1;
        }
      },
      _createHelper: function (event) {
        var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [
            event,
            this.currentItem
          ])) : o.helper === 'clone' ? this.currentItem.clone() : this.currentItem;
        //Add the helper to the DOM if that didn't happen already
        if (!helper.parents('body').length) {
          $(o.appendTo !== 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
        }
        if (helper[0] === this.currentItem[0]) {
          this._storedCSS = {
            width: this.currentItem[0].style.width,
            height: this.currentItem[0].style.height,
            position: this.currentItem.css('position'),
            top: this.currentItem.css('top'),
            left: this.currentItem.css('left')
          };
        }
        if (!helper[0].style.width || o.forceHelperSize) {
          helper.width(this.currentItem.width());
        }
        if (!helper[0].style.height || o.forceHelperSize) {
          helper.height(this.currentItem.height());
        }
        return helper;
      },
      _adjustOffsetFromHelper: function (obj) {
        if (typeof obj === 'string') {
          obj = obj.split(' ');
        }
        if ($.isArray(obj)) {
          obj = {
            left: +obj[0],
            top: +obj[1] || 0
          };
        }
        if ('left' in obj) {
          this.offset.click.left = obj.left + this.margins.left;
        }
        if ('right' in obj) {
          this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
        }
        if ('top' in obj) {
          this.offset.click.top = obj.top + this.margins.top;
        }
        if ('bottom' in obj) {
          this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
        }
      },
      _getParentOffset: function () {
        //Get the offsetParent and cache its position
        this.offsetParent = this.helper.offsetParent();
        var po = this.offsetParent.offset();
        // This is a special case where we need to modify a offset calculated on start, since the following happened:
        // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
        // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
        //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
        if (this.cssPosition === 'absolute' && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
          po.left += this.scrollParent.scrollLeft();
          po.top += this.scrollParent.scrollTop();
        }
        // This needs to be actually done for all browsers, since pageX/pageY includes this information
        // with an ugly IE fix
        if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie) {
          po = {
            top: 0,
            left: 0
          };
        }
        return {
          top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
          left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
        };
      },
      _getRelativeOffset: function () {
        if (this.cssPosition === 'relative') {
          var p = this.currentItem.position();
          return {
            top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
            left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft()
          };
        } else {
          return {
            top: 0,
            left: 0
          };
        }
      },
      _cacheMargins: function () {
        this.margins = {
          left: parseInt(this.currentItem.css('marginLeft'), 10) || 0,
          top: parseInt(this.currentItem.css('marginTop'), 10) || 0
        };
      },
      _cacheHelperProportions: function () {
        this.helperProportions = {
          width: this.helper.outerWidth(),
          height: this.helper.outerHeight()
        };
      },
      _setContainment: function () {
        var ce, co, over, o = this.options;
        if (o.containment === 'parent') {
          o.containment = this.helper[0].parentNode;
        }
        if (o.containment === 'document' || o.containment === 'window') {
          this.containment = [
            0 - this.offset.relative.left - this.offset.parent.left,
            0 - this.offset.relative.top - this.offset.parent.top,
            o.containment === 'document' ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
            (o.containment === 'document' ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
          ];
        }
        if (!/^(document|window|parent)$/.test(o.containment)) {
          ce = $(o.containment)[0];
          co = $(o.containment).offset();
          over = $(ce).css('overflow') !== 'hidden';
          this.containment = [
            co.left + (parseInt($(ce).css('borderLeftWidth'), 10) || 0) + (parseInt($(ce).css('paddingLeft'), 10) || 0) - this.margins.left,
            co.top + (parseInt($(ce).css('borderTopWidth'), 10) || 0) + (parseInt($(ce).css('paddingTop'), 10) || 0) - this.margins.top,
            co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css('borderLeftWidth'), 10) || 0) - (parseInt($(ce).css('paddingRight'), 10) || 0) - this.helperProportions.width - this.margins.left,
            co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css('borderTopWidth'), 10) || 0) - (parseInt($(ce).css('paddingBottom'), 10) || 0) - this.helperProportions.height - this.margins.top
          ];
        }
      },
      _convertPositionTo: function (d, pos) {
        if (!pos) {
          pos = this.position;
        }
        var mod = d === 'absolute' ? 1 : -1, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
        return {
          top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
          left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
        };
      },
      _generatePosition: function (event) {
        var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
        // This is another very weird special case that only happens for relative elements:
        // 1. If the css position is relative
        // 2. and the scroll parent is the document or similar to the offset parent
        // we have to refresh the relative offset during the scroll so there are no jumps
        if (this.cssPosition === 'relative' && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
          this.offset.relative = this._getRelativeOffset();
        }
        /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
        if (this.originalPosition) {
          //If we are not dragging yet, we won't check for options
          if (this.containment) {
            if (event.pageX - this.offset.click.left < this.containment[0]) {
              pageX = this.containment[0] + this.offset.click.left;
            }
            if (event.pageY - this.offset.click.top < this.containment[1]) {
              pageY = this.containment[1] + this.offset.click.top;
            }
            if (event.pageX - this.offset.click.left > this.containment[2]) {
              pageX = this.containment[2] + this.offset.click.left;
            }
            if (event.pageY - this.offset.click.top > this.containment[3]) {
              pageY = this.containment[3] + this.offset.click.top;
            }
          }
          if (o.grid) {
            top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
            pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
            left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
            pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
          }
        }
        return {
          top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
          left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
        };
      },
      _rearrange: function (event, i, a, hardRefresh) {
        a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === 'down' ? i.item[0] : i.item[0].nextSibling);
        //Various things done here to improve the performance:
        // 1. we create a setTimeout, that calls refreshPositions
        // 2. on the instance, we have a counter variable, that get's higher after every append
        // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
        // 4. this lets only the last addition to the timeout stack through
        this.counter = this.counter ? ++this.counter : 1;
        var counter = this.counter;
        this._delay(function () {
          if (counter === this.counter) {
            this.refreshPositions(!hardRefresh);  //Precompute after each DOM insertion, NOT on mousemove
          }
        });
      },
      _clear: function (event, noPropagation) {
        this.reverting = false;
        // We delay all events that have to be triggered to after the point where the placeholder has been removed and
        // everything else normalized again
        var i, delayedTriggers = [];
        // We first have to update the dom position of the actual currentItem
        // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
        if (!this._noFinalSort && this.currentItem.parent().length) {
          this.placeholder.before(this.currentItem);
        }
        this._noFinalSort = null;
        if (this.helper[0] === this.currentItem[0]) {
          for (i in this._storedCSS) {
            if (this._storedCSS[i] === 'auto' || this._storedCSS[i] === 'static') {
              this._storedCSS[i] = '';
            }
          }
          this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
        } else {
          this.currentItem.show();
        }
        if (this.fromOutside && !noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger('receive', event, this._uiHash(this.fromOutside));
          });
        }
        if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not('.ui-sortable-helper')[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger('update', event, this._uiHash());
          });  //Trigger update callback if the DOM position has changed
        }
        // Check if the items Container has Changed and trigger appropriate
        // events.
        if (this !== this.currentContainer) {
          if (!noPropagation) {
            delayedTriggers.push(function (event) {
              this._trigger('remove', event, this._uiHash());
            });
            delayedTriggers.push(function (c) {
              return function (event) {
                c._trigger('receive', event, this._uiHash(this));
              };
            }.call(this, this.currentContainer));
            delayedTriggers.push(function (c) {
              return function (event) {
                c._trigger('update', event, this._uiHash(this));
              };
            }.call(this, this.currentContainer));
          }
        }
        //Post events to containers
        function delayEvent(type, instance, container) {
          return function (event) {
            container._trigger(type, event, instance._uiHash(instance));
          };
        }
        for (i = this.containers.length - 1; i >= 0; i--) {
          if (!noPropagation) {
            delayedTriggers.push(delayEvent('deactivate', this, this.containers[i]));
          }
          if (this.containers[i].containerCache.over) {
            delayedTriggers.push(delayEvent('out', this, this.containers[i]));
            this.containers[i].containerCache.over = 0;
          }
        }
        //Do what was originally in plugins
        if (this.storedCursor) {
          this.document.find('body').css('cursor', this.storedCursor);
          this.storedStylesheet.remove();
        }
        if (this._storedOpacity) {
          this.helper.css('opacity', this._storedOpacity);
        }
        if (this._storedZIndex) {
          this.helper.css('zIndex', this._storedZIndex === 'auto' ? '' : this._storedZIndex);
        }
        this.dragging = false;
        if (!noPropagation) {
          this._trigger('beforeStop', event, this._uiHash());
        }
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        if (!this.cancelHelperRemoval) {
          if (this.helper[0] !== this.currentItem[0]) {
            this.helper.remove();
          }
          this.helper = null;
        }
        if (!noPropagation) {
          for (i = 0; i < delayedTriggers.length; i++) {
            delayedTriggers[i].call(this, event);
          }
          //Trigger all delayed events
          this._trigger('stop', event, this._uiHash());
        }
        this.fromOutside = false;
        return !this.cancelHelperRemoval;
      },
      _trigger: function () {
        if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
          this.cancel();
        }
      },
      _uiHash: function (_inst) {
        var inst = _inst || this;
        return {
          helper: inst.helper,
          placeholder: inst.placeholder || $([]),
          position: inst.position,
          originalPosition: inst.originalPosition,
          offset: inst.positionAbs,
          item: inst.currentItem,
          sender: _inst ? _inst.element : null
        };
      }
    });
  /*!
 * jQuery UI Spinner 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/spinner/
 */
  function spinner_modifier(fn) {
    return function () {
      var previous = this.element.val();
      fn.apply(this, arguments);
      this._refresh();
      if (previous !== this.element.val()) {
        this._trigger('change');
      }
    };
  }
  var spinner = $.widget('ui.spinner', {
      version: '1.11.4',
      defaultElement: '<input>',
      widgetEventPrefix: 'spin',
      options: {
        culture: null,
        icons: {
          down: 'ui-icon-triangle-1-s',
          up: 'ui-icon-triangle-1-n'
        },
        incremental: true,
        max: null,
        min: null,
        numberFormat: null,
        page: 10,
        step: 1,
        change: null,
        spin: null,
        start: null,
        stop: null
      },
      _create: function () {
        // handle string values that need to be parsed
        this._setOption('max', this.options.max);
        this._setOption('min', this.options.min);
        this._setOption('step', this.options.step);
        // Only format if there is a value, prevents the field from being marked
        // as invalid in Firefox, see #9573.
        if (this.value() !== '') {
          // Format the value, but don't constrain.
          this._value(this.element.val(), true);
        }
        this._draw();
        this._on(this._events);
        this._refresh();
        // turning off autocomplete prevents the browser from remembering the
        // value when navigating through history, so we re-enable autocomplete
        // if the page is unloaded before the widget is destroyed. #7790
        this._on(this.window, {
          beforeunload: function () {
            this.element.removeAttr('autocomplete');
          }
        });
      },
      _getCreateOptions: function () {
        var options = {}, element = this.element;
        $.each([
          'min',
          'max',
          'step'
        ], function (i, option) {
          var value = element.attr(option);
          if (value !== undefined && value.length) {
            options[option] = value;
          }
        });
        return options;
      },
      _events: {
        keydown: function (event) {
          if (this._start(event) && this._keydown(event)) {
            event.preventDefault();
          }
        },
        keyup: '_stop',
        focus: function () {
          this.previous = this.element.val();
        },
        blur: function (event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }
          this._stop();
          this._refresh();
          if (this.previous !== this.element.val()) {
            this._trigger('change', event);
          }
        },
        mousewheel: function (event, delta) {
          if (!delta) {
            return;
          }
          if (!this.spinning && !this._start(event)) {
            return false;
          }
          this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
          clearTimeout(this.mousewheelTimer);
          this.mousewheelTimer = this._delay(function () {
            if (this.spinning) {
              this._stop(event);
            }
          }, 100);
          event.preventDefault();
        },
        'mousedown .ui-spinner-button': function (event) {
          var previous;
          // We never want the buttons to have focus; whenever the user is
          // interacting with the spinner, the focus should be on the input.
          // If the input is focused then this.previous is properly set from
          // when the input first received focus. If the input is not focused
          // then we need to set this.previous based on the value before spinning.
          previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
          function checkFocus() {
            var isActive = this.element[0] === this.document[0].activeElement;
            if (!isActive) {
              this.element.focus();
              this.previous = previous;
              // support: IE
              // IE sets focus asynchronously, so we need to check if focus
              // moved off of the input because the user clicked on the button.
              this._delay(function () {
                this.previous = previous;
              });
            }
          }
          // ensure focus is on (or stays on) the text field
          event.preventDefault();
          checkFocus.call(this);
          // support: IE
          // IE doesn't prevent moving focus even with event.preventDefault()
          // so we set a flag to know when we should ignore the blur event
          // and check (again) if focus moved off of the input.
          this.cancelBlur = true;
          this._delay(function () {
            delete this.cancelBlur;
            checkFocus.call(this);
          });
          if (this._start(event) === false) {
            return;
          }
          this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
        },
        'mouseup .ui-spinner-button': '_stop',
        'mouseenter .ui-spinner-button': function (event) {
          // button will add ui-state-active if mouse was down while mouseleave and kept down
          if (!$(event.currentTarget).hasClass('ui-state-active')) {
            return;
          }
          if (this._start(event) === false) {
            return false;
          }
          this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
        },
        'mouseleave .ui-spinner-button': '_stop'
      },
      _draw: function () {
        var uiSpinner = this.uiSpinner = this.element.addClass('ui-spinner-input').attr('autocomplete', 'off').wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
        this.element.attr('role', 'spinbutton');
        // button bindings
        this.buttons = uiSpinner.find('.ui-spinner-button').attr('tabIndex', -1).button().removeClass('ui-corner-all');
        // IE 6 doesn't understand height: 50% for the buttons
        // unless the wrapper has an explicit height
        if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {
          uiSpinner.height(uiSpinner.height());
        }
        // disable spinner if element was already disabled
        if (this.options.disabled) {
          this.disable();
        }
      },
      _keydown: function (event) {
        var options = this.options, keyCode = $.ui.keyCode;
        switch (event.keyCode) {
        case keyCode.UP:
          this._repeat(null, 1, event);
          return true;
        case keyCode.DOWN:
          this._repeat(null, -1, event);
          return true;
        case keyCode.PAGE_UP:
          this._repeat(null, options.page, event);
          return true;
        case keyCode.PAGE_DOWN:
          this._repeat(null, -options.page, event);
          return true;
        }
        return false;
      },
      _uiSpinnerHtml: function () {
        return '<span class=\'ui-spinner ui-widget ui-widget-content ui-corner-all\'></span>';
      },
      _buttonHtml: function () {
        return '' + '<a class=\'ui-spinner-button ui-spinner-up ui-corner-tr\'>' + '<span class=\'ui-icon ' + this.options.icons.up + '\'>&#9650;</span>' + '</a>' + '<a class=\'ui-spinner-button ui-spinner-down ui-corner-br\'>' + '<span class=\'ui-icon ' + this.options.icons.down + '\'>&#9660;</span>' + '</a>';
      },
      _start: function (event) {
        if (!this.spinning && this._trigger('start', event) === false) {
          return false;
        }
        if (!this.counter) {
          this.counter = 1;
        }
        this.spinning = true;
        return true;
      },
      _repeat: function (i, steps, event) {
        i = i || 500;
        clearTimeout(this.timer);
        this.timer = this._delay(function () {
          this._repeat(40, steps, event);
        }, i);
        this._spin(steps * this.options.step, event);
      },
      _spin: function (step, event) {
        var value = this.value() || 0;
        if (!this.counter) {
          this.counter = 1;
        }
        value = this._adjustValue(value + step * this._increment(this.counter));
        if (!this.spinning || this._trigger('spin', event, { value: value }) !== false) {
          this._value(value);
          this.counter++;
        }
      },
      _increment: function (i) {
        var incremental = this.options.incremental;
        if (incremental) {
          return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
        }
        return 1;
      },
      _precision: function () {
        var precision = this._precisionOf(this.options.step);
        if (this.options.min !== null) {
          precision = Math.max(precision, this._precisionOf(this.options.min));
        }
        return precision;
      },
      _precisionOf: function (num) {
        var str = num.toString(), decimal = str.indexOf('.');
        return decimal === -1 ? 0 : str.length - decimal - 1;
      },
      _adjustValue: function (value) {
        var base, aboveMin, options = this.options;
        // make sure we're at a valid step
        // - find out where we are relative to the base (min or 0)
        base = options.min !== null ? options.min : 0;
        aboveMin = value - base;
        // - round to the nearest step
        aboveMin = Math.round(aboveMin / options.step) * options.step;
        // - rounding is based on 0, so adjust back to our base
        value = base + aboveMin;
        // fix precision from bad JS floating point math
        value = parseFloat(value.toFixed(this._precision()));
        // clamp the value
        if (options.max !== null && value > options.max) {
          return options.max;
        }
        if (options.min !== null && value < options.min) {
          return options.min;
        }
        return value;
      },
      _stop: function (event) {
        if (!this.spinning) {
          return;
        }
        clearTimeout(this.timer);
        clearTimeout(this.mousewheelTimer);
        this.counter = 0;
        this.spinning = false;
        this._trigger('stop', event);
      },
      _setOption: function (key, value) {
        if (key === 'culture' || key === 'numberFormat') {
          var prevValue = this._parse(this.element.val());
          this.options[key] = value;
          this.element.val(this._format(prevValue));
          return;
        }
        if (key === 'max' || key === 'min' || key === 'step') {
          if (typeof value === 'string') {
            value = this._parse(value);
          }
        }
        if (key === 'icons') {
          this.buttons.first().find('.ui-icon').removeClass(this.options.icons.up).addClass(value.up);
          this.buttons.last().find('.ui-icon').removeClass(this.options.icons.down).addClass(value.down);
        }
        this._super(key, value);
        if (key === 'disabled') {
          this.widget().toggleClass('ui-state-disabled', !!value);
          this.element.prop('disabled', !!value);
          this.buttons.button(value ? 'disable' : 'enable');
        }
      },
      _setOptions: spinner_modifier(function (options) {
        this._super(options);
      }),
      _parse: function (val) {
        if (typeof val === 'string' && val !== '') {
          val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
        }
        return val === '' || isNaN(val) ? null : val;
      },
      _format: function (value) {
        if (value === '') {
          return '';
        }
        return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
      },
      _refresh: function () {
        this.element.attr({
          'aria-valuemin': this.options.min,
          'aria-valuemax': this.options.max,
          'aria-valuenow': this._parse(this.element.val())
        });
      },
      isValid: function () {
        var value = this.value();
        // null is invalid
        if (value === null) {
          return false;
        }
        // if value gets adjusted, it's invalid
        return value === this._adjustValue(value);
      },
      _value: function (value, allowAny) {
        var parsed;
        if (value !== '') {
          parsed = this._parse(value);
          if (parsed !== null) {
            if (!allowAny) {
              parsed = this._adjustValue(parsed);
            }
            value = this._format(parsed);
          }
        }
        this.element.val(value);
        this._refresh();
      },
      _destroy: function () {
        this.element.removeClass('ui-spinner-input').prop('disabled', false).removeAttr('autocomplete').removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow');
        this.uiSpinner.replaceWith(this.element);
      },
      stepUp: spinner_modifier(function (steps) {
        this._stepUp(steps);
      }),
      _stepUp: function (steps) {
        if (this._start()) {
          this._spin((steps || 1) * this.options.step);
          this._stop();
        }
      },
      stepDown: spinner_modifier(function (steps) {
        this._stepDown(steps);
      }),
      _stepDown: function (steps) {
        if (this._start()) {
          this._spin((steps || 1) * -this.options.step);
          this._stop();
        }
      },
      pageUp: spinner_modifier(function (pages) {
        this._stepUp((pages || 1) * this.options.page);
      }),
      pageDown: spinner_modifier(function (pages) {
        this._stepDown((pages || 1) * this.options.page);
      }),
      value: function (newVal) {
        if (!arguments.length) {
          return this._parse(this.element.val());
        }
        spinner_modifier(this._value).call(this, newVal);
      },
      widget: function () {
        return this.uiSpinner;
      }
    });
  /*!
 * jQuery UI Tabs 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 */
  var tabs = $.widget('ui.tabs', {
      version: '1.11.4',
      delay: 300,
      options: {
        active: null,
        collapsible: false,
        event: 'click',
        heightStyle: 'content',
        hide: null,
        show: null,
        activate: null,
        beforeActivate: null,
        beforeLoad: null,
        load: null
      },
      _isLocal: function () {
        var rhash = /#.*$/;
        return function (anchor) {
          var anchorUrl, locationUrl;
          // support: IE7
          // IE7 doesn't normalize the href property when set via script (#9317)
          anchor = anchor.cloneNode(false);
          anchorUrl = anchor.href.replace(rhash, '');
          locationUrl = location.href.replace(rhash, '');
          // decoding may throw an error if the URL isn't UTF-8 (#9518)
          try {
            anchorUrl = decodeURIComponent(anchorUrl);
          } catch (error) {
          }
          try {
            locationUrl = decodeURIComponent(locationUrl);
          } catch (error) {
          }
          return anchor.hash.length > 1 && anchorUrl === locationUrl;
        };
      }(),
      _create: function () {
        var that = this, options = this.options;
        this.running = false;
        this.element.addClass('ui-tabs ui-widget ui-widget-content ui-corner-all').toggleClass('ui-tabs-collapsible', options.collapsible);
        this._processTabs();
        options.active = this._initialActive();
        // Take disabling tabs via class attribute from HTML
        // into account and update option properly.
        if ($.isArray(options.disabled)) {
          options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter('.ui-state-disabled'), function (li) {
            return that.tabs.index(li);
          }))).sort();
        }
        // check for length avoids error when initializing empty list
        if (this.options.active !== false && this.anchors.length) {
          this.active = this._findActive(options.active);
        } else {
          this.active = $();
        }
        this._refresh();
        if (this.active.length) {
          this.load(options.active);
        }
      },
      _initialActive: function () {
        var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
        if (active === null) {
          // check the fragment identifier in the URL
          if (locationHash) {
            this.tabs.each(function (i, tab) {
              if ($(tab).attr('aria-controls') === locationHash) {
                active = i;
                return false;
              }
            });
          }
          // check for a tab marked active via a class
          if (active === null) {
            active = this.tabs.index(this.tabs.filter('.ui-tabs-active'));
          }
          // no active tab, set to false
          if (active === null || active === -1) {
            active = this.tabs.length ? 0 : false;
          }
        }
        // handle numbers: negative, out of range
        if (active !== false) {
          active = this.tabs.index(this.tabs.eq(active));
          if (active === -1) {
            active = collapsible ? false : 0;
          }
        }
        // don't allow collapsible: false and active: false
        if (!collapsible && active === false && this.anchors.length) {
          active = 0;
        }
        return active;
      },
      _getCreateEventData: function () {
        return {
          tab: this.active,
          panel: !this.active.length ? $() : this._getPanelForTab(this.active)
        };
      },
      _tabKeydown: function (event) {
        var focusedTab = $(this.document[0].activeElement).closest('li'), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
        if (this._handlePageNav(event)) {
          return;
        }
        switch (event.keyCode) {
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
          selectedIndex++;
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.LEFT:
          goingForward = false;
          selectedIndex--;
          break;
        case $.ui.keyCode.END:
          selectedIndex = this.anchors.length - 1;
          break;
        case $.ui.keyCode.HOME:
          selectedIndex = 0;
          break;
        case $.ui.keyCode.SPACE:
          // Activate only, no collapsing
          event.preventDefault();
          clearTimeout(this.activating);
          this._activate(selectedIndex);
          return;
        case $.ui.keyCode.ENTER:
          // Toggle (cancel delayed activation, allow collapsing)
          event.preventDefault();
          clearTimeout(this.activating);
          // Determine if we should collapse or activate
          this._activate(selectedIndex === this.options.active ? false : selectedIndex);
          return;
        default:
          return;
        }
        // Focus the appropriate tab, based on which key was pressed
        event.preventDefault();
        clearTimeout(this.activating);
        selectedIndex = this._focusNextTab(selectedIndex, goingForward);
        // Navigating with control/command key will prevent automatic activation
        if (!event.ctrlKey && !event.metaKey) {
          // Update aria-selected immediately so that AT think the tab is already selected.
          // Otherwise AT may confuse the user by stating that they need to activate the tab,
          // but the tab will already be activated by the time the announcement finishes.
          focusedTab.attr('aria-selected', 'false');
          this.tabs.eq(selectedIndex).attr('aria-selected', 'true');
          this.activating = this._delay(function () {
            this.option('active', selectedIndex);
          }, this.delay);
        }
      },
      _panelKeydown: function (event) {
        if (this._handlePageNav(event)) {
          return;
        }
        // Ctrl+up moves focus to the current tab
        if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
          event.preventDefault();
          this.active.focus();
        }
      },
      _handlePageNav: function (event) {
        if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
          this._activate(this._focusNextTab(this.options.active - 1, false));
          return true;
        }
        if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
          this._activate(this._focusNextTab(this.options.active + 1, true));
          return true;
        }
      },
      _findNextTab: function (index, goingForward) {
        var lastTabIndex = this.tabs.length - 1;
        function constrain() {
          if (index > lastTabIndex) {
            index = 0;
          }
          if (index < 0) {
            index = lastTabIndex;
          }
          return index;
        }
        while ($.inArray(constrain(), this.options.disabled) !== -1) {
          index = goingForward ? index + 1 : index - 1;
        }
        return index;
      },
      _focusNextTab: function (index, goingForward) {
        index = this._findNextTab(index, goingForward);
        this.tabs.eq(index).focus();
        return index;
      },
      _setOption: function (key, value) {
        if (key === 'active') {
          // _activate() will handle invalid values and update this.options
          this._activate(value);
          return;
        }
        if (key === 'disabled') {
          // don't use the widget factory's disabled handling
          this._setupDisabled(value);
          return;
        }
        this._super(key, value);
        if (key === 'collapsible') {
          this.element.toggleClass('ui-tabs-collapsible', value);
          // Setting collapsible: false while collapsed; open first panel
          if (!value && this.options.active === false) {
            this._activate(0);
          }
        }
        if (key === 'event') {
          this._setupEvents(value);
        }
        if (key === 'heightStyle') {
          this._setupHeightStyle(value);
        }
      },
      _sanitizeSelector: function (hash) {
        return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, '\\$&') : '';
      },
      refresh: function () {
        var options = this.options, lis = this.tablist.children(':has(a[href])');
        // get disabled tabs from class attribute from HTML
        // this will get converted to a boolean if needed in _refresh()
        options.disabled = $.map(lis.filter('.ui-state-disabled'), function (tab) {
          return lis.index(tab);
        });
        this._processTabs();
        // was collapsed or no tabs
        if (options.active === false || !this.anchors.length) {
          options.active = false;
          this.active = $();  // was active, but active tab is gone
        } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
          // all remaining tabs are disabled
          if (this.tabs.length === options.disabled.length) {
            options.active = false;
            this.active = $();  // activate previous tab
          } else {
            this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
          }  // was active, active tab still exists
        } else {
          // make sure active index is correct
          options.active = this.tabs.index(this.active);
        }
        this._refresh();
      },
      _refresh: function () {
        this._setupDisabled(this.options.disabled);
        this._setupEvents(this.options.event);
        this._setupHeightStyle(this.options.heightStyle);
        this.tabs.not(this.active).attr({
          'aria-selected': 'false',
          'aria-expanded': 'false',
          tabIndex: -1
        });
        this.panels.not(this._getPanelForTab(this.active)).hide().attr({ 'aria-hidden': 'true' });
        // Make sure one tab is in the tab order
        if (!this.active.length) {
          this.tabs.eq(0).attr('tabIndex', 0);
        } else {
          this.active.addClass('ui-tabs-active ui-state-active').attr({
            'aria-selected': 'true',
            'aria-expanded': 'true',
            tabIndex: 0
          });
          this._getPanelForTab(this.active).show().attr({ 'aria-hidden': 'false' });
        }
      },
      _processTabs: function () {
        var that = this, prevTabs = this.tabs, prevAnchors = this.anchors, prevPanels = this.panels;
        this.tablist = this._getList().addClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all').attr('role', 'tablist').delegate('> li', 'mousedown' + this.eventNamespace, function (event) {
          if ($(this).is('.ui-state-disabled')) {
            event.preventDefault();
          }
        }).delegate('.ui-tabs-anchor', 'focus' + this.eventNamespace, function () {
          if ($(this).closest('li').is('.ui-state-disabled')) {
            this.blur();
          }
        });
        this.tabs = this.tablist.find('> li:has(a[href])').addClass('ui-state-default ui-corner-top').attr({
          role: 'tab',
          tabIndex: -1
        });
        this.anchors = this.tabs.map(function () {
          return $('a', this)[0];
        }).addClass('ui-tabs-anchor').attr({
          role: 'presentation',
          tabIndex: -1
        });
        this.panels = $();
        this.anchors.each(function (i, anchor) {
          var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr('id'), tab = $(anchor).closest('li'), originalAriaControls = tab.attr('aria-controls');
          // inline tab
          if (that._isLocal(anchor)) {
            selector = anchor.hash;
            panelId = selector.substring(1);
            panel = that.element.find(that._sanitizeSelector(selector));  // remote tab
          } else {
            // If the tab doesn't already have aria-controls,
            // generate an id by using a throw-away element
            panelId = tab.attr('aria-controls') || $({}).uniqueId()[0].id;
            selector = '#' + panelId;
            panel = that.element.find(selector);
            if (!panel.length) {
              panel = that._createPanel(panelId);
              panel.insertAfter(that.panels[i - 1] || that.tablist);
            }
            panel.attr('aria-live', 'polite');
          }
          if (panel.length) {
            that.panels = that.panels.add(panel);
          }
          if (originalAriaControls) {
            tab.data('ui-tabs-aria-controls', originalAriaControls);
          }
          tab.attr({
            'aria-controls': panelId,
            'aria-labelledby': anchorId
          });
          panel.attr('aria-labelledby', anchorId);
        });
        this.panels.addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').attr('role', 'tabpanel');
        // Avoid memory leaks (#10056)
        if (prevTabs) {
          this._off(prevTabs.not(this.tabs));
          this._off(prevAnchors.not(this.anchors));
          this._off(prevPanels.not(this.panels));
        }
      },
      _getList: function () {
        return this.tablist || this.element.find('ol,ul').eq(0);
      },
      _createPanel: function (id) {
        return $('<div>').attr('id', id).addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').data('ui-tabs-destroy', true);
      },
      _setupDisabled: function (disabled) {
        if ($.isArray(disabled)) {
          if (!disabled.length) {
            disabled = false;
          } else if (disabled.length === this.anchors.length) {
            disabled = true;
          }
        }
        // disable tabs
        for (var i = 0, li; li = this.tabs[i]; i++) {
          if (disabled === true || $.inArray(i, disabled) !== -1) {
            $(li).addClass('ui-state-disabled').attr('aria-disabled', 'true');
          } else {
            $(li).removeClass('ui-state-disabled').removeAttr('aria-disabled');
          }
        }
        this.options.disabled = disabled;
      },
      _setupEvents: function (event) {
        var events = {};
        if (event) {
          $.each(event.split(' '), function (index, eventName) {
            events[eventName] = '_eventHandler';
          });
        }
        this._off(this.anchors.add(this.tabs).add(this.panels));
        // Always prevent the default action, even when disabled
        this._on(true, this.anchors, {
          click: function (event) {
            event.preventDefault();
          }
        });
        this._on(this.anchors, events);
        this._on(this.tabs, { keydown: '_tabKeydown' });
        this._on(this.panels, { keydown: '_panelKeydown' });
        this._focusable(this.tabs);
        this._hoverable(this.tabs);
      },
      _setupHeightStyle: function (heightStyle) {
        var maxHeight, parent = this.element.parent();
        if (heightStyle === 'fill') {
          maxHeight = parent.height();
          maxHeight -= this.element.outerHeight() - this.element.height();
          this.element.siblings(':visible').each(function () {
            var elem = $(this), position = elem.css('position');
            if (position === 'absolute' || position === 'fixed') {
              return;
            }
            maxHeight -= elem.outerHeight(true);
          });
          this.element.children().not(this.panels).each(function () {
            maxHeight -= $(this).outerHeight(true);
          });
          this.panels.each(function () {
            $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
          }).css('overflow', 'auto');
        } else if (heightStyle === 'auto') {
          maxHeight = 0;
          this.panels.each(function () {
            maxHeight = Math.max(maxHeight, $(this).height('').height());
          }).height(maxHeight);
        }
      },
      _eventHandler: function (event) {
        var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest('li'), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
            oldTab: active,
            oldPanel: toHide,
            newTab: collapsing ? $() : tab,
            newPanel: toShow
          };
        event.preventDefault();
        if (tab.hasClass('ui-state-disabled') || tab.hasClass('ui-tabs-loading') || this.running || clickedIsActive && !options.collapsible || this._trigger('beforeActivate', event, eventData) === false) {
          return;
        }
        options.active = collapsing ? false : this.tabs.index(tab);
        this.active = clickedIsActive ? $() : tab;
        if (this.xhr) {
          this.xhr.abort();
        }
        if (!toHide.length && !toShow.length) {
          $.error('jQuery UI Tabs: Mismatching fragment identifier.');
        }
        if (toShow.length) {
          this.load(this.tabs.index(tab), event);
        }
        this._toggle(event, eventData);
      },
      _toggle: function (event, eventData) {
        var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
        this.running = true;
        function complete() {
          that.running = false;
          that._trigger('activate', event, eventData);
        }
        function show() {
          eventData.newTab.closest('li').addClass('ui-tabs-active ui-state-active');
          if (toShow.length && that.options.show) {
            that._show(toShow, that.options.show, complete);
          } else {
            toShow.show();
            complete();
          }
        }
        // start out by hiding, then showing, then completing
        if (toHide.length && this.options.hide) {
          this._hide(toHide, this.options.hide, function () {
            eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
            show();
          });
        } else {
          eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
          toHide.hide();
          show();
        }
        toHide.attr('aria-hidden', 'true');
        eventData.oldTab.attr({
          'aria-selected': 'false',
          'aria-expanded': 'false'
        });
        // If we're switching tabs, remove the old tab from the tab order.
        // If we're opening from collapsed state, remove the previous tab from the tab order.
        // If we're collapsing, then keep the collapsing tab in the tab order.
        if (toShow.length && toHide.length) {
          eventData.oldTab.attr('tabIndex', -1);
        } else if (toShow.length) {
          this.tabs.filter(function () {
            return $(this).attr('tabIndex') === 0;
          }).attr('tabIndex', -1);
        }
        toShow.attr('aria-hidden', 'false');
        eventData.newTab.attr({
          'aria-selected': 'true',
          'aria-expanded': 'true',
          tabIndex: 0
        });
      },
      _activate: function (index) {
        var anchor, active = this._findActive(index);
        // trying to activate the already active panel
        if (active[0] === this.active[0]) {
          return;
        }
        // trying to collapse, simulate a click on the current active header
        if (!active.length) {
          active = this.active;
        }
        anchor = active.find('.ui-tabs-anchor')[0];
        this._eventHandler({
          target: anchor,
          currentTarget: anchor,
          preventDefault: $.noop
        });
      },
      _findActive: function (index) {
        return index === false ? $() : this.tabs.eq(index);
      },
      _getIndex: function (index) {
        // meta-function to give users option to provide a href string instead of a numerical index.
        if (typeof index === 'string') {
          index = this.anchors.index(this.anchors.filter('[href$=\'' + index + '\']'));
        }
        return index;
      },
      _destroy: function () {
        if (this.xhr) {
          this.xhr.abort();
        }
        this.element.removeClass('ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible');
        this.tablist.removeClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all').removeAttr('role');
        this.anchors.removeClass('ui-tabs-anchor').removeAttr('role').removeAttr('tabIndex').removeUniqueId();
        this.tablist.unbind(this.eventNamespace);
        this.tabs.add(this.panels).each(function () {
          if ($.data(this, 'ui-tabs-destroy')) {
            $(this).remove();
          } else {
            $(this).removeClass('ui-state-default ui-state-active ui-state-disabled ' + 'ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel').removeAttr('tabIndex').removeAttr('aria-live').removeAttr('aria-busy').removeAttr('aria-selected').removeAttr('aria-labelledby').removeAttr('aria-hidden').removeAttr('aria-expanded').removeAttr('role');
          }
        });
        this.tabs.each(function () {
          var li = $(this), prev = li.data('ui-tabs-aria-controls');
          if (prev) {
            li.attr('aria-controls', prev).removeData('ui-tabs-aria-controls');
          } else {
            li.removeAttr('aria-controls');
          }
        });
        this.panels.show();
        if (this.options.heightStyle !== 'content') {
          this.panels.css('height', '');
        }
      },
      enable: function (index) {
        var disabled = this.options.disabled;
        if (disabled === false) {
          return;
        }
        if (index === undefined) {
          disabled = false;
        } else {
          index = this._getIndex(index);
          if ($.isArray(disabled)) {
            disabled = $.map(disabled, function (num) {
              return num !== index ? num : null;
            });
          } else {
            disabled = $.map(this.tabs, function (li, num) {
              return num !== index ? num : null;
            });
          }
        }
        this._setupDisabled(disabled);
      },
      disable: function (index) {
        var disabled = this.options.disabled;
        if (disabled === true) {
          return;
        }
        if (index === undefined) {
          disabled = true;
        } else {
          index = this._getIndex(index);
          if ($.inArray(index, disabled) !== -1) {
            return;
          }
          if ($.isArray(disabled)) {
            disabled = $.merge([index], disabled).sort();
          } else {
            disabled = [index];
          }
        }
        this._setupDisabled(disabled);
      },
      load: function (index, event) {
        index = this._getIndex(index);
        var that = this, tab = this.tabs.eq(index), anchor = tab.find('.ui-tabs-anchor'), panel = this._getPanelForTab(tab), eventData = {
            tab: tab,
            panel: panel
          }, complete = function (jqXHR, status) {
            if (status === 'abort') {
              that.panels.stop(false, true);
            }
            tab.removeClass('ui-tabs-loading');
            panel.removeAttr('aria-busy');
            if (jqXHR === that.xhr) {
              delete that.xhr;
            }
          };
        // not remote
        if (this._isLocal(anchor[0])) {
          return;
        }
        this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
        // support: jQuery <1.8
        // jQuery <1.8 returns false if the request is canceled in beforeSend,
        // but as of 1.8, $.ajax() always returns a jqXHR object.
        if (this.xhr && this.xhr.statusText !== 'canceled') {
          tab.addClass('ui-tabs-loading');
          panel.attr('aria-busy', 'true');
          this.xhr.done(function (response, status, jqXHR) {
            // support: jQuery <1.8
            // http://bugs.jquery.com/ticket/11778
            setTimeout(function () {
              panel.html(response);
              that._trigger('load', event, eventData);
              complete(jqXHR, status);
            }, 1);
          }).fail(function (jqXHR, status) {
            // support: jQuery <1.8
            // http://bugs.jquery.com/ticket/11778
            setTimeout(function () {
              complete(jqXHR, status);
            }, 1);
          });
        }
      },
      _ajaxSettings: function (anchor, event, eventData) {
        var that = this;
        return {
          url: anchor.attr('href'),
          beforeSend: function (jqXHR, settings) {
            return that._trigger('beforeLoad', event, $.extend({
              jqXHR: jqXHR,
              ajaxSettings: settings
            }, eventData));
          }
        };
      },
      _getPanelForTab: function (tab) {
        var id = $(tab).attr('aria-controls');
        return this.element.find(this._sanitizeSelector('#' + id));
      }
    });
  /*!
 * jQuery UI Tooltip 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tooltip/
 */
  var tooltip = $.widget('ui.tooltip', {
      version: '1.11.4',
      options: {
        content: function () {
          // support: IE<9, Opera in jQuery <1.7
          // .text() can't accept undefined, so coerce to a string
          var title = $(this).attr('title') || '';
          // Escape title, since we're going from an attribute to raw HTML
          return $('<a>').text(title).html();
        },
        hide: true,
        items: '[title]:not([disabled])',
        position: {
          my: 'left top+15',
          at: 'left bottom',
          collision: 'flipfit flip'
        },
        show: true,
        tooltipClass: null,
        track: false,
        close: null,
        open: null
      },
      _addDescribedBy: function (elem, id) {
        var describedby = (elem.attr('aria-describedby') || '').split(/\s+/);
        describedby.push(id);
        elem.data('ui-tooltip-id', id).attr('aria-describedby', $.trim(describedby.join(' ')));
      },
      _removeDescribedBy: function (elem) {
        var id = elem.data('ui-tooltip-id'), describedby = (elem.attr('aria-describedby') || '').split(/\s+/), index = $.inArray(id, describedby);
        if (index !== -1) {
          describedby.splice(index, 1);
        }
        elem.removeData('ui-tooltip-id');
        describedby = $.trim(describedby.join(' '));
        if (describedby) {
          elem.attr('aria-describedby', describedby);
        } else {
          elem.removeAttr('aria-describedby');
        }
      },
      _create: function () {
        this._on({
          mouseover: 'open',
          focusin: 'open'
        });
        // IDs of generated tooltips, needed for destroy
        this.tooltips = {};
        // IDs of parent tooltips where we removed the title attribute
        this.parents = {};
        if (this.options.disabled) {
          this._disable();
        }
        // Append the aria-live region so tooltips announce correctly
        this.liveRegion = $('<div>').attr({
          role: 'log',
          'aria-live': 'assertive',
          'aria-relevant': 'additions'
        }).addClass('ui-helper-hidden-accessible').appendTo(this.document[0].body);
      },
      _setOption: function (key, value) {
        var that = this;
        if (key === 'disabled') {
          this[value ? '_disable' : '_enable']();
          this.options[key] = value;
          // disable element style changes
          return;
        }
        this._super(key, value);
        if (key === 'content') {
          $.each(this.tooltips, function (id, tooltipData) {
            that._updateContent(tooltipData.element);
          });
        }
      },
      _disable: function () {
        var that = this;
        // close open tooltips
        $.each(this.tooltips, function (id, tooltipData) {
          var event = $.Event('blur');
          event.target = event.currentTarget = tooltipData.element[0];
          that.close(event, true);
        });
        // remove title attributes to prevent native tooltips
        this.element.find(this.options.items).addBack().each(function () {
          var element = $(this);
          if (element.is('[title]')) {
            element.data('ui-tooltip-title', element.attr('title')).removeAttr('title');
          }
        });
      },
      _enable: function () {
        // restore title attributes
        this.element.find(this.options.items).addBack().each(function () {
          var element = $(this);
          if (element.data('ui-tooltip-title')) {
            element.attr('title', element.data('ui-tooltip-title'));
          }
        });
      },
      open: function (event) {
        var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
        // No element to show a tooltip for or the tooltip is already open
        if (!target.length || target.data('ui-tooltip-id')) {
          return;
        }
        if (target.attr('title')) {
          target.data('ui-tooltip-title', target.attr('title'));
        }
        target.data('ui-tooltip-open', true);
        // kill parent tooltips, custom or native, for hover
        if (event && event.type === 'mouseover') {
          target.parents().each(function () {
            var parent = $(this), blurEvent;
            if (parent.data('ui-tooltip-open')) {
              blurEvent = $.Event('blur');
              blurEvent.target = blurEvent.currentTarget = this;
              that.close(blurEvent, true);
            }
            if (parent.attr('title')) {
              parent.uniqueId();
              that.parents[this.id] = {
                element: this,
                title: parent.attr('title')
              };
              parent.attr('title', '');
            }
          });
        }
        this._registerCloseHandlers(event, target);
        this._updateContent(target, event);
      },
      _updateContent: function (target, event) {
        var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
        if (typeof contentOption === 'string') {
          return this._open(event, target, contentOption);
        }
        content = contentOption.call(target[0], function (response) {
          // IE may instantly serve a cached response for ajax requests
          // delay this call to _open so the other call to _open runs first
          that._delay(function () {
            // Ignore async response if tooltip was closed already
            if (!target.data('ui-tooltip-open')) {
              return;
            }
            // jQuery creates a special event for focusin when it doesn't
            // exist natively. To improve performance, the native event
            // object is reused and the type is changed. Therefore, we can't
            // rely on the type being correct after the event finished
            // bubbling, so we set it back to the previous value. (#8740)
            if (event) {
              event.type = eventType;
            }
            this._open(event, target, response);
          });
        });
        if (content) {
          this._open(event, target, content);
        }
      },
      _open: function (event, target, content) {
        var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend({}, this.options.position);
        if (!content) {
          return;
        }
        // Content can be updated multiple times. If the tooltip already
        // exists, then just update the content and bail.
        tooltipData = this._find(target);
        if (tooltipData) {
          tooltipData.tooltip.find('.ui-tooltip-content').html(content);
          return;
        }
        // if we have a title, clear it to prevent the native tooltip
        // we have to check first to avoid defining a title if none exists
        // (we don't want to cause an element to start matching [title])
        //
        // We use removeAttr only for key events, to allow IE to export the correct
        // accessible attributes. For mouse events, set to empty string to avoid
        // native tooltip showing up (happens only when removing inside mouseover).
        if (target.is('[title]')) {
          if (event && event.type === 'mouseover') {
            target.attr('title', '');
          } else {
            target.removeAttr('title');
          }
        }
        tooltipData = this._tooltip(target);
        tooltip = tooltipData.tooltip;
        this._addDescribedBy(target, tooltip.attr('id'));
        tooltip.find('.ui-tooltip-content').html(content);
        // Support: Voiceover on OS X, JAWS on IE <= 9
        // JAWS announces deletions even when aria-relevant="additions"
        // Voiceover will sometimes re-read the entire log region's contents from the beginning
        this.liveRegion.children().hide();
        if (content.clone) {
          a11yContent = content.clone();
          a11yContent.removeAttr('id').find('[id]').removeAttr('id');
        } else {
          a11yContent = content;
        }
        $('<div>').html(a11yContent).appendTo(this.liveRegion);
        function position(event) {
          positionOption.of = event;
          if (tooltip.is(':hidden')) {
            return;
          }
          tooltip.position(positionOption);
        }
        if (this.options.track && event && /^mouse/.test(event.type)) {
          this._on(this.document, { mousemove: position });
          // trigger once to override element-relative positioning
          position(event);
        } else {
          tooltip.position($.extend({ of: target }, this.options.position));
        }
        tooltip.hide();
        this._show(tooltip, this.options.show);
        // Handle tracking tooltips that are shown with a delay (#8644). As soon
        // as the tooltip is visible, position the tooltip using the most recent
        // event.
        if (this.options.show && this.options.show.delay) {
          delayedShow = this.delayedShow = setInterval(function () {
            if (tooltip.is(':visible')) {
              position(positionOption.of);
              clearInterval(delayedShow);
            }
          }, $.fx.interval);
        }
        this._trigger('open', event, { tooltip: tooltip });
      },
      _registerCloseHandlers: function (event, target) {
        var events = {
            keyup: function (event) {
              if (event.keyCode === $.ui.keyCode.ESCAPE) {
                var fakeEvent = $.Event(event);
                fakeEvent.currentTarget = target[0];
                this.close(fakeEvent, true);
              }
            }
          };
        // Only bind remove handler for delegated targets. Non-delegated
        // tooltips will handle this in destroy.
        if (target[0] !== this.element[0]) {
          events.remove = function () {
            this._removeTooltip(this._find(target).tooltip);
          };
        }
        if (!event || event.type === 'mouseover') {
          events.mouseleave = 'close';
        }
        if (!event || event.type === 'focusin') {
          events.focusout = 'close';
        }
        this._on(true, target, events);
      },
      close: function (event) {
        var tooltip, that = this, target = $(event ? event.currentTarget : this.element), tooltipData = this._find(target);
        // The tooltip may already be closed
        if (!tooltipData) {
          // We set ui-tooltip-open immediately upon open (in open()), but only set the
          // additional data once there's actually content to show (in _open()). So even if the
          // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
          // the period between open() and _open().
          target.removeData('ui-tooltip-open');
          return;
        }
        tooltip = tooltipData.tooltip;
        // disabling closes the tooltip, so we need to track when we're closing
        // to avoid an infinite loop in case the tooltip becomes disabled on close
        if (tooltipData.closing) {
          return;
        }
        // Clear the interval for delayed tracking tooltips
        clearInterval(this.delayedShow);
        // only set title if we had one before (see comment in _open())
        // If the title attribute has changed since open(), don't restore
        if (target.data('ui-tooltip-title') && !target.attr('title')) {
          target.attr('title', target.data('ui-tooltip-title'));
        }
        this._removeDescribedBy(target);
        tooltipData.hiding = true;
        tooltip.stop(true);
        this._hide(tooltip, this.options.hide, function () {
          that._removeTooltip($(this));
        });
        target.removeData('ui-tooltip-open');
        this._off(target, 'mouseleave focusout keyup');
        // Remove 'remove' binding only on delegated targets
        if (target[0] !== this.element[0]) {
          this._off(target, 'remove');
        }
        this._off(this.document, 'mousemove');
        if (event && event.type === 'mouseleave') {
          $.each(this.parents, function (id, parent) {
            $(parent.element).attr('title', parent.title);
            delete that.parents[id];
          });
        }
        tooltipData.closing = true;
        this._trigger('close', event, { tooltip: tooltip });
        if (!tooltipData.hiding) {
          tooltipData.closing = false;
        }
      },
      _tooltip: function (element) {
        var tooltip = $('<div>').attr('role', 'tooltip').addClass('ui-tooltip ui-widget ui-corner-all ui-widget-content ' + (this.options.tooltipClass || '')), id = tooltip.uniqueId().attr('id');
        $('<div>').addClass('ui-tooltip-content').appendTo(tooltip);
        tooltip.appendTo(this.document[0].body);
        return this.tooltips[id] = {
          element: element,
          tooltip: tooltip
        };
      },
      _find: function (target) {
        var id = target.data('ui-tooltip-id');
        return id ? this.tooltips[id] : null;
      },
      _removeTooltip: function (tooltip) {
        tooltip.remove();
        delete this.tooltips[tooltip.attr('id')];
      },
      _destroy: function () {
        var that = this;
        // close open tooltips
        $.each(this.tooltips, function (id, tooltipData) {
          // Delegate to close method to handle common cleanup
          var event = $.Event('blur'), element = tooltipData.element;
          event.target = event.currentTarget = element[0];
          that.close(event, true);
          // Remove immediately; destroying an open tooltip doesn't use the
          // hide animation
          $('#' + id).remove();
          // Restore the title
          if (element.data('ui-tooltip-title')) {
            // If the title attribute has changed since open(), don't restore
            if (!element.attr('title')) {
              element.attr('title', element.data('ui-tooltip-title'));
            }
            element.removeData('ui-tooltip-title');
          }
        });
        this.liveRegion.remove();
      }
    });
}));/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 2011–2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
(function ($) {
  // Detect touch support
  $.support.touch = 'ontouchend' in document;
  // Ignore browsers without touch support
  if (!$.support.touch) {
    return;
  }
  var mouseProto = $.ui.mouse.prototype, _mouseInit = mouseProto._mouseInit, _mouseDestroy = mouseProto._mouseDestroy, touchHandled;
  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
  function simulateMouseEvent(event, simulatedType) {
    // Ignore multi-touch events
    if (event.originalEvent.touches.length > 1) {
      return;
    }
    event.preventDefault();
    var touch = event.originalEvent.changedTouches[0], simulatedEvent = document.createEvent('MouseEvents');
    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(simulatedType, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    // Dispatch the simulated event to the target element
    event.target.dispatchEvent(simulatedEvent);
  }
  /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
  mouseProto._touchStart = function (event) {
    var self = this;
    // Ignore the event if another widget is already being handled
    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
      return;
    }
    // Set the flag to prevent other widgets from inheriting the touch event
    touchHandled = true;
    // Track movement to determine if interaction was a click
    self._touchMoved = false;
    // Simulate the mouseover event
    simulateMouseEvent(event, 'mouseover');
    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');
    // Simulate the mousedown event
    simulateMouseEvent(event, 'mousedown');
  };
  /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
  mouseProto._touchMove = function (event) {
    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }
    // Interaction was not a click
    this._touchMoved = true;
    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');
  };
  /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
  mouseProto._touchEnd = function (event) {
    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }
    // Simulate the mouseup event
    simulateMouseEvent(event, 'mouseup');
    // Simulate the mouseout event
    simulateMouseEvent(event, 'mouseout');
    // If the touch interaction did not move, it should trigger a click
    if (!this._touchMoved) {
      // Simulate the click event
      simulateMouseEvent(event, 'click');
    }
    // Unset the flag to allow other widgets to inherit the touch event
    touchHandled = false;
  };
  /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
  mouseProto._mouseInit = function () {
    var self = this;
    // Delegate the touch handlers to the widget's element
    self.element.bind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });
    // Call the original $.ui.mouse init method
    _mouseInit.call(self);
  };
  /**
   * Remove the touch event handlers
   */
  mouseProto._mouseDestroy = function () {
    var self = this;
    // Delegate the touch handlers to the widget's element
    self.element.unbind({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });
    // Call the original $.ui.mouse destroy method
    _mouseDestroy.call(self);
  };
}(jQuery));/*!
 * Bootstrap v3.3.4 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery');
}
+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.');
  if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher');
  }
}(jQuery);
/* ========================================================================
 * Bootstrap: transition.js v3.3.4
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================
  function transitionEnd() {
    var el = document.createElement('bootstrap');
    var transEndEventNames = {
        WebkitTransition: 'webkitTransitionEnd',
        MozTransition: 'transitionend',
        OTransition: 'oTransitionEnd otransitionend',
        transition: 'transitionend'
      };
    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] };
      }
    }
    return false;
  }
  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false;
    var $el = this;
    $(this).one('bsTransitionEnd', function () {
      called = true;
    });
    var callback = function () {
      if (!called)
        $($el).trigger($.support.transition.end);
    };
    setTimeout(callback, duration);
    return this;
  };
  $(function () {
    $.support.transition = transitionEnd();
    if (!$.support.transition)
      return;
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this))
          return e.handleObj.handler.apply(this, arguments);
      }
    };
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: alert.js v3.3.4
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // ALERT CLASS DEFINITION
  // ======================
  var dismiss = '[data-dismiss="alert"]';
  var Alert = function (el) {
    $(el).on('click', dismiss, this.close);
  };
  Alert.VERSION = '3.3.4';
  Alert.TRANSITION_DURATION = 150;
  Alert.prototype.close = function (e) {
    var $this = $(this);
    var selector = $this.attr('data-target');
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    var $parent = $(selector);
    if (e)
      e.preventDefault();
    if (!$parent.length) {
      $parent = $this.closest('.alert');
    }
    $parent.trigger(e = $.Event('close.bs.alert'));
    if (e.isDefaultPrevented())
      return;
    $parent.removeClass('in');
    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove();
    }
    $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
  };
  // ALERT PLUGIN DEFINITION
  // =======================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.alert');
      if (!data)
        $this.data('bs.alert', data = new Alert(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  }
  var old = $.fn.alert;
  $.fn.alert = Plugin;
  $.fn.alert.Constructor = Alert;
  // ALERT NO CONFLICT
  // =================
  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  };
  // ALERT DATA-API
  // ==============
  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
}(jQuery);
/* ========================================================================
 * Bootstrap: button.js v3.3.4
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================
  var Button = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Button.DEFAULTS, options);
    this.isLoading = false;
  };
  Button.VERSION = '3.3.4';
  Button.DEFAULTS = { loadingText: 'loading...' };
  Button.prototype.setState = function (state) {
    var d = 'disabled';
    var $el = this.$element;
    var val = $el.is('input') ? 'val' : 'html';
    var data = $el.data();
    state = state + 'Text';
    if (data.resetText == null)
      $el.data('resetText', $el[val]());
    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state]);
      if (state == 'loadingText') {
        this.isLoading = true;
        $el.addClass(d).attr(d, d);
      } else if (this.isLoading) {
        this.isLoading = false;
        $el.removeClass(d).removeAttr(d);
      }
    }, this), 0);
  };
  Button.prototype.toggle = function () {
    var changed = true;
    var $parent = this.$element.closest('[data-toggle="buttons"]');
    if ($parent.length) {
      var $input = this.$element.find('input');
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active'))
          changed = false;
        else
          $parent.find('.active').removeClass('active');
      }
      if (changed)
        $input.prop('checked', !this.$element.hasClass('active')).trigger('change');
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
    }
    if (changed)
      this.$element.toggleClass('active');
  };
  // BUTTON PLUGIN DEFINITION
  // ========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.button');
      var options = typeof option == 'object' && option;
      if (!data)
        $this.data('bs.button', data = new Button(this, options));
      if (option == 'toggle')
        data.toggle();
      else if (option)
        data.setState(option);
    });
  }
  var old = $.fn.button;
  $.fn.button = Plugin;
  $.fn.button.Constructor = Button;
  // BUTTON NO CONFLICT
  // ==================
  $.fn.button.noConflict = function () {
    $.fn.button = old;
    return this;
  };
  // BUTTON DATA-API
  // ===============
  $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
    var $btn = $(e.target);
    if (!$btn.hasClass('btn'))
      $btn = $btn.closest('.btn');
    Plugin.call($btn, 'toggle');
    e.preventDefault();
  }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
    $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: carousel.js v3.3.4
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CAROUSEL CLASS DEFINITION
  // =========================
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.paused = null;
    this.sliding = null;
    this.interval = null;
    this.$active = null;
    this.$items = null;
    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));
    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
  };
  Carousel.VERSION = '3.3.4';
  Carousel.TRANSITION_DURATION = 600;
  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  };
  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName))
      return;
    switch (e.which) {
    case 37:
      this.prev();
      break;
    case 39:
      this.next();
      break;
    default:
      return;
    }
    e.preventDefault();
  };
  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false);
    this.interval && clearInterval(this.interval);
    this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
    return this;
  };
  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item');
    return this.$items.index(item || this.$active);
  };
  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active);
    var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
    if (willWrap && !this.options.wrap)
      return active;
    var delta = direction == 'prev' ? -1 : 1;
    var itemIndex = (activeIndex + delta) % this.$items.length;
    return this.$items.eq(itemIndex);
  };
  Carousel.prototype.to = function (pos) {
    var that = this;
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));
    if (pos > this.$items.length - 1 || pos < 0)
      return;
    if (this.sliding)
      return this.$element.one('slid.bs.carousel', function () {
        that.to(pos);
      });
    // yes, "slid"
    if (activeIndex == pos)
      return this.pause().cycle();
    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
  };
  Carousel.prototype.pause = function (e) {
    e || (this.paused = true);
    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end);
      this.cycle(true);
    }
    this.interval = clearInterval(this.interval);
    return this;
  };
  Carousel.prototype.next = function () {
    if (this.sliding)
      return;
    return this.slide('next');
  };
  Carousel.prototype.prev = function () {
    if (this.sliding)
      return;
    return this.slide('prev');
  };
  Carousel.prototype.slide = function (type, next) {
    var $active = this.$element.find('.item.active');
    var $next = next || this.getItemForDirection(type, $active);
    var isCycling = this.interval;
    var direction = type == 'next' ? 'left' : 'right';
    var that = this;
    if ($next.hasClass('active'))
      return this.sliding = false;
    var relatedTarget = $next[0];
    var slideEvent = $.Event('slide.bs.carousel', {
        relatedTarget: relatedTarget,
        direction: direction
      });
    this.$element.trigger(slideEvent);
    if (slideEvent.isDefaultPrevented())
      return;
    this.sliding = true;
    isCycling && this.pause();
    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active');
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
      $nextIndicator && $nextIndicator.addClass('active');
    }
    var slidEvent = $.Event('slid.bs.carousel', {
        relatedTarget: relatedTarget,
        direction: direction
      });
    // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type);
      $next[0].offsetWidth;
      // force reflow
      $active.addClass(direction);
      $next.addClass(direction);
      $active.one('bsTransitionEnd', function () {
        $next.removeClass([
          type,
          direction
        ].join(' ')).addClass('active');
        $active.removeClass([
          'active',
          direction
        ].join(' '));
        that.sliding = false;
        setTimeout(function () {
          that.$element.trigger(slidEvent);
        }, 0);
      }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
    } else {
      $active.removeClass('active');
      $next.addClass('active');
      this.sliding = false;
      this.$element.trigger(slidEvent);
    }
    isCycling && this.cycle();
    return this;
  };
  // CAROUSEL PLUGIN DEFINITION
  // ==========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.carousel');
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
      var action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('bs.carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  }
  var old = $.fn.carousel;
  $.fn.carousel = Plugin;
  $.fn.carousel.Constructor = Carousel;
  // CAROUSEL NO CONFLICT
  // ====================
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  // CAROUSEL DATA-API
  // =================
  var clickHandler = function (e) {
    var href;
    var $this = $(this);
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''));
    // strip for ie7
    if (!$target.hasClass('carousel'))
      return;
    var options = $.extend({}, $target.data(), $this.data());
    var slideIndex = $this.attr('data-slide-to');
    if (slideIndex)
      options.interval = false;
    Plugin.call($target, options);
    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex);
    }
    e.preventDefault();
  };
  $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);
  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this);
      Plugin.call($carousel, $carousel.data());
    });
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: collapse.js v3.3.4
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Collapse.DEFAULTS, options);
    this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
    this.transitioning = null;
    if (this.options.parent) {
      this.$parent = this.getParent();
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger);
    }
    if (this.options.toggle)
      this.toggle();
  };
  Collapse.VERSION = '3.3.4';
  Collapse.TRANSITION_DURATION = 350;
  Collapse.DEFAULTS = { toggle: true };
  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width');
    return hasWidth ? 'width' : 'height';
  };
  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in'))
      return;
    var activesData;
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');
    if (actives && actives.length) {
      activesData = actives.data('bs.collapse');
      if (activesData && activesData.transitioning)
        return;
    }
    var startEvent = $.Event('show.bs.collapse');
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented())
      return;
    if (actives && actives.length) {
      Plugin.call(actives, 'hide');
      activesData || actives.data('bs.collapse', null);
    }
    var dimension = this.dimension();
    this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);
    this.$trigger.removeClass('collapsed').attr('aria-expanded', true);
    this.transitioning = 1;
    var complete = function () {
      this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
      this.transitioning = 0;
      this.$element.trigger('shown.bs.collapse');
    };
    if (!$.support.transition)
      return complete.call(this);
    var scrollSize = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
    this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
  };
  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in'))
      return;
    var startEvent = $.Event('hide.bs.collapse');
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented())
      return;
    var dimension = this.dimension();
    this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
    this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);
    this.$trigger.addClass('collapsed').attr('aria-expanded', false);
    this.transitioning = 1;
    var complete = function () {
      this.transitioning = 0;
      this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
    };
    if (!$.support.transition)
      return complete.call(this);
    this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
  };
  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']();
  };
  Collapse.prototype.getParent = function () {
    return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
      var $element = $(element);
      this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
    }, this)).end();
  };
  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in');
    $element.attr('aria-expanded', isOpen);
    $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
  };
  function getTargetFromTrigger($trigger) {
    var href;
    var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '');
    // strip for ie7
    return $(target);
  }
  // COLLAPSE PLUGIN DEFINITION
  // ==========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.collapse');
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);
      if (!data && options.toggle && /show|hide/.test(option))
        options.toggle = false;
      if (!data)
        $this.data('bs.collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  }
  var old = $.fn.collapse;
  $.fn.collapse = Plugin;
  $.fn.collapse.Constructor = Collapse;
  // COLLAPSE NO CONFLICT
  // ====================
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  // COLLAPSE DATA-API
  // =================
  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this = $(this);
    if (!$this.attr('data-target'))
      e.preventDefault();
    var $target = getTargetFromTrigger($this);
    var data = $target.data('bs.collapse');
    var option = data ? 'toggle' : $this.data();
    Plugin.call($target, option);
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.4
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // DROPDOWN CLASS DEFINITION
  // =========================
  var backdrop = '.dropdown-backdrop';
  var toggle = '[data-toggle="dropdown"]';
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle);
  };
  Dropdown.VERSION = '3.3.4';
  Dropdown.prototype.toggle = function (e) {
    var $this = $(this);
    if ($this.is('.disabled, :disabled'))
      return;
    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');
    clearMenus();
    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus);
      }
      var relatedTarget = { relatedTarget: this };
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
      if (e.isDefaultPrevented())
        return;
      $this.trigger('focus').attr('aria-expanded', 'true');
      $parent.toggleClass('open').trigger('shown.bs.dropdown', relatedTarget);
    }
    return false;
  };
  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName))
      return;
    var $this = $(this);
    e.preventDefault();
    e.stopPropagation();
    if ($this.is('.disabled, :disabled'))
      return;
    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');
    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27)
        $parent.find(toggle).trigger('focus');
      return $this.trigger('click');
    }
    var desc = ' li:not(.disabled):visible a';
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc);
    if (!$items.length)
      return;
    var index = $items.index(e.target);
    if (e.which == 38 && index > 0)
      index--;
    // up
    if (e.which == 40 && index < $items.length - 1)
      index++;
    // down
    if (!~index)
      index = 0;
    $items.eq(index).trigger('focus');
  };
  function clearMenus(e) {
    if (e && e.which === 3)
      return;
    $(backdrop).remove();
    $(toggle).each(function () {
      var $this = $(this);
      var $parent = getParent($this);
      var relatedTarget = { relatedTarget: this };
      if (!$parent.hasClass('open'))
        return;
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
      if (e.isDefaultPrevented())
        return;
      $this.attr('aria-expanded', 'false');
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget);
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target');
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    var $parent = selector && $(selector);
    return $parent && $parent.length ? $parent : $this.parent();
  }
  // DROPDOWN PLUGIN DEFINITION
  // ==========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.dropdown');
      if (!data)
        $this.data('bs.dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  }
  var old = $.fn.dropdown;
  $.fn.dropdown = Plugin;
  $.fn.dropdown.Constructor = Dropdown;
  // DROPDOWN NO CONFLICT
  // ====================
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================
  $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown);
}(jQuery);
/* ========================================================================
 * Bootstrap: modal.js v3.3.4
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // MODAL CLASS DEFINITION
  // ======================
  var Modal = function (element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find('.modal-dialog');
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;
    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };
  Modal.VERSION = '3.3.4';
  Modal.TRANSITION_DURATION = 300;
  Modal.BACKDROP_TRANSITION_DURATION = 150;
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };
  Modal.prototype.show = function (_relatedTarget) {
    var that = this;
    var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });
    this.$element.trigger(e);
    if (this.isShown || e.isDefaultPrevented())
      return;
    this.isShown = true;
    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass('modal-open');
    this.escape();
    this.resize();
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element))
          that.ignoreBackdropClick = true;
      });
    });
    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');
      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body);
      }
      that.$element.show().scrollTop(0);
      that.adjustDialog();
      if (transition) {
        that.$element[0].offsetWidth;
      }
      that.$element.addClass('in').attr('aria-hidden', false);
      that.enforceFocus();
      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });
      transition ? that.$dialog.one('bsTransitionEnd', function () {
        that.$element.trigger('focus').trigger(e);
      }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
    });
  };
  Modal.prototype.hide = function (e) {
    if (e)
      e.preventDefault();
    e = $.Event('hide.bs.modal');
    this.$element.trigger(e);
    if (!this.isShown || e.isDefaultPrevented())
      return;
    this.isShown = false;
    this.escape();
    this.resize();
    $(document).off('focusin.bs.modal');
    this.$element.removeClass('in').attr('aria-hidden', true).off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
    this.$dialog.off('mousedown.dismiss.bs.modal');
    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
  };
  Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function (e) {
      if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
        this.$element.trigger('focus');
      }
    }, this));
  };
  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal');
    }
  };
  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
    } else {
      $(window).off('resize.bs.modal');
    }
  };
  Modal.prototype.hideModal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass('modal-open');
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger('hidden.bs.modal');
    });
  };
  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };
  Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass('fade') ? 'fade' : '';
    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;
      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(this.$body);
      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }
        if (e.target !== e.currentTarget)
          return;
        this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
      }, this));
      if (doAnimate)
        this.$backdrop[0].offsetWidth;
      // force reflow
      this.$backdrop.addClass('in');
      if (!callback)
        return;
      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in');
      var callbackRemove = function () {
        that.removeBackdrop();
        callback && callback();
      };
      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
    } else if (callback) {
      callback();
    }
  };
  // these following methods are used to handle overflowing modals
  Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };
  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    });
  };
  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    });
  };
  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;
    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect();
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };
  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || '';
    if (this.bodyIsOverflowing)
      this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
  };
  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad);
  };
  Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement('div');
    scrollDiv.className = 'modal-scrollbar-measure';
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  };
  // MODAL PLUGIN DEFINITION
  // =======================
  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('bs.modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option](_relatedTarget);
      else if (options.show)
        data.show(_relatedTarget);
    });
  }
  var old = $.fn.modal;
  $.fn.modal = Plugin;
  $.fn.modal.Constructor = Modal;
  // MODAL NO CONFLICT
  // =================
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  // MODAL DATA-API
  // ==============
  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this);
    var href = $this.attr('href');
    var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, ''));
    // strip for ie7
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    if ($this.is('a'))
      e.preventDefault();
    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented())
        return;
      // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus');
      });
    });
    Plugin.call($target, option, this);
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.4
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================
  var Tooltip = function (element, options) {
    this.type = null;
    this.options = null;
    this.enabled = null;
    this.timeout = null;
    this.hoverState = null;
    this.$element = null;
    this.init('tooltip', element, options);
  };
  Tooltip.VERSION = '3.3.4';
  Tooltip.TRANSITION_DURATION = 150;
  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  };
  Tooltip.prototype.init = function (type, element, options) {
    this.enabled = true;
    this.type = type;
    this.$element = $(element);
    this.options = this.getOptions(options);
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);
    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
    }
    var triggers = this.options.trigger.split(' ');
    for (var i = triggers.length; i--;) {
      var trigger = triggers[i];
      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
      } else if (trigger != 'manual') {
        var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
      }
    }
    this.options.selector ? this._options = $.extend({}, this.options, {
      trigger: 'manual',
      selector: ''
    }) : this.fixTitle();
  };
  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS;
  };
  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options);
    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      };
    }
    return options;
  };
  Tooltip.prototype.getDelegateOptions = function () {
    var options = {};
    var defaults = this.getDefaults();
    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value)
        options[key] = value;
    });
    return options;
  };
  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in';
      return;
    }
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
      $(obj.currentTarget).data('bs.' + this.type, self);
    }
    clearTimeout(self.timeout);
    self.hoverState = 'in';
    if (!self.options.delay || !self.options.delay.show)
      return self.show();
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in')
        self.show();
    }, self.options.delay.show);
  };
  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
      $(obj.currentTarget).data('bs.' + this.type, self);
    }
    clearTimeout(self.timeout);
    self.hoverState = 'out';
    if (!self.options.delay || !self.options.delay.hide)
      return self.hide();
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out')
        self.hide();
    }, self.options.delay.hide);
  };
  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type);
    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e);
      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
      if (e.isDefaultPrevented() || !inDom)
        return;
      var that = this;
      var $tip = this.tip();
      var tipId = this.getUID(this.type);
      this.setContent();
      $tip.attr('id', tipId);
      this.$element.attr('aria-describedby', tipId);
      if (this.options.animation)
        $tip.addClass('fade');
      var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
      var autoToken = /\s?auto?\s?/i;
      var autoPlace = autoToken.test(placement);
      if (autoPlace)
        placement = placement.replace(autoToken, '') || 'top';
      $tip.detach().css({
        top: 0,
        left: 0,
        display: 'block'
      }).addClass(placement).data('bs.' + this.type, this);
      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
      var pos = this.getPosition();
      var actualWidth = $tip[0].offsetWidth;
      var actualHeight = $tip[0].offsetHeight;
      if (autoPlace) {
        var orgPlacement = placement;
        var $container = this.options.container ? $(this.options.container) : this.$element.parent();
        var containerDim = this.getPosition($container);
        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < containerDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > containerDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < containerDim.left ? 'right' : placement;
        $tip.removeClass(orgPlacement).addClass(placement);
      }
      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
      this.applyPlacement(calculatedOffset, placement);
      var complete = function () {
        var prevHoverState = that.hoverState;
        that.$element.trigger('shown.bs.' + that.type);
        that.hoverState = null;
        if (prevHoverState == 'out')
          that.leave(that);
      };
      $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
    }
  };
  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip = this.tip();
    var width = $tip[0].offsetWidth;
    var height = $tip[0].offsetHeight;
    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10);
    var marginLeft = parseInt($tip.css('margin-left'), 10);
    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))
      marginTop = 0;
    if (isNaN(marginLeft))
      marginLeft = 0;
    offset.top = offset.top + marginTop;
    offset.left = offset.left + marginLeft;
    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        });
      }
    }, offset), 0);
    $tip.addClass('in');
    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth = $tip[0].offsetWidth;
    var actualHeight = $tip[0].offsetHeight;
    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight;
    }
    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
    if (delta.left)
      offset.left += delta.left;
    else
      offset.top += delta.top;
    var isVertical = /top|bottom/.test(placement);
    var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
    $tip.offset(offset);
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
  };
  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
  };
  Tooltip.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();
    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
    $tip.removeClass('fade in top bottom left right');
  };
  Tooltip.prototype.hide = function (callback) {
    var that = this;
    var $tip = $(this.$tip);
    var e = $.Event('hide.bs.' + this.type);
    function complete() {
      if (that.hoverState != 'in')
        $tip.detach();
      that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
      callback && callback();
    }
    this.$element.trigger(e);
    if (e.isDefaultPrevented())
      return;
    $tip.removeClass('in');
    $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
    this.hoverState = null;
    return this;
  };
  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element;
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
    }
  };
  Tooltip.prototype.hasContent = function () {
    return this.getTitle();
  };
  Tooltip.prototype.getPosition = function ($element) {
    $element = $element || this.$element;
    var el = $element[0];
    var isBody = el.tagName == 'BODY';
    var elRect = el.getBoundingClientRect();
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, {
        width: elRect.right - elRect.left,
        height: elRect.bottom - elRect.top
      });
    }
    var elOffset = isBody ? {
        top: 0,
        left: 0
      } : $element.offset();
    var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
    var outerDims = isBody ? {
        width: $(window).width(),
        height: $(window).height()
      } : null;
    return $.extend({}, elRect, scroll, outerDims, elOffset);
  };
  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? {
      top: pos.top + pos.height,
      left: pos.left + pos.width / 2 - actualWidth / 2
    } : placement == 'top' ? {
      top: pos.top - actualHeight,
      left: pos.left + pos.width / 2 - actualWidth / 2
    } : placement == 'left' ? {
      top: pos.top + pos.height / 2 - actualHeight / 2,
      left: pos.left - actualWidth
    } : {
      top: pos.top + pos.height / 2 - actualHeight / 2,
      left: pos.left + pos.width
    };
  };
  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = {
        top: 0,
        left: 0
      };
    if (!this.$viewport)
      return delta;
    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
    var viewportDimensions = this.getPosition(this.$viewport);
    if (/right|left/.test(placement)) {
      var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
      if (topEdgeOffset < viewportDimensions.top) {
        // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset;
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
        // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
      }
    } else {
      var leftEdgeOffset = pos.left - viewportPadding;
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
      if (leftEdgeOffset < viewportDimensions.left) {
        // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset;
      } else if (rightEdgeOffset > viewportDimensions.width) {
        // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
      }
    }
    return delta;
  };
  Tooltip.prototype.getTitle = function () {
    var title;
    var $e = this.$element;
    var o = this.options;
    title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
    return title;
  };
  Tooltip.prototype.getUID = function (prefix) {
    do
      prefix += ~~(Math.random() * 1000000);
    while (document.getElementById(prefix));
    return prefix;
  };
  Tooltip.prototype.tip = function () {
    return this.$tip = this.$tip || $(this.options.template);
  };
  Tooltip.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
  };
  Tooltip.prototype.enable = function () {
    this.enabled = true;
  };
  Tooltip.prototype.disable = function () {
    this.enabled = false;
  };
  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled;
  };
  Tooltip.prototype.toggle = function (e) {
    var self = this;
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type);
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions());
        $(e.currentTarget).data('bs.' + this.type, self);
      }
    }
    self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
  };
  Tooltip.prototype.destroy = function () {
    var that = this;
    clearTimeout(this.timeout);
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type);
    });
  };
  // TOOLTIP PLUGIN DEFINITION
  // =========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.tooltip');
      var options = typeof option == 'object' && option;
      if (!data && /destroy|hide/.test(option))
        return;
      if (!data)
        $this.data('bs.tooltip', data = new Tooltip(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  }
  var old = $.fn.tooltip;
  $.fn.tooltip = Plugin;
  $.fn.tooltip.Constructor = Tooltip;
  // TOOLTIP NO CONFLICT
  // ===================
  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old;
    return this;
  };
}(jQuery);
/* ========================================================================
 * Bootstrap: popover.js v3.3.4
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================
  var Popover = function (element, options) {
    this.init('popover', element, options);
  };
  if (!$.fn.tooltip)
    throw new Error('Popover requires tooltip.js');
  Popover.VERSION = '3.3.4';
  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  });
  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================
  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
  Popover.prototype.constructor = Popover;
  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS;
  };
  Popover.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();
    var content = this.getContent();
    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
    $tip.find('.popover-content').children().detach().end()[this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);
    $tip.removeClass('fade top bottom left right in');
    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html())
      $tip.find('.popover-title').hide();
  };
  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent();
  };
  Popover.prototype.getContent = function () {
    var $e = this.$element;
    var o = this.options;
    return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
  };
  Popover.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.arrow');
  };
  // POPOVER PLUGIN DEFINITION
  // =========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.popover');
      var options = typeof option == 'object' && option;
      if (!data && /destroy|hide/.test(option))
        return;
      if (!data)
        $this.data('bs.popover', data = new Popover(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  }
  var old = $.fn.popover;
  $.fn.popover = Plugin;
  $.fn.popover.Constructor = Popover;
  // POPOVER NO CONFLICT
  // ===================
  $.fn.popover.noConflict = function () {
    $.fn.popover = old;
    return this;
  };
}(jQuery);
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.4
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // SCROLLSPY CLASS DEFINITION
  // ==========================
  function ScrollSpy(element, options) {
    this.$body = $(document.body);
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
    this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
    this.selector = (this.options.target || '') + ' .nav li > a';
    this.offsets = [];
    this.targets = [];
    this.activeTarget = null;
    this.scrollHeight = 0;
    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
    this.refresh();
    this.process();
  }
  ScrollSpy.VERSION = '3.3.4';
  ScrollSpy.DEFAULTS = { offset: 10 };
  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
  };
  ScrollSpy.prototype.refresh = function () {
    var that = this;
    var offsetMethod = 'offset';
    var offsetBase = 0;
    this.offsets = [];
    this.targets = [];
    this.scrollHeight = this.getScrollHeight();
    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position';
      offsetBase = this.$scrollElement.scrollTop();
    }
    this.$body.find(this.selector).map(function () {
      var $el = $(this);
      var href = $el.data('target') || $el.attr('href');
      var $href = /^#./.test(href) && $(href);
      return $href && $href.length && $href.is(':visible') && [[
          $href[offsetMethod]().top + offsetBase,
          href
        ]] || null;
    }).sort(function (a, b) {
      return a[0] - b[0];
    }).each(function () {
      that.offsets.push(this[0]);
      that.targets.push(this[1]);
    });
  };
  ScrollSpy.prototype.process = function () {
    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
    var scrollHeight = this.getScrollHeight();
    var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
    var offsets = this.offsets;
    var targets = this.targets;
    var activeTarget = this.activeTarget;
    var i;
    if (this.scrollHeight != scrollHeight) {
      this.refresh();
    }
    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
    }
    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null;
      return this.clear();
    }
    for (i = offsets.length; i--;) {
      activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
    }
  };
  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target;
    this.clear();
    var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
    var active = $(selector).parents('li').addClass('active');
    if (active.parent('.dropdown-menu').length) {
      active = active.closest('li.dropdown').addClass('active');
    }
    active.trigger('activate.bs.scrollspy');
  };
  ScrollSpy.prototype.clear = function () {
    $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
  };
  // SCROLLSPY PLUGIN DEFINITION
  // ===========================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.scrollspy');
      var options = typeof option == 'object' && option;
      if (!data)
        $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  }
  var old = $.fn.scrollspy;
  $.fn.scrollspy = Plugin;
  $.fn.scrollspy.Constructor = ScrollSpy;
  // SCROLLSPY NO CONFLICT
  // =====================
  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old;
    return this;
  };
  // SCROLLSPY DATA-API
  // ==================
  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this);
      Plugin.call($spy, $spy.data());
    });
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: tab.js v3.3.4
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // TAB CLASS DEFINITION
  // ====================
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.VERSION = '3.3.4';
  Tab.TRANSITION_DURATION = 150;
  Tab.prototype.show = function () {
    var $this = this.element;
    var $ul = $this.closest('ul:not(.dropdown-menu)');
    var selector = $this.data('target');
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    if ($this.parent('li').hasClass('active'))
      return;
    var $previous = $ul.find('.active:last a');
    var hideEvent = $.Event('hide.bs.tab', { relatedTarget: $this[0] });
    var showEvent = $.Event('show.bs.tab', { relatedTarget: $previous[0] });
    $previous.trigger(hideEvent);
    $this.trigger(showEvent);
    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())
      return;
    var $target = $(selector);
    this.activate($this.closest('li'), $ul);
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      });
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      });
    });
  };
  Tab.prototype.activate = function (element, container, callback) {
    var $active = container.find('> .active');
    var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);
    function next() {
      $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
      element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);
      if (transition) {
        element[0].offsetWidth;
        // reflow for transition
        element.addClass('in');
      } else {
        element.removeClass('fade');
      }
      if (element.parent('.dropdown-menu').length) {
        element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
      }
      callback && callback();
    }
    $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
    $active.removeClass('in');
  };
  // TAB PLUGIN DEFINITION
  // =====================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.tab');
      if (!data)
        $this.data('bs.tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  }
  var old = $.fn.tab;
  $.fn.tab = Plugin;
  $.fn.tab.Constructor = Tab;
  // TAB NO CONFLICT
  // ===============
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  // TAB DATA-API
  // ============
  var clickHandler = function (e) {
    e.preventDefault();
    Plugin.call($(this), 'show');
  };
  $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
}(jQuery);
/* ========================================================================
 * Bootstrap: affix.js v3.3.4
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // AFFIX CLASS DEFINITION
  // ======================
  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options);
    this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
    this.$element = $(element);
    this.affixed = null;
    this.unpin = null;
    this.pinnedOffset = null;
    this.checkPosition();
  };
  Affix.VERSION = '3.3.4';
  Affix.RESET = 'affix affix-top affix-bottom';
  Affix.DEFAULTS = {
    offset: 0,
    target: window
  };
  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop = this.$target.scrollTop();
    var position = this.$element.offset();
    var targetHeight = this.$target.height();
    if (offsetTop != null && this.affixed == 'top')
      return scrollTop < offsetTop ? 'top' : false;
    if (this.affixed == 'bottom') {
      if (offsetTop != null)
        return scrollTop + this.unpin <= position.top ? false : 'bottom';
      return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
    }
    var initializing = this.affixed == null;
    var colliderTop = initializing ? scrollTop : position.top;
    var colliderHeight = initializing ? targetHeight : height;
    if (offsetTop != null && scrollTop <= offsetTop)
      return 'top';
    if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom)
      return 'bottom';
    return false;
  };
  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset)
      return this.pinnedOffset;
    this.$element.removeClass(Affix.RESET).addClass('affix');
    var scrollTop = this.$target.scrollTop();
    var position = this.$element.offset();
    return this.pinnedOffset = position.top - scrollTop;
  };
  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1);
  };
  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible'))
      return;
    var height = this.$element.height();
    var offset = this.options.offset;
    var offsetTop = offset.top;
    var offsetBottom = offset.bottom;
    var scrollHeight = $(document.body).height();
    if (typeof offset != 'object')
      offsetBottom = offsetTop = offset;
    if (typeof offsetTop == 'function')
      offsetTop = offset.top(this.$element);
    if (typeof offsetBottom == 'function')
      offsetBottom = offset.bottom(this.$element);
    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
    if (this.affixed != affix) {
      if (this.unpin != null)
        this.$element.css('top', '');
      var affixType = 'affix' + (affix ? '-' + affix : '');
      var e = $.Event(affixType + '.bs.affix');
      this.$element.trigger(e);
      if (e.isDefaultPrevented())
        return;
      this.affixed = affix;
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
      this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
    }
    if (affix == 'bottom') {
      this.$element.offset({ top: scrollHeight - height - offsetBottom });
    }
  };
  // AFFIX PLUGIN DEFINITION
  // =======================
  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.affix');
      var options = typeof option == 'object' && option;
      if (!data)
        $this.data('bs.affix', data = new Affix(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  }
  var old = $.fn.affix;
  $.fn.affix = Plugin;
  $.fn.affix.Constructor = Affix;
  // AFFIX NO CONFLICT
  // =================
  $.fn.affix.noConflict = function () {
    $.fn.affix = old;
    return this;
  };
  // AFFIX DATA-API
  // ==============
  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this);
      var data = $spy.data();
      data.offset = data.offset || {};
      if (data.offsetBottom != null)
        data.offset.bottom = data.offsetBottom;
      if (data.offsetTop != null)
        data.offset.top = data.offsetTop;
      Plugin.call($spy, data);
    });
  });
}(jQuery);/* ========================================================================
 * bootstrap-switch - v3.3.2
 * http://www.bootstrap-switch.org
 * ========================================================================
 * Copyright 2012-2013 Mattia Larentis
 *
 * ========================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================================
 */
(function () {
  var t = [].slice;
  !function (e, i) {
    'use strict';
    var n;
    return n = function () {
      function t(t, i) {
        null == i && (i = {}), this.$element = e(t), this.options = e.extend({}, e.fn.bootstrapSwitch.defaults, {
          state: this.$element.is(':checked'),
          size: this.$element.data('size'),
          animate: this.$element.data('animate'),
          disabled: this.$element.is(':disabled'),
          readonly: this.$element.is('[readonly]'),
          indeterminate: this.$element.data('indeterminate'),
          inverse: this.$element.data('inverse'),
          radioAllOff: this.$element.data('radio-all-off'),
          onColor: this.$element.data('on-color'),
          offColor: this.$element.data('off-color'),
          onText: this.$element.data('on-text'),
          offText: this.$element.data('off-text'),
          labelText: this.$element.data('label-text'),
          handleWidth: this.$element.data('handle-width'),
          labelWidth: this.$element.data('label-width'),
          baseClass: this.$element.data('base-class'),
          wrapperClass: this.$element.data('wrapper-class')
        }, i), this.$wrapper = e('<div>', {
          'class': function (t) {
            return function () {
              var e;
              return e = ['' + t.options.baseClass].concat(t._getClasses(t.options.wrapperClass)), e.push(t.options.state ? '' + t.options.baseClass + '-on' : '' + t.options.baseClass + '-off'), null != t.options.size && e.push('' + t.options.baseClass + '-' + t.options.size), t.options.disabled && e.push('' + t.options.baseClass + '-disabled'), t.options.readonly && e.push('' + t.options.baseClass + '-readonly'), t.options.indeterminate && e.push('' + t.options.baseClass + '-indeterminate'), t.options.inverse && e.push('' + t.options.baseClass + '-inverse'), t.$element.attr('id') && e.push('' + t.options.baseClass + '-id-' + t.$element.attr('id')), e.join(' ');
            };
          }(this)()
        }), this.$container = e('<div>', { 'class': '' + this.options.baseClass + '-container' }), this.$on = e('<span>', {
          html: this.options.onText,
          'class': '' + this.options.baseClass + '-handle-on ' + this.options.baseClass + '-' + this.options.onColor
        }), this.$off = e('<span>', {
          html: this.options.offText,
          'class': '' + this.options.baseClass + '-handle-off ' + this.options.baseClass + '-' + this.options.offColor
        }), this.$label = e('<span>', {
          html: this.options.labelText,
          'class': '' + this.options.baseClass + '-label'
        }), this.$element.on('init.bootstrapSwitch', function (e) {
          return function () {
            return e.options.onInit.apply(t, arguments);
          };
        }(this)), this.$element.on('switchChange.bootstrapSwitch', function (e) {
          return function () {
            return e.options.onSwitchChange.apply(t, arguments);
          };
        }(this)), this.$container = this.$element.wrap(this.$container).parent(), this.$wrapper = this.$container.wrap(this.$wrapper).parent(), this.$element.before(this.options.inverse ? this.$off : this.$on).before(this.$label).before(this.options.inverse ? this.$on : this.$off), this.options.indeterminate && this.$element.prop('indeterminate', !0), this._init(), this._elementHandlers(), this._handleHandlers(), this._labelHandlers(), this._formHandler(), this._externalLabelHandler(), this.$element.trigger('init.bootstrapSwitch');
      }
      return t.prototype._constructor = t, t.prototype.state = function (t, e) {
        return 'undefined' == typeof t ? this.options.state : this.options.disabled || this.options.readonly ? this.$element : this.options.state && !this.options.radioAllOff && this.$element.is(':radio') ? this.$element : (this.options.indeterminate && this.indeterminate(!1), t = !!t, this.$element.prop('checked', t).trigger('change.bootstrapSwitch', e), this.$element);
      }, t.prototype.toggleState = function (t) {
        return this.options.disabled || this.options.readonly ? this.$element : this.options.indeterminate ? (this.indeterminate(!1), this.state(!0)) : this.$element.prop('checked', !this.options.state).trigger('change.bootstrapSwitch', t);
      }, t.prototype.size = function (t) {
        return 'undefined' == typeof t ? this.options.size : (null != this.options.size && this.$wrapper.removeClass('' + this.options.baseClass + '-' + this.options.size), t && this.$wrapper.addClass('' + this.options.baseClass + '-' + t), this._width(), this._containerPosition(), this.options.size = t, this.$element);
      }, t.prototype.animate = function (t) {
        return 'undefined' == typeof t ? this.options.animate : (t = !!t, t === this.options.animate ? this.$element : this.toggleAnimate());
      }, t.prototype.toggleAnimate = function () {
        return this.options.animate = !this.options.animate, this.$wrapper.toggleClass('' + this.options.baseClass + '-animate'), this.$element;
      }, t.prototype.disabled = function (t) {
        return 'undefined' == typeof t ? this.options.disabled : (t = !!t, t === this.options.disabled ? this.$element : this.toggleDisabled());
      }, t.prototype.toggleDisabled = function () {
        return this.options.disabled = !this.options.disabled, this.$element.prop('disabled', this.options.disabled), this.$wrapper.toggleClass('' + this.options.baseClass + '-disabled'), this.$element;
      }, t.prototype.readonly = function (t) {
        return 'undefined' == typeof t ? this.options.readonly : (t = !!t, t === this.options.readonly ? this.$element : this.toggleReadonly());
      }, t.prototype.toggleReadonly = function () {
        return this.options.readonly = !this.options.readonly, this.$element.prop('readonly', this.options.readonly), this.$wrapper.toggleClass('' + this.options.baseClass + '-readonly'), this.$element;
      }, t.prototype.indeterminate = function (t) {
        return 'undefined' == typeof t ? this.options.indeterminate : (t = !!t, t === this.options.indeterminate ? this.$element : this.toggleIndeterminate());
      }, t.prototype.toggleIndeterminate = function () {
        return this.options.indeterminate = !this.options.indeterminate, this.$element.prop('indeterminate', this.options.indeterminate), this.$wrapper.toggleClass('' + this.options.baseClass + '-indeterminate'), this._containerPosition(), this.$element;
      }, t.prototype.inverse = function (t) {
        return 'undefined' == typeof t ? this.options.inverse : (t = !!t, t === this.options.inverse ? this.$element : this.toggleInverse());
      }, t.prototype.toggleInverse = function () {
        var t, e;
        return this.$wrapper.toggleClass('' + this.options.baseClass + '-inverse'), e = this.$on.clone(!0), t = this.$off.clone(!0), this.$on.replaceWith(t), this.$off.replaceWith(e), this.$on = t, this.$off = e, this.options.inverse = !this.options.inverse, this.$element;
      }, t.prototype.onColor = function (t) {
        var e;
        return e = this.options.onColor, 'undefined' == typeof t ? e : (null != e && this.$on.removeClass('' + this.options.baseClass + '-' + e), this.$on.addClass('' + this.options.baseClass + '-' + t), this.options.onColor = t, this.$element);
      }, t.prototype.offColor = function (t) {
        var e;
        return e = this.options.offColor, 'undefined' == typeof t ? e : (null != e && this.$off.removeClass('' + this.options.baseClass + '-' + e), this.$off.addClass('' + this.options.baseClass + '-' + t), this.options.offColor = t, this.$element);
      }, t.prototype.onText = function (t) {
        return 'undefined' == typeof t ? this.options.onText : (this.$on.html(t), this._width(), this._containerPosition(), this.options.onText = t, this.$element);
      }, t.prototype.offText = function (t) {
        return 'undefined' == typeof t ? this.options.offText : (this.$off.html(t), this._width(), this._containerPosition(), this.options.offText = t, this.$element);
      }, t.prototype.labelText = function (t) {
        return 'undefined' == typeof t ? this.options.labelText : (this.$label.html(t), this._width(), this.options.labelText = t, this.$element);
      }, t.prototype.handleWidth = function (t) {
        return 'undefined' == typeof t ? this.options.handleWidth : (this.options.handleWidth = t, this._width(), this._containerPosition(), this.$element);
      }, t.prototype.labelWidth = function (t) {
        return 'undefined' == typeof t ? this.options.labelWidth : (this.options.labelWidth = t, this._width(), this._containerPosition(), this.$element);
      }, t.prototype.baseClass = function () {
        return this.options.baseClass;
      }, t.prototype.wrapperClass = function (t) {
        return 'undefined' == typeof t ? this.options.wrapperClass : (t || (t = e.fn.bootstrapSwitch.defaults.wrapperClass), this.$wrapper.removeClass(this._getClasses(this.options.wrapperClass).join(' ')), this.$wrapper.addClass(this._getClasses(t).join(' ')), this.options.wrapperClass = t, this.$element);
      }, t.prototype.radioAllOff = function (t) {
        return 'undefined' == typeof t ? this.options.radioAllOff : (t = !!t, t === this.options.radioAllOff ? this.$element : (this.options.radioAllOff = t, this.$element));
      }, t.prototype.onInit = function (t) {
        return 'undefined' == typeof t ? this.options.onInit : (t || (t = e.fn.bootstrapSwitch.defaults.onInit), this.options.onInit = t, this.$element);
      }, t.prototype.onSwitchChange = function (t) {
        return 'undefined' == typeof t ? this.options.onSwitchChange : (t || (t = e.fn.bootstrapSwitch.defaults.onSwitchChange), this.options.onSwitchChange = t, this.$element);
      }, t.prototype.destroy = function () {
        var t;
        return t = this.$element.closest('form'), t.length && t.off('reset.bootstrapSwitch').removeData('bootstrap-switch'), this.$container.children().not(this.$element).remove(), this.$element.unwrap().unwrap().off('.bootstrapSwitch').removeData('bootstrap-switch'), this.$element;
      }, t.prototype._width = function () {
        var t, e;
        return t = this.$on.add(this.$off), t.add(this.$label).css('width', ''), e = 'auto' === this.options.handleWidth ? Math.max(this.$on.width(), this.$off.width()) : this.options.handleWidth, t.width(e), this.$label.width(function (t) {
          return function (i, n) {
            return 'auto' !== t.options.labelWidth ? t.options.labelWidth : e > n ? e : n;
          };
        }(this)), this._handleWidth = this.$on.outerWidth(), this._labelWidth = this.$label.outerWidth(), this.$container.width(2 * this._handleWidth + this._labelWidth), this.$wrapper.width(this._handleWidth + this._labelWidth);
      }, t.prototype._containerPosition = function (t, e) {
        return null == t && (t = this.options.state), this.$container.css('margin-left', function (e) {
          return function () {
            var i;
            return i = [
              0,
              '-' + e._handleWidth + 'px'
            ], e.options.indeterminate ? '-' + e._handleWidth / 2 + 'px' : t ? e.options.inverse ? i[1] : i[0] : e.options.inverse ? i[0] : i[1];
          };
        }(this)), e ? setTimeout(function () {
          return e();
        }, 50) : void 0;
      }, t.prototype._init = function () {
        var t, e;
        return t = function (t) {
          return function () {
            return t._width(), t._containerPosition(null, function () {
              return t.options.animate ? t.$wrapper.addClass('' + t.options.baseClass + '-animate') : void 0;
            });
          };
        }(this), this.$wrapper.is(':visible') ? t() : e = i.setInterval(function (n) {
          return function () {
            return n.$wrapper.is(':visible') ? (t(), i.clearInterval(e)) : void 0;
          };
        }(this), 50);
      }, t.prototype._elementHandlers = function () {
        return this.$element.on({
          'change.bootstrapSwitch': function (t) {
            return function (i, n) {
              var o;
              return i.preventDefault(), i.stopImmediatePropagation(), o = t.$element.is(':checked'), t._containerPosition(o), o !== t.options.state ? (t.options.state = o, t.$wrapper.toggleClass('' + t.options.baseClass + '-off').toggleClass('' + t.options.baseClass + '-on'), n ? void 0 : (t.$element.is(':radio') && e('[name=\'' + t.$element.attr('name') + '\']').not(t.$element).prop('checked', !1).trigger('change.bootstrapSwitch', !0), t.$element.trigger('switchChange.bootstrapSwitch', [o]))) : void 0;
            };
          }(this),
          'focus.bootstrapSwitch': function (t) {
            return function (e) {
              return e.preventDefault(), t.$wrapper.addClass('' + t.options.baseClass + '-focused');
            };
          }(this),
          'blur.bootstrapSwitch': function (t) {
            return function (e) {
              return e.preventDefault(), t.$wrapper.removeClass('' + t.options.baseClass + '-focused');
            };
          }(this),
          'keydown.bootstrapSwitch': function (t) {
            return function (e) {
              if (e.which && !t.options.disabled && !t.options.readonly)
                switch (e.which) {
                case 37:
                  return e.preventDefault(), e.stopImmediatePropagation(), t.state(!1);
                case 39:
                  return e.preventDefault(), e.stopImmediatePropagation(), t.state(!0);
                }
            };
          }(this)
        });
      }, t.prototype._handleHandlers = function () {
        return this.$on.on('click.bootstrapSwitch', function (t) {
          return function (e) {
            return e.preventDefault(), e.stopPropagation(), t.state(!1), t.$element.trigger('focus.bootstrapSwitch');
          };
        }(this)), this.$off.on('click.bootstrapSwitch', function (t) {
          return function (e) {
            return e.preventDefault(), e.stopPropagation(), t.state(!0), t.$element.trigger('focus.bootstrapSwitch');
          };
        }(this));
      }, t.prototype._labelHandlers = function () {
        return this.$label.on({
          'mousedown.bootstrapSwitch touchstart.bootstrapSwitch': function (t) {
            return function (e) {
              return t._dragStart || t.options.disabled || t.options.readonly ? void 0 : (e.preventDefault(), e.stopPropagation(), t._dragStart = (e.pageX || e.originalEvent.touches[0].pageX) - parseInt(t.$container.css('margin-left'), 10), t.options.animate && t.$wrapper.removeClass('' + t.options.baseClass + '-animate'), t.$element.trigger('focus.bootstrapSwitch'));
            };
          }(this),
          'mousemove.bootstrapSwitch touchmove.bootstrapSwitch': function (t) {
            return function (e) {
              var i;
              if (null != t._dragStart && (e.preventDefault(), i = (e.pageX || e.originalEvent.touches[0].pageX) - t._dragStart, !(i < -t._handleWidth || i > 0)))
                return t._dragEnd = i, t.$container.css('margin-left', '' + t._dragEnd + 'px');
            };
          }(this),
          'mouseup.bootstrapSwitch touchend.bootstrapSwitch': function (t) {
            return function (e) {
              var i;
              if (t._dragStart)
                return e.preventDefault(), t.options.animate && t.$wrapper.addClass('' + t.options.baseClass + '-animate'), t._dragEnd ? (i = t._dragEnd > -(t._handleWidth / 2), t._dragEnd = !1, t.state(t.options.inverse ? !i : i)) : t.state(!t.options.state), t._dragStart = !1;
            };
          }(this),
          'mouseleave.bootstrapSwitch': function (t) {
            return function () {
              return t.$label.trigger('mouseup.bootstrapSwitch');
            };
          }(this)
        });
      }, t.prototype._externalLabelHandler = function () {
        var t;
        return t = this.$element.closest('label'), t.on('click', function (e) {
          return function (i) {
            return i.preventDefault(), i.stopImmediatePropagation(), i.target === t[0] ? e.toggleState() : void 0;
          };
        }(this));
      }, t.prototype._formHandler = function () {
        var t;
        return t = this.$element.closest('form'), t.data('bootstrap-switch') ? void 0 : t.on('reset.bootstrapSwitch', function () {
          return i.setTimeout(function () {
            return t.find('input').filter(function () {
              return e(this).data('bootstrap-switch');
            }).each(function () {
              return e(this).bootstrapSwitch('state', this.checked);
            });
          }, 1);
        }).data('bootstrap-switch', !0);
      }, t.prototype._getClasses = function (t) {
        var i, n, o, s;
        if (!e.isArray(t))
          return ['' + this.options.baseClass + '-' + t];
        for (n = [], o = 0, s = t.length; s > o; o++)
          i = t[o], n.push('' + this.options.baseClass + '-' + i);
        return n;
      }, t;
    }(), e.fn.bootstrapSwitch = function () {
      var i, o, s;
      return o = arguments[0], i = 2 <= arguments.length ? t.call(arguments, 1) : [], s = this, this.each(function () {
        var t, a;
        return t = e(this), a = t.data('bootstrap-switch'), a || t.data('bootstrap-switch', a = new n(this, o)), 'string' == typeof o ? s = a[o].apply(a, i) : void 0;
      }), s;
    }, e.fn.bootstrapSwitch.Constructor = n, e.fn.bootstrapSwitch.defaults = {
      state: !0,
      size: null,
      animate: !0,
      disabled: !1,
      readonly: !1,
      indeterminate: !1,
      inverse: !1,
      radioAllOff: !1,
      onColor: 'primary',
      offColor: 'default',
      onText: 'ON',
      offText: 'OFF',
      labelText: '&nbsp;',
      handleWidth: 'auto',
      labelWidth: 'auto',
      baseClass: 'bootstrap-switch',
      wrapperClass: 'wrapper',
      onInit: function () {
      },
      onSwitchChange: function () {
      }
    };
  }(window.jQuery, window);
}.call(this));/*
 * js-md5 v0.3.0
 * https://github.com/emn178/js-md5
 *
 * Copyright 2014-2015, emn178@gmail.com
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
;
(function (root, undefined) {
  'use strict';
  var NODE_JS = typeof module != 'undefined';
  if (NODE_JS) {
    root = global;
    if (root.JS_MD5_TEST) {
      root.navigator = { userAgent: 'Firefox' };
    }
  }
  var FIREFOX = (root.JS_MD5_TEST || !NODE_JS) && navigator.userAgent.indexOf('Firefox') != -1;
  var ARRAY_BUFFER = !root.JS_MD5_TEST && typeof ArrayBuffer != 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [
      128,
      32768,
      8388608,
      -2147483648
    ];
  var SHIFT = [
      0,
      8,
      16,
      24
    ];
  var blocks = [], buffer8;
  if (ARRAY_BUFFER) {
    var buffer = new ArrayBuffer(68);
    buffer8 = new Uint8Array(buffer);
    blocks = new Uint32Array(buffer);
  }
  var md5 = function (message) {
    var notString = typeof message != 'string';
    if (notString && message.constructor == ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var h0, h1, h2, h3, a, b, c, d, bc, da, code, first = true, end = false, index = 0, i, start = 0, bytes = 0, length = message.length;
    blocks[16] = 0;
    do {
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      if (notString) {
        if (ARRAY_BUFFER) {
          for (i = start; index < length && i < 64; ++index) {
            buffer8[i++] = message[index];
          }
        } else {
          for (i = start; index < length && i < 64; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        }
      } else {
        if (ARRAY_BUFFER) {
          for (i = start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              buffer8[i++] = code;
            } else if (code < 2048) {
              buffer8[i++] = 192 | code >> 6;
              buffer8[i++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              buffer8[i++] = 224 | code >> 12;
              buffer8[i++] = 128 | code >> 6 & 63;
              buffer8[i++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              buffer8[i++] = 240 | code >> 18;
              buffer8[i++] = 128 | code >> 12 & 63;
              buffer8[i++] = 128 | code >> 6 & 63;
              buffer8[i++] = 128 | code & 63;
            }
          }
        } else {
          for (i = start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 2048) {
              blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            }
          }
        }
      }
      bytes += i - start;
      start = i - 64;
      if (index == length) {
        blocks[i >> 2] |= EXTRA[i & 3];
        ++index;
      }
      if (index > length && i < 56) {
        blocks[14] = bytes << 3;
        end = true;
      }
      if (first) {
        a = blocks[0] - 680876937;
        a = (a << 7 | a >>> 25) - 271733879 << 0;
        d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
        d = (d << 12 | d >>> 20) + a << 0;
        c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
        c = (c << 17 | c >>> 15) + d << 0;
        b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
        b = (b << 22 | b >>> 10) + c << 0;
      } else {
        a = h0;
        b = h1;
        c = h2;
        d = h3;
        a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
        b = (b << 22 | b >>> 10) + c << 0;
      }
      a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
      b = (b << 22 | b >>> 10) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
      b = (b << 20 | b >>> 12) + c << 0;
      a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
      a = (a << 5 | a >>> 27) + b << 0;
      d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
      d = (d << 9 | d >>> 23) + a << 0;
      c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
      c = (c << 14 | c >>> 18) + d << 0;
      b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
      b = (b << 20 | b >>> 12) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[5] - 378558;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[8] - 2022574463;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[11] + 1839030562;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[14] - 35309556;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[1] - 1530992060;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[4] + 1272893353;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[7] - 155497632;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[10] - 1094730640;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[13] + 681279174;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[0] - 358537222;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[3] - 722521979;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[6] + 76029189;
      b = (b << 23 | b >>> 9) + c << 0;
      bc = b ^ c;
      a += (bc ^ d) + blocks[9] - 640364487;
      a = (a << 4 | a >>> 28) + b << 0;
      d += (bc ^ a) + blocks[12] - 421815835;
      d = (d << 11 | d >>> 21) + a << 0;
      da = d ^ a;
      c += (da ^ b) + blocks[15] + 530742520;
      c = (c << 16 | c >>> 16) + d << 0;
      b += (da ^ c) + blocks[2] - 995338651;
      b = (b << 23 | b >>> 9) + c << 0;
      a += (c ^ (b | ~d)) + blocks[0] - 198630844;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[5] - 57434055;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[10] - 1051523;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[15] - 30611744;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
      b = (b << 21 | b >>> 11) + c << 0;
      a += (c ^ (b | ~d)) + blocks[4] - 145523070;
      a = (a << 6 | a >>> 26) + b << 0;
      d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
      d = (d << 10 | d >>> 22) + a << 0;
      c += (a ^ (d | ~b)) + blocks[2] + 718787259;
      c = (c << 15 | c >>> 17) + d << 0;
      b += (d ^ (c | ~a)) + blocks[9] - 343485551;
      b = (b << 21 | b >>> 11) + c << 0;
      if (first) {
        h0 = a + 1732584193 << 0;
        h1 = b - 271733879 << 0;
        h2 = c - 1732584194 << 0;
        h3 = d + 271733878 << 0;
        first = false;
      } else {
        h0 = h0 + a << 0;
        h1 = h1 + b << 0;
        h2 = h2 + c << 0;
        h3 = h3 + d << 0;
      }
    } while (!end);
    if (FIREFOX) {
      var hex = HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15];
      hex += HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15];
      hex += HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15];
      hex += HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15];
      hex += HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15];
      hex += HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15];
      hex += HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15];
      hex += HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15];
      hex += HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15];
      hex += HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15];
      hex += HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15];
      hex += HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15];
      hex += HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15];
      hex += HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15];
      hex += HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15];
      hex += HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      return hex;
    } else {
      return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
    }
  };
  if (!root.JS_MD5_TEST && NODE_JS) {
    var crypto = require('crypto');
    var Buffer = require('buffer').Buffer;
    module.exports = function (message) {
      if (typeof message == 'string') {
        if (message.length <= 80) {
          return md5(message);
        } else if (message.length <= 183 && !/[^\x00-\x7F]/.test(message)) {
          return md5(message);
        }
        return crypto.createHash('md5').update(message, 'utf8').digest('hex');
      }
      if (message.constructor == ArrayBuffer) {
        message = new Uint8Array(message);
      }
      if (message.length <= 370) {
        return md5(message);
      }
      return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
    };
  } else if (root) {
    root.md5 = md5;
  }
}(this));/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version: 1.3.6
 *
 */
(function ($) {
  $.fn.extend({
    slimScroll: function (options) {
      var defaults = {
          width: 'auto',
          height: '250px',
          size: '7px',
          color: '#000',
          position: 'right',
          distance: '1px',
          start: 'top',
          opacity: 0.4,
          alwaysVisible: false,
          disableFadeOut: false,
          railVisible: false,
          railColor: '#333',
          railOpacity: 0.2,
          railDraggable: true,
          railClass: 'slimScrollRail',
          barClass: 'slimScrollBar',
          wrapperClass: 'slimScrollDiv',
          allowPageScroll: false,
          wheelStep: 20,
          touchScrollStep: 200,
          borderRadius: '7px',
          railBorderRadius: '7px'
        };
      var o = $.extend(defaults, options);
      // do it for every element that matches selector
      this.each(function () {
        var isOverPanel, isOverBar, isDragg, queueHide, touchDif, barHeight, percentScroll, lastScroll, divS = '<div></div>', minBarHeight = 30, releaseScroll = false;
        // used in event handlers and for better minification
        var me = $(this);
        // ensure we are not binding it again
        if (me.parent().hasClass(o.wrapperClass)) {
          // start from last bar position
          var offset = me.scrollTop();
          // find bar and rail
          bar = me.closest('.' + o.barClass);
          rail = me.closest('.' + o.railClass);
          getBarHeight();
          // check if we should scroll existing instance
          if ($.isPlainObject(options)) {
            // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
            if ('height' in options && options.height == 'auto') {
              me.parent().css('height', 'auto');
              me.css('height', 'auto');
              var height = me.parent().parent().height();
              me.parent().css('height', height);
              me.css('height', height);
            }
            if ('scrollTo' in options) {
              // jump to a static point
              offset = parseInt(o.scrollTo);
            } else if ('scrollBy' in options) {
              // jump by value pixels
              offset += parseInt(o.scrollBy);
            } else if ('destroy' in options) {
              // remove slimscroll elements
              bar.remove();
              rail.remove();
              me.unwrap();
              return;
            }
            // scroll content by the given offset
            scrollContent(offset, false, true);
          }
          return;
        } else if ($.isPlainObject(options)) {
          if ('destroy' in options) {
            return;
          }
        }
        // optionally set height to the parent's height
        o.height = o.height == 'auto' ? me.parent().height() : o.height;
        // wrap content
        var wrapper = $(divS).addClass(o.wrapperClass).css({
            position: 'relative',
            overflow: 'hidden',
            width: o.width,
            height: o.height
          });
        // update style for the div
        me.css({
          overflow: 'hidden',
          width: o.width,
          height: o.height
        });
        // create scrollbar rail
        var rail = $(divS).addClass(o.railClass).css({
            width: o.size,
            height: '100%',
            position: 'absolute',
            top: 0,
            display: o.alwaysVisible && o.railVisible ? 'block' : 'none',
            'border-radius': o.railBorderRadius,
            background: o.railColor,
            opacity: o.railOpacity,
            zIndex: 90
          });
        // create scrollbar
        var bar = $(divS).addClass(o.barClass).css({
            background: o.color,
            width: o.size,
            position: 'absolute',
            top: 0,
            opacity: o.opacity,
            display: o.alwaysVisible ? 'block' : 'none',
            'border-radius': o.borderRadius,
            BorderRadius: o.borderRadius,
            MozBorderRadius: o.borderRadius,
            WebkitBorderRadius: o.borderRadius,
            zIndex: 99
          });
        // set position
        var posCss = o.position == 'right' ? { right: o.distance } : { left: o.distance };
        rail.css(posCss);
        bar.css(posCss);
        // wrap it
        me.wrap(wrapper);
        // append to parent div
        me.parent().append(bar);
        me.parent().append(rail);
        // make it draggable and no longer dependent on the jqueryUI
        if (o.railDraggable) {
          bar.bind('mousedown', function (e) {
            var $doc = $(document);
            isDragg = true;
            t = parseFloat(bar.css('top'));
            pageY = e.pageY;
            $doc.bind('mousemove.slimscroll', function (e) {
              currTop = t + e.pageY - pageY;
              bar.css('top', currTop);
              scrollContent(0, bar.position().top, false);  // scroll content
            });
            $doc.bind('mouseup.slimscroll', function (e) {
              isDragg = false;
              hideBar();
              $doc.unbind('.slimscroll');
            });
            return false;
          }).bind('selectstart.slimscroll', function (e) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          });
        }
        // on rail over
        rail.hover(function () {
          showBar();
        }, function () {
          hideBar();
        });
        // on bar over
        bar.hover(function () {
          isOverBar = true;
        }, function () {
          isOverBar = false;
        });
        // show on parent mouseover
        me.hover(function () {
          isOverPanel = true;
          showBar();
          hideBar();
        }, function () {
          isOverPanel = false;
          hideBar();
        });
        // support for mobile
        me.bind('touchstart', function (e, b) {
          if (e.originalEvent.touches.length) {
            // record where touch started
            touchDif = e.originalEvent.touches[0].pageY;
          }
        });
        me.bind('touchmove', function (e) {
          // prevent scrolling the page if necessary
          if (!releaseScroll) {
            e.originalEvent.preventDefault();
          }
          if (e.originalEvent.touches.length) {
            // see how far user swiped
            var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
            // scroll content
            scrollContent(diff, true);
            touchDif = e.originalEvent.touches[0].pageY;
          }
        });
        // set up initial height
        getBarHeight();
        // check start position
        if (o.start === 'bottom') {
          // scroll content to bottom
          bar.css({ top: me.outerHeight() - bar.outerHeight() });
          scrollContent(0, true);
        } else if (o.start !== 'top') {
          // assume jQuery selector
          scrollContent($(o.start).position().top, null, true);
          // make sure bar stays hidden
          if (!o.alwaysVisible) {
            bar.hide();
          }
        }
        // attach scroll events
        attachWheel(this);
        function _onWheel(e) {
          // use mouse wheel only when mouse is over
          if (!isOverPanel) {
            return;
          }
          var e = e || window.event;
          var delta = 0;
          if (e.wheelDelta) {
            delta = -e.wheelDelta / 120;
          }
          if (e.detail) {
            delta = e.detail / 3;
          }
          var target = e.target || e.srcTarget || e.srcElement;
          if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {
            // scroll content
            scrollContent(delta, true);
          }
          // stop window scroll
          if (e.preventDefault && !releaseScroll) {
            e.preventDefault();
          }
          if (!releaseScroll) {
            e.returnValue = false;
          }
        }
        function scrollContent(y, isWheel, isJump) {
          releaseScroll = false;
          var delta = y;
          var maxTop = me.outerHeight() - bar.outerHeight();
          if (isWheel) {
            // move bar with mouse wheel
            delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();
            // move bar, make sure it doesn't go out
            delta = Math.min(Math.max(delta, 0), maxTop);
            // if scrolling down, make sure a fractional change to the
            // scroll position isn't rounded away when the scrollbar's CSS is set
            // this flooring of delta would happened automatically when
            // bar.css is set below, but we floor here for clarity
            delta = y > 0 ? Math.ceil(delta) : Math.floor(delta);
            // scroll the scrollbar
            bar.css({ top: delta + 'px' });
          }
          // calculate actual scroll amount
          percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());
          delta = percentScroll * (me[0].scrollHeight - me.outerHeight());
          if (isJump) {
            delta = y;
            var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
            offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
            bar.css({ top: offsetTop + 'px' });
          }
          // scroll content
          me.scrollTop(delta);
          // fire scrolling event
          me.trigger('slimscrolling', ~~delta);
          // ensure bar is visible
          showBar();
          // trigger hide when scroll is stopped
          hideBar();
        }
        function attachWheel(target) {
          if (window.addEventListener) {
            target.addEventListener('DOMMouseScroll', _onWheel, false);
            target.addEventListener('mousewheel', _onWheel, false);
          } else {
            document.attachEvent('onmousewheel', _onWheel);
          }
        }
        function getBarHeight() {
          // calculate scrollbar height and make sure it is not too small
          barHeight = Math.max(me.outerHeight() / me[0].scrollHeight * me.outerHeight(), minBarHeight);
          bar.css({ height: barHeight + 'px' });
          // hide scrollbar if content is not long enough
          var display = barHeight == me.outerHeight() ? 'none' : 'block';
          bar.css({ display: display });
        }
        function showBar() {
          // recalculate bar height
          getBarHeight();
          clearTimeout(queueHide);
          // when bar reached top or bottom
          if (percentScroll == ~~percentScroll) {
            //release wheel
            releaseScroll = o.allowPageScroll;
            // publish approporiate event
            if (lastScroll != percentScroll) {
              var msg = ~~percentScroll == 0 ? 'top' : 'bottom';
              me.trigger('slimscroll', msg);
            }
          } else {
            releaseScroll = false;
          }
          lastScroll = percentScroll;
          // show only when required
          if (barHeight >= me.outerHeight()) {
            //allow window scroll
            releaseScroll = true;
            return;
          }
          bar.stop(true, true).fadeIn('fast');
          if (o.railVisible) {
            rail.stop(true, true).fadeIn('fast');
          }
        }
        function hideBar() {
          // only hide when options allow it
          if (!o.alwaysVisible) {
            queueHide = setTimeout(function () {
              if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg) {
                bar.fadeOut('slow');
                rail.fadeOut('slow');
              }
            }, 1000);
          }
        }
      });
      // maintain chainability
      return this;
    }
  });
  $.fn.extend({ slimscroll: $.fn.slimScroll });
}(jQuery));/*!
 * jQuery.scrollTo
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.1
 */
;
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['jquery'], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    // CommonJS
    module.exports = factory(require('jquery'));
  } else {
    // Global
    factory(jQuery);
  }
}(function ($) {
  'use strict';
  var $scrollTo = $.scrollTo = function (target, duration, settings) {
      return $(window).scrollTo(target, duration, settings);
    };
  $scrollTo.defaults = {
    axis: 'xy',
    duration: 0,
    limit: true
  };
  function isWin(elem) {
    return !elem.nodeName || $.inArray(elem.nodeName.toLowerCase(), [
      'iframe',
      '#document',
      'html',
      'body'
    ]) !== -1;
  }
  $.fn.scrollTo = function (target, duration, settings) {
    if (typeof duration === 'object') {
      settings = duration;
      duration = 0;
    }
    if (typeof settings === 'function') {
      settings = { onAfter: settings };
    }
    if (target === 'max') {
      target = 9000000000;
    }
    settings = $.extend({}, $scrollTo.defaults, settings);
    // Speed is still recognized for backwards compatibility
    duration = duration || settings.duration;
    // Make sure the settings are given right
    var queue = settings.queue && settings.axis.length > 1;
    if (queue) {
      // Let's keep the overall duration
      duration /= 2;
    }
    settings.offset = both(settings.offset);
    settings.over = both(settings.over);
    return this.each(function () {
      // Null target yields nothing, just like jQuery does
      if (target === null)
        return;
      var win = isWin(this), elem = win ? this.contentWindow || window : this, $elem = $(elem), targ = target, attr = {}, toff;
      switch (typeof targ) {
      // A number will pass the regex
      case 'number':
      case 'string':
        if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
          targ = both(targ);
          // We are done
          break;
        }
        // Relative/Absolute selector
        targ = win ? $(targ) : $(targ, elem);
        if (!targ.length)
          return;
      /* falls through */
      case 'object':
        // DOMElement / jQuery
        if (targ.is || targ.style) {
          // Get the real position of the target
          toff = (targ = $(targ)).offset();
        }
      }
      var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;
      $.each(settings.axis.split(''), function (i, axis) {
        var Pos = axis === 'x' ? 'Left' : 'Top', pos = Pos.toLowerCase(), key = 'scroll' + Pos, prev = $elem[key](), max = $scrollTo.max(elem, axis);
        if (toff) {
          // jQuery / DOMElement
          attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);
          // If it's a dom element, reduce the margin
          if (settings.margin) {
            attr[key] -= parseInt(targ.css('margin' + Pos), 10) || 0;
            attr[key] -= parseInt(targ.css('border' + Pos + 'Width'), 10) || 0;
          }
          attr[key] += offset[pos] || 0;
          if (settings.over[pos]) {
            // Scroll to a fraction of its width/height
            attr[key] += targ[axis === 'x' ? 'width' : 'height']() * settings.over[pos];
          }
        } else {
          var val = targ[pos];
          // Handle percentage values
          attr[key] = val.slice && val.slice(-1) === '%' ? parseFloat(val) / 100 * max : val;
        }
        // Number or 'number'
        if (settings.limit && /^\d+$/.test(attr[key])) {
          // Check the limits
          attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
        }
        // Don't waste time animating, if there's no need.
        if (!i && settings.axis.length > 1) {
          if (prev === attr[key]) {
            // No animation needed
            attr = {};
          } else if (queue) {
            // Intermediate animation
            animate(settings.onAfterFirst);
            // Don't animate this axis again in the next iteration.
            attr = {};
          }
        }
      });
      animate(settings.onAfter);
      function animate(callback) {
        var opts = $.extend({}, settings, {
            queue: true,
            duration: duration,
            complete: callback && function () {
              callback.call(elem, targ, settings);
            }
          });
        $elem.animate(attr, opts);
      }
    });
  };
  // Max scrolling position, works on quirks mode
  // It only fails (not too badly) on IE, quirks mode.
  $scrollTo.max = function (elem, axis) {
    var Dim = axis === 'x' ? 'Width' : 'Height', scroll = 'scroll' + Dim;
    if (!isWin(elem))
      return elem[scroll] - $(elem)[Dim.toLowerCase()]();
    var size = 'client' + Dim, doc = elem.ownerDocument || elem.document, html = doc.documentElement, body = doc.body;
    return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
  };
  function both(val) {
    return $.isFunction(val) || $.isPlainObject(val) ? val : {
      top: val,
      left: val
    };
  }
  // Add special hooks so that window scroll properties can be animated
  $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = {
    get: function (t) {
      return $(t.elem)[t.prop]();
    },
    set: function (t) {
      var curr = this.get(t);
      // If interrupt is true and user scrolled, stop animating
      if (t.options.interrupt && t._last && t._last !== curr) {
        return $(t.elem).stop();
      }
      var next = Math.round(t.now);
      // Don't waste CPU
      // Browsers don't render floating point scroll
      if (curr !== next) {
        $(t.elem)[t.prop](next);
        t._last = this.get(t);
      }
    }
  };
  // AMD requirement
  return $scrollTo;
}));/**
 * Extend jquery with a scrollspy plugin.
 * This watches the window scroll and fires events when elements are scrolled into viewport.
 *
 * throttle() and getTime() taken from Underscore.js
 * https://github.com/jashkenas/underscore
 *
 * @author Copyright 2013 John Smart
 * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE
 * @see https://github.com/thesmart
 * @version 0.1.2
 */
(function ($) {
  var jWindow = $(window);
  var elements = [];
  var elementsInView = [];
  var isSpying = false;
  var ticks = 0;
  var offset = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  /**
	 * Find elements that are within the boundary
	 * @param {number} top
	 * @param {number} right
	 * @param {number} bottom
	 * @param {number} left
	 * @return {jQuery}		A collection of elements
	 */
  function findElements(top, right, bottom, left) {
    var hits = $();
    $.each(elements, function (i, element) {
      var elTop = element.offset().top, elLeft = element.offset().left, elRight = elLeft + element.width(), elBottom = elTop + element.height();
      var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < top);
      if (isIntersect) {
        hits.push(element);
      }
    });
    return hits;
  }
  /**
	 * Called when the user scrolls the window
	 */
  function onScroll() {
    // unique tick id
    ++ticks;
    // viewport rectangle
    var top = jWindow.scrollTop(), left = jWindow.scrollLeft(), right = left + jWindow.width(), bottom = top + jWindow.height();
    // determine which elements are in view
    var intersections = findElements(top + offset.top, right + offset.right, bottom + offset.bottom, left + offset.left);
    $.each(intersections, function (i, element) {
      var lastTick = element.data('scrollSpy:ticks');
      if (typeof lastTick != 'number') {
        // entered into view
        element.triggerHandler('scrollSpy:enter');
      }
      // update tick id
      element.data('scrollSpy:ticks', ticks);
    });
    // determine which elements are no longer in view
    $.each(elementsInView, function (i, element) {
      var lastTick = element.data('scrollSpy:ticks');
      if (typeof lastTick == 'number' && lastTick !== ticks) {
        // exited from view
        element.triggerHandler('scrollSpy:exit');
        element.data('scrollSpy:ticks', null);
      }
    });
    // remember elements in view for next tick
    elementsInView = intersections;
  }
  /**
	 * Called when window is resized
	*/
  function onWinSize() {
    jWindow.trigger('scrollSpy:winSize');
  }
  /**
	 * Get time in ms
   * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
	 * @type {function}
	 * @return {number}
	 */
  var getTime = Date.now || function () {
      return new Date().getTime();
    };
  /**
	 * Returns a function, that, when invoked, will only be triggered at most once
	 * during a given window of time. Normally, the throttled function will run
	 * as much as it can, without ever going more than once per `wait` duration;
	 * but if you'd like to disable the execution on the leading edge, pass
	 * `{leading: false}`. To disable execution on the trailing edge, ditto.
	 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
	 * @param {function} func
	 * @param {number} wait
	 * @param {Object=} options
	 * @returns {Function}
	 */
  function throttle(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function () {
      var now = getTime();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  }
  ;
  /**
	 * Enables ScrollSpy using a selector
	 * @param {jQuery|string} selector  The elements collection, or a selector
	 * @param {Object=} options	Optional.
											throttle : number -> scrollspy throttling. Default: 100 ms
											offsetTop : number -> offset from top. Default: 0
											offsetRight : number -> offset from right. Default: 0
											offsetBottom : number -> offset from bottom. Default: 0
											offsetLeft : number -> offset from left. Default: 0
	 * @returns {jQuery}
	 */
  $.scrollSpy = function (selector, options) {
    selector = $(selector);
    selector.each(function (i, element) {
      elements.push($(element));
    });
    options = options || { throttle: 100 };
    offset.top = options.offsetTop || 0;
    offset.right = options.offsetRight || 0;
    offset.bottom = options.offsetBottom || 0;
    offset.left = options.offsetLeft || 0;
    var throttledScroll = throttle(onScroll, options.throttle || 100);
    var readyScroll = function () {
      $(document).ready(throttledScroll);
    };
    if (!isSpying) {
      jWindow.on('scroll', readyScroll);
      jWindow.on('resize', readyScroll);
      isSpying = true;
    }
    // perform a scan once, after current execution context, and after dom is ready
    setTimeout(readyScroll, 0);
    return selector;
  };
  /**
	 * Listen for window resize events
	 * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
	 * @returns {jQuery}		$(window)
	 */
  $.winSizeSpy = function (options) {
    $.winSizeSpy = function () {
      return jWindow;
    };
    // lock from multiple calls
    options = options || { throttle: 100 };
    return jWindow.on('resize', throttle(onWinSize, options.throttle || 100));
  };
  /**
	 * Enables ScrollSpy on a collection of elements
	 * e.g. $('.scrollSpy').scrollSpy()
	 * @param {Object=} options	Optional.
											throttle : number -> scrollspy throttling. Default: 100 ms
											offsetTop : number -> offset from top. Default: 0
											offsetRight : number -> offset from right. Default: 0
											offsetBottom : number -> offset from bottom. Default: 0
											offsetLeft : number -> offset from left. Default: 0
	 * @returns {jQuery}
	 */
  $.fn.scrollSpy = function (options) {
    return $.scrollSpy($(this), options);
  };
}(jQuery));// Ion.RangeSlider
// version 2.0.10 Build: 323
// © Denis Ineshin, 2015
// https://github.com/IonDen
//
// Project page:    http://ionden.com/a/plugins/ion.rangeSlider/en.html
// GitHub page:     https://github.com/IonDen/ion.rangeSlider
//
// Released under MIT licence:
// http://ionden.com/a/plugins/licence-en.html
// =====================================================================================================================
;
(function ($, document, window, navigator, undefined) {
  'use strict';
  // =================================================================================================================
  // Service
  var plugin_count = 0;
  // IE8 fix
  var is_old_ie = function () {
      var n = navigator.userAgent, r = /msie\s\d+/i, v;
      if (n.search(r) > 0) {
        v = r.exec(n).toString();
        v = v.split(' ')[1];
        if (v < 9) {
          $('html').addClass('lt-ie9');
          return true;
        }
      }
      return false;
    }();
  if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) {
      var target = this;
      var slice = [].slice;
      if (typeof target != 'function') {
        throw new TypeError();
      }
      var args = slice.call(arguments, 1), bound = function () {
          if (this instanceof bound) {
            var F = function () {
            };
            F.prototype = target.prototype;
            var self = new F();
            var result = target.apply(self, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return self;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
      return bound;
    };
  }
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement, fromIndex) {
      var k;
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }
      var O = Object(this);
      var len = O.length >>> 0;
      if (len === 0) {
        return -1;
      }
      var n = +fromIndex || 0;
      if (Math.abs(n) === Infinity) {
        n = 0;
      }
      if (n >= len) {
        return -1;
      }
      k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
      while (k < len) {
        if (k in O && O[k] === searchElement) {
          return k;
        }
        k++;
      }
      return -1;
    };
  }
  // =================================================================================================================
  // Template
  var base_html = '<span class="irs">' + '<span class="irs-line" tabindex="-1"><span class="irs-line-left"></span><span class="irs-line-mid"></span><span class="irs-line-right"></span></span>' + '<span class="irs-min">0</span><span class="irs-max">1</span>' + '<span class="irs-from">0</span><span class="irs-to">0</span><span class="irs-single">0</span>' + '</span>' + '<span class="irs-grid"></span>' + '<span class="irs-bar"></span>';
  var single_html = '<span class="irs-bar-edge"></span>' + '<span class="irs-shadow shadow-single"></span>' + '<span class="irs-slider single"></span>';
  var double_html = '<span class="irs-shadow shadow-from"></span>' + '<span class="irs-shadow shadow-to"></span>' + '<span class="irs-slider from"></span>' + '<span class="irs-slider to"></span>';
  var disable_html = '<span class="irs-disable-mask"></span>';
  // =================================================================================================================
  // Core
  var IonRangeSlider = function (input, options, plugin_count) {
    this.VERSION = '2.0.10';
    this.input = input;
    this.plugin_count = plugin_count;
    this.current_plugin = 0;
    this.calc_count = 0;
    this.update_tm = 0;
    this.old_from = 0;
    this.old_to = 0;
    this.raf_id = null;
    this.dragging = false;
    this.force_redraw = false;
    this.is_key = false;
    this.is_update = false;
    this.is_start = true;
    this.is_active = false;
    this.is_resize = false;
    this.is_click = false;
    this.$cache = {
      win: $(window),
      body: $(document.body),
      input: $(input),
      cont: null,
      rs: null,
      min: null,
      max: null,
      from: null,
      to: null,
      single: null,
      bar: null,
      line: null,
      s_single: null,
      s_from: null,
      s_to: null,
      shad_single: null,
      shad_from: null,
      shad_to: null,
      grid: null,
      grid_labels: []
    };
    // get config data attributes
    var $inp = this.$cache.input;
    var data = {
        type: $inp.data('type'),
        min: $inp.data('min'),
        max: $inp.data('max'),
        from: $inp.data('from'),
        to: $inp.data('to'),
        step: $inp.data('step'),
        min_interval: $inp.data('minInterval'),
        max_interval: $inp.data('maxInterval'),
        drag_interval: $inp.data('dragInterval'),
        values: $inp.data('values'),
        from_fixed: $inp.data('fromFixed'),
        from_min: $inp.data('fromMin'),
        from_max: $inp.data('fromMax'),
        from_shadow: $inp.data('fromShadow'),
        to_fixed: $inp.data('toFixed'),
        to_min: $inp.data('toMin'),
        to_max: $inp.data('toMax'),
        to_shadow: $inp.data('toShadow'),
        prettify_enabled: $inp.data('prettifyEnabled'),
        prettify_separator: $inp.data('prettifySeparator'),
        force_edges: $inp.data('forceEdges'),
        keyboard: $inp.data('keyboard'),
        keyboard_step: $inp.data('keyboardStep'),
        grid: $inp.data('grid'),
        grid_margin: $inp.data('gridMargin'),
        grid_num: $inp.data('gridNum'),
        grid_snap: $inp.data('gridSnap'),
        hide_min_max: $inp.data('hideMinMax'),
        hide_from_to: $inp.data('hideFromTo'),
        prefix: $inp.data('prefix'),
        postfix: $inp.data('postfix'),
        max_postfix: $inp.data('maxPostfix'),
        decorate_both: $inp.data('decorateBoth'),
        values_separator: $inp.data('valuesSeparator'),
        disable: $inp.data('disable')
      };
    data.values = data.values && data.values.split(',');
    // get from and to out of input
    var val = $inp.prop('value');
    if (val) {
      val = val.split(';');
      if (val[0] && val[0] == +val[0]) {
        val[0] = +val[0];
      }
      if (val[1] && val[1] == +val[1]) {
        val[1] = +val[1];
      }
      if (options && options.values && options.values.length) {
        data.from = val[0] && options.values.indexOf(val[0]);
        data.to = val[1] && options.values.indexOf(val[1]);
      } else {
        data.from = val[0] && +val[0];
        data.to = val[1] && +val[1];
      }
    }
    // JS config has a priority
    options = $.extend(data, options);
    // get config from options
    this.options = $.extend({
      type: 'single',
      min: 10,
      max: 100,
      from: null,
      to: null,
      step: 1,
      min_interval: 0,
      max_interval: 0,
      drag_interval: false,
      values: [],
      p_values: [],
      from_fixed: false,
      from_min: null,
      from_max: null,
      from_shadow: false,
      to_fixed: false,
      to_min: null,
      to_max: null,
      to_shadow: false,
      prettify_enabled: true,
      prettify_separator: ' ',
      prettify: null,
      force_edges: false,
      keyboard: false,
      keyboard_step: 5,
      grid: false,
      grid_margin: true,
      grid_num: 4,
      grid_snap: false,
      hide_min_max: false,
      hide_from_to: false,
      prefix: '',
      postfix: '',
      max_postfix: '',
      decorate_both: true,
      values_separator: ' \u2014 ',
      disable: false,
      onStart: null,
      onChange: null,
      onFinish: null,
      onUpdate: null
    }, options);
    this.validate();
    this.result = {
      input: this.$cache.input,
      slider: null,
      min: this.options.min,
      max: this.options.max,
      from: this.options.from,
      from_percent: 0,
      from_value: null,
      to: this.options.to,
      to_percent: 0,
      to_value: null
    };
    this.coords = {
      x_gap: 0,
      x_pointer: 0,
      w_rs: 0,
      w_rs_old: 0,
      w_handle: 0,
      p_gap: 0,
      p_gap_left: 0,
      p_gap_right: 0,
      p_step: 0,
      p_pointer: 0,
      p_handle: 0,
      p_single: 0,
      p_single_real: 0,
      p_from: 0,
      p_from_real: 0,
      p_to: 0,
      p_to_real: 0,
      p_bar_x: 0,
      p_bar_w: 0,
      grid_gap: 0,
      big_num: 0,
      big: [],
      big_w: [],
      big_p: [],
      big_x: []
    };
    this.labels = {
      w_min: 0,
      w_max: 0,
      w_from: 0,
      w_to: 0,
      w_single: 0,
      p_min: 0,
      p_max: 0,
      p_from: 0,
      p_from_left: 0,
      p_to: 0,
      p_to_left: 0,
      p_single: 0,
      p_single_left: 0
    };
    this.init();
  };
  IonRangeSlider.prototype = {
    init: function (is_update) {
      this.coords.p_step = this.options.step / ((this.options.max - this.options.min) / 100);
      this.target = 'base';
      this.toggleInput();
      this.append();
      this.setMinMax();
      if (is_update) {
        this.force_redraw = true;
        this.calc(true);
        if (this.options.onUpdate && typeof this.options.onUpdate === 'function') {
          this.options.onUpdate(this.result);
        }
      } else {
        this.force_redraw = true;
        this.calc(true);
        if (this.options.onStart && typeof this.options.onStart === 'function') {
          this.options.onStart(this.result);
        }
      }
      this.updateScene();
    },
    append: function () {
      var container_html = '<span class="irs js-irs-' + this.plugin_count + '"></span>';
      this.$cache.input.before(container_html);
      this.$cache.input.prop('readonly', true);
      this.$cache.cont = this.$cache.input.prev();
      this.result.slider = this.$cache.cont;
      this.$cache.cont.html(base_html);
      this.$cache.rs = this.$cache.cont.find('.irs');
      this.$cache.min = this.$cache.cont.find('.irs-min');
      this.$cache.max = this.$cache.cont.find('.irs-max');
      this.$cache.from = this.$cache.cont.find('.irs-from');
      this.$cache.to = this.$cache.cont.find('.irs-to');
      this.$cache.single = this.$cache.cont.find('.irs-single');
      this.$cache.bar = this.$cache.cont.find('.irs-bar');
      this.$cache.line = this.$cache.cont.find('.irs-line');
      this.$cache.grid = this.$cache.cont.find('.irs-grid');
      if (this.options.type === 'single') {
        this.$cache.cont.append(single_html);
        this.$cache.s_single = this.$cache.cont.find('.single');
        this.$cache.from[0].style.visibility = 'hidden';
        this.$cache.to[0].style.visibility = 'hidden';
        this.$cache.shad_single = this.$cache.cont.find('.shadow-single');
      } else {
        this.$cache.cont.append(double_html);
        this.$cache.s_from = this.$cache.cont.find('.from');
        this.$cache.s_to = this.$cache.cont.find('.to');
        this.$cache.shad_from = this.$cache.cont.find('.shadow-from');
        this.$cache.shad_to = this.$cache.cont.find('.shadow-to');
        this.setTopHandler();
      }
      if (this.options.hide_from_to) {
        this.$cache.from[0].style.display = 'none';
        this.$cache.to[0].style.display = 'none';
        this.$cache.single[0].style.display = 'none';
      }
      this.appendGrid();
      if (this.options.disable) {
        this.appendDisableMask();
        this.$cache.input[0].disabled = true;
      } else {
        this.$cache.cont.removeClass('irs-disabled');
        this.$cache.input[0].disabled = false;
        this.bindEvents();
      }
    },
    setTopHandler: function () {
      var min = this.options.min, max = this.options.max, from = this.options.from, to = this.options.to;
      if (from > min && to === max) {
        this.$cache.s_from.addClass('type_last');
      } else if (to < max) {
        this.$cache.s_to.addClass('type_last');
      }
    },
    appendDisableMask: function () {
      this.$cache.cont.append(disable_html);
      this.$cache.cont.addClass('irs-disabled');
    },
    remove: function () {
      this.$cache.cont.remove();
      this.$cache.cont = null;
      this.$cache.line.off('keydown.irs_' + this.plugin_count);
      this.$cache.body.off('touchmove.irs_' + this.plugin_count);
      this.$cache.body.off('mousemove.irs_' + this.plugin_count);
      this.$cache.win.off('touchend.irs_' + this.plugin_count);
      this.$cache.win.off('mouseup.irs_' + this.plugin_count);
      if (is_old_ie) {
        this.$cache.body.off('mouseup.irs_' + this.plugin_count);
        this.$cache.body.off('mouseleave.irs_' + this.plugin_count);
      }
      this.$cache.grid_labels = [];
      this.coords.big = [];
      this.coords.big_w = [];
      this.coords.big_p = [];
      this.coords.big_x = [];
      cancelAnimationFrame(this.raf_id);
    },
    bindEvents: function () {
      this.$cache.body.on('touchmove.irs_' + this.plugin_count, this.pointerMove.bind(this));
      this.$cache.body.on('mousemove.irs_' + this.plugin_count, this.pointerMove.bind(this));
      this.$cache.win.on('touchend.irs_' + this.plugin_count, this.pointerUp.bind(this));
      this.$cache.win.on('mouseup.irs_' + this.plugin_count, this.pointerUp.bind(this));
      this.$cache.line.on('touchstart.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
      this.$cache.line.on('mousedown.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
      if (this.options.drag_interval && this.options.type === 'double') {
        this.$cache.bar.on('touchstart.irs_' + this.plugin_count, this.pointerDown.bind(this, 'both'));
        this.$cache.bar.on('mousedown.irs_' + this.plugin_count, this.pointerDown.bind(this, 'both'));
      } else {
        this.$cache.bar.on('touchstart.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
        this.$cache.bar.on('mousedown.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
      }
      if (this.options.type === 'single') {
        this.$cache.s_single.on('touchstart.irs_' + this.plugin_count, this.pointerDown.bind(this, 'single'));
        this.$cache.shad_single.on('touchstart.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
        this.$cache.s_single.on('mousedown.irs_' + this.plugin_count, this.pointerDown.bind(this, 'single'));
        this.$cache.shad_single.on('mousedown.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
      } else {
        this.$cache.s_from.on('touchstart.irs_' + this.plugin_count, this.pointerDown.bind(this, 'from'));
        this.$cache.s_to.on('touchstart.irs_' + this.plugin_count, this.pointerDown.bind(this, 'to'));
        this.$cache.shad_from.on('touchstart.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
        this.$cache.shad_to.on('touchstart.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
        this.$cache.s_from.on('mousedown.irs_' + this.plugin_count, this.pointerDown.bind(this, 'from'));
        this.$cache.s_to.on('mousedown.irs_' + this.plugin_count, this.pointerDown.bind(this, 'to'));
        this.$cache.shad_from.on('mousedown.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
        this.$cache.shad_to.on('mousedown.irs_' + this.plugin_count, this.pointerClick.bind(this, 'click'));
      }
      if (this.options.keyboard) {
        this.$cache.line.on('keydown.irs_' + this.plugin_count, this.key.bind(this, 'keyboard'));
      }
      if (is_old_ie) {
        this.$cache.body.on('mouseup.irs_' + this.plugin_count, this.pointerUp.bind(this));
        this.$cache.body.on('mouseleave.irs_' + this.plugin_count, this.pointerUp.bind(this));
      }
    },
    pointerMove: function (e) {
      if (!this.dragging) {
        return;
      }
      var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
      this.coords.x_pointer = x - this.coords.x_gap;
      this.calc();
    },
    pointerUp: function (e) {
      if (this.current_plugin !== this.plugin_count) {
        return;
      }
      if (this.is_active) {
        this.is_active = false;
      } else {
        return;
      }
      var is_function = this.options.onFinish && typeof this.options.onFinish === 'function', is_original = $.contains(this.$cache.cont[0], e.target) || this.dragging;
      if (is_function && is_original) {
        this.options.onFinish(this.result);
      }
      this.$cache.cont.find('.state_hover').removeClass('state_hover');
      this.force_redraw = true;
      this.dragging = false;
      if (is_old_ie) {
        $('*').prop('unselectable', false);
      }
      this.updateScene();
    },
    pointerDown: function (target, e) {
      e.preventDefault();
      var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
      if (e.button === 2) {
        return;
      }
      this.current_plugin = this.plugin_count;
      this.target = target;
      this.is_active = true;
      this.dragging = true;
      this.coords.x_gap = this.$cache.rs.offset().left;
      this.coords.x_pointer = x - this.coords.x_gap;
      this.calcPointer();
      switch (target) {
      case 'single':
        this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single);
        break;
      case 'from':
        this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from);
        this.$cache.s_from.addClass('state_hover');
        this.$cache.s_from.addClass('type_last');
        this.$cache.s_to.removeClass('type_last');
        break;
      case 'to':
        this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to);
        this.$cache.s_to.addClass('state_hover');
        this.$cache.s_to.addClass('type_last');
        this.$cache.s_from.removeClass('type_last');
        break;
      case 'both':
        this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from);
        this.coords.p_gap_right = this.toFixed(this.coords.p_to - this.coords.p_pointer);
        this.$cache.s_to.removeClass('type_last');
        this.$cache.s_from.removeClass('type_last');
        break;
      }
      if (is_old_ie) {
        $('*').prop('unselectable', true);
      }
      this.$cache.line.trigger('focus');
      this.updateScene();
    },
    pointerClick: function (target, e) {
      e.preventDefault();
      var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
      if (e.button === 2) {
        return;
      }
      this.current_plugin = this.plugin_count;
      this.target = target;
      this.is_click = true;
      this.coords.x_gap = this.$cache.rs.offset().left;
      this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();
      this.force_redraw = true;
      this.calc();
      this.$cache.line.trigger('focus');
    },
    key: function (target, e) {
      if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
        return;
      }
      switch (e.which) {
      case 83:
      // W
      case 65:
      // A
      case 40:
      // DOWN
      case 37:
        // LEFT
        e.preventDefault();
        this.moveByKey(false);
        break;
      case 87:
      // S
      case 68:
      // D
      case 38:
      // UP
      case 39:
        // RIGHT
        e.preventDefault();
        this.moveByKey(true);
        break;
      }
      return true;
    },
    moveByKey: function (right) {
      var p = this.coords.p_pointer;
      if (right) {
        p += this.options.keyboard_step;
      } else {
        p -= this.options.keyboard_step;
      }
      this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);
      this.is_key = true;
      this.calc();
    },
    setMinMax: function () {
      if (!this.options) {
        return;
      }
      if (this.options.hide_min_max) {
        this.$cache.min[0].style.display = 'none';
        this.$cache.max[0].style.display = 'none';
        return;
      }
      if (this.options.values.length) {
        this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));
        this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));
      } else {
        this.$cache.min.html(this.decorate(this._prettify(this.options.min), this.options.min));
        this.$cache.max.html(this.decorate(this._prettify(this.options.max), this.options.max));
      }
      this.labels.w_min = this.$cache.min.outerWidth(false);
      this.labels.w_max = this.$cache.max.outerWidth(false);
    },
    calc: function (update) {
      if (!this.options) {
        return;
      }
      this.calc_count++;
      if (this.calc_count === 10 || update) {
        this.calc_count = 0;
        this.coords.w_rs = this.$cache.rs.outerWidth(false);
        if (this.options.type === 'single') {
          this.coords.w_handle = this.$cache.s_single.outerWidth(false);
        } else {
          this.coords.w_handle = this.$cache.s_from.outerWidth(false);
        }
      }
      if (!this.coords.w_rs) {
        return;
      }
      this.calcPointer();
      this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);
      var real_width = 100 - this.coords.p_handle, real_x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);
      if (this.target === 'click') {
        real_x = this.toFixed(this.coords.p_pointer - this.coords.p_handle / 2);
        this.target = this.chooseHandle(real_x);
      }
      if (real_x < 0) {
        real_x = 0;
      } else if (real_x > real_width) {
        real_x = real_width;
      }
      switch (this.target) {
      case 'base':
        var w = (this.options.max - this.options.min) / 100, f = (this.result.from - this.options.min) / w, t = (this.result.to - this.options.min) / w;
        this.coords.p_single_real = this.toFixed(f);
        this.coords.p_from_real = this.toFixed(f);
        this.coords.p_to_real = this.toFixed(t);
        this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
        this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
        this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
        this.coords.p_single = this.toFixed(f - this.coords.p_handle / 100 * f);
        this.coords.p_from = this.toFixed(f - this.coords.p_handle / 100 * f);
        this.coords.p_to = this.toFixed(t - this.coords.p_handle / 100 * t);
        this.target = null;
        break;
      case 'single':
        if (this.options.from_fixed) {
          break;
        }
        this.coords.p_single_real = this.calcWithStep(real_x / real_width * 100);
        this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
        this.coords.p_single = this.toFixed(this.coords.p_single_real / 100 * real_width);
        break;
      case 'from':
        if (this.options.from_fixed) {
          break;
        }
        this.coords.p_from_real = this.calcWithStep(real_x / real_width * 100);
        if (this.coords.p_from_real > this.coords.p_to_real) {
          this.coords.p_from_real = this.coords.p_to_real;
        }
        this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
        this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, 'from');
        this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, 'from');
        this.coords.p_from = this.toFixed(this.coords.p_from_real / 100 * real_width);
        break;
      case 'to':
        if (this.options.to_fixed) {
          break;
        }
        this.coords.p_to_real = this.calcWithStep(real_x / real_width * 100);
        if (this.coords.p_to_real < this.coords.p_from_real) {
          this.coords.p_to_real = this.coords.p_from_real;
        }
        this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
        this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, 'to');
        this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, 'to');
        this.coords.p_to = this.toFixed(this.coords.p_to_real / 100 * real_width);
        break;
      case 'both':
        if (this.options.from_fixed || this.options.to_fixed) {
          break;
        }
        real_x = this.toFixed(real_x + this.coords.p_handle * 0.1);
        this.coords.p_from_real = this.calcWithStep((real_x - this.coords.p_gap_left) / real_width * 100);
        this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
        this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, 'from');
        this.coords.p_from = this.toFixed(this.coords.p_from_real / 100 * real_width);
        this.coords.p_to_real = this.calcWithStep((real_x + this.coords.p_gap_right) / real_width * 100);
        this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
        this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, 'to');
        this.coords.p_to = this.toFixed(this.coords.p_to_real / 100 * real_width);
        break;
      }
      if (this.options.type === 'single') {
        this.coords.p_bar_x = this.coords.p_handle / 2;
        this.coords.p_bar_w = this.coords.p_single;
        this.result.from_percent = this.coords.p_single_real;
        this.result.from = this.calcReal(this.coords.p_single_real);
        if (this.options.values.length) {
          this.result.from_value = this.options.values[this.result.from];
        }
      } else {
        this.coords.p_bar_x = this.toFixed(this.coords.p_from + this.coords.p_handle / 2);
        this.coords.p_bar_w = this.toFixed(this.coords.p_to - this.coords.p_from);
        this.result.from_percent = this.coords.p_from_real;
        this.result.from = this.calcReal(this.coords.p_from_real);
        this.result.to_percent = this.coords.p_to_real;
        this.result.to = this.calcReal(this.coords.p_to_real);
        if (this.options.values.length) {
          this.result.from_value = this.options.values[this.result.from];
          this.result.to_value = this.options.values[this.result.to];
        }
      }
      this.calcMinMax();
      this.calcLabels();
    },
    calcPointer: function () {
      if (!this.coords.w_rs) {
        this.coords.p_pointer = 0;
        return;
      }
      if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)) {
        this.coords.x_pointer = 0;
      } else if (this.coords.x_pointer > this.coords.w_rs) {
        this.coords.x_pointer = this.coords.w_rs;
      }
      this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);
    },
    chooseHandle: function (real_x) {
      if (this.options.type === 'single') {
        return 'single';
      } else {
        var m_point = this.coords.p_from_real + (this.coords.p_to_real - this.coords.p_from_real) / 2;
        if (real_x >= m_point) {
          return this.options.to_fixed ? 'from' : 'to';
        } else {
          return this.options.from_fixed ? 'to' : 'from';
        }
      }
    },
    calcMinMax: function () {
      if (!this.coords.w_rs) {
        return;
      }
      this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;
      this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;
    },
    calcLabels: function () {
      if (!this.coords.w_rs || this.options.hide_from_to) {
        return;
      }
      if (this.options.type === 'single') {
        this.labels.w_single = this.$cache.single.outerWidth(false);
        this.labels.p_single = this.labels.w_single / this.coords.w_rs * 100;
        this.labels.p_single_left = this.coords.p_single + this.coords.p_handle / 2 - this.labels.p_single / 2;
        this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single);
      } else {
        this.labels.w_from = this.$cache.from.outerWidth(false);
        this.labels.p_from = this.labels.w_from / this.coords.w_rs * 100;
        this.labels.p_from_left = this.coords.p_from + this.coords.p_handle / 2 - this.labels.p_from / 2;
        this.labels.p_from_left = this.toFixed(this.labels.p_from_left);
        this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from);
        this.labels.w_to = this.$cache.to.outerWidth(false);
        this.labels.p_to = this.labels.w_to / this.coords.w_rs * 100;
        this.labels.p_to_left = this.coords.p_to + this.coords.p_handle / 2 - this.labels.p_to / 2;
        this.labels.p_to_left = this.toFixed(this.labels.p_to_left);
        this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to);
        this.labels.w_single = this.$cache.single.outerWidth(false);
        this.labels.p_single = this.labels.w_single / this.coords.w_rs * 100;
        this.labels.p_single_left = (this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to) / 2 - this.labels.p_single / 2;
        this.labels.p_single_left = this.toFixed(this.labels.p_single_left);
        this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single);
      }
    },
    updateScene: function () {
      if (this.raf_id) {
        cancelAnimationFrame(this.raf_id);
        this.raf_id = null;
      }
      clearTimeout(this.update_tm);
      this.update_tm = null;
      if (!this.options) {
        return;
      }
      this.drawHandles();
      if (this.is_active) {
        this.raf_id = requestAnimationFrame(this.updateScene.bind(this));
      } else {
        this.update_tm = setTimeout(this.updateScene.bind(this), 300);
      }
    },
    drawHandles: function () {
      this.coords.w_rs = this.$cache.rs.outerWidth(false);
      if (!this.coords.w_rs) {
        return;
      }
      if (this.coords.w_rs !== this.coords.w_rs_old) {
        this.target = 'base';
        this.is_resize = true;
      }
      if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {
        this.setMinMax();
        this.calc(true);
        this.drawLabels();
        if (this.options.grid) {
          this.calcGridMargin();
          this.calcGridLabels();
        }
        this.force_redraw = true;
        this.coords.w_rs_old = this.coords.w_rs;
        this.drawShadow();
      }
      if (!this.coords.w_rs) {
        return;
      }
      if (!this.dragging && !this.force_redraw && !this.is_key) {
        return;
      }
      if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {
        this.drawLabels();
        this.$cache.bar[0].style.left = this.coords.p_bar_x + '%';
        this.$cache.bar[0].style.width = this.coords.p_bar_w + '%';
        if (this.options.type === 'single') {
          this.$cache.s_single[0].style.left = this.coords.p_single + '%';
          this.$cache.single[0].style.left = this.labels.p_single_left + '%';
          if (this.options.values.length) {
            this.$cache.input.prop('value', this.result.from_value);
            this.$cache.input.data('from', this.result.from_value);
          } else {
            this.$cache.input.prop('value', this.result.from);
            this.$cache.input.data('from', this.result.from);
          }
        } else {
          this.$cache.s_from[0].style.left = this.coords.p_from + '%';
          this.$cache.s_to[0].style.left = this.coords.p_to + '%';
          if (this.old_from !== this.result.from || this.force_redraw) {
            this.$cache.from[0].style.left = this.labels.p_from_left + '%';
          }
          if (this.old_to !== this.result.to || this.force_redraw) {
            this.$cache.to[0].style.left = this.labels.p_to_left + '%';
          }
          this.$cache.single[0].style.left = this.labels.p_single_left + '%';
          if (this.options.values.length) {
            this.$cache.input.prop('value', this.result.from_value + ';' + this.result.to_value);
            this.$cache.input.data('from', this.result.from_value);
            this.$cache.input.data('to', this.result.to_value);
          } else {
            this.$cache.input.prop('value', this.result.from + ';' + this.result.to);
            this.$cache.input.data('from', this.result.from);
            this.$cache.input.data('to', this.result.to);
          }
        }
        if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {
          this.$cache.input.trigger('change');
        }
        this.old_from = this.result.from;
        this.old_to = this.result.to;
        var is_function = this.options.onChange && typeof this.options.onChange === 'function' && !this.is_resize;
        if (is_function && !this.is_update && !this.is_start) {
          this.options.onChange(this.result);
        }
        var is_finish = this.options.onFinish && typeof this.options.onFinish === 'function';
        if (is_finish && (this.is_key || this.is_click)) {
          this.options.onFinish(this.result);
        }
        this.is_update = false;
        this.is_resize = false;
      }
      this.is_start = false;
      this.is_key = false;
      this.is_click = false;
      this.force_redraw = false;
    },
    drawLabels: function () {
      if (!this.options) {
        return;
      }
      var values_num = this.options.values.length, p_values = this.options.p_values, text_single, text_from, text_to;
      if (this.options.hide_from_to) {
        return;
      }
      if (this.options.type === 'single') {
        if (values_num) {
          text_single = this.decorate(p_values[this.result.from]);
          this.$cache.single.html(text_single);
        } else {
          text_single = this.decorate(this._prettify(this.result.from), this.result.from);
          this.$cache.single.html(text_single);
        }
        this.calcLabels();
        if (this.labels.p_single_left < this.labels.p_min + 1) {
          this.$cache.min[0].style.visibility = 'hidden';
        } else {
          this.$cache.min[0].style.visibility = 'visible';
        }
        if (this.labels.p_single_left + this.labels.p_single > 100 - this.labels.p_max - 1) {
          this.$cache.max[0].style.visibility = 'hidden';
        } else {
          this.$cache.max[0].style.visibility = 'visible';
        }
      } else {
        if (values_num) {
          if (this.options.decorate_both) {
            text_single = this.decorate(p_values[this.result.from]);
            text_single += this.options.values_separator;
            text_single += this.decorate(p_values[this.result.to]);
          } else {
            text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);
          }
          text_from = this.decorate(p_values[this.result.from]);
          text_to = this.decorate(p_values[this.result.to]);
          this.$cache.single.html(text_single);
          this.$cache.from.html(text_from);
          this.$cache.to.html(text_to);
        } else {
          if (this.options.decorate_both) {
            text_single = this.decorate(this._prettify(this.result.from), this.result.from);
            text_single += this.options.values_separator;
            text_single += this.decorate(this._prettify(this.result.to), this.result.to);
          } else {
            text_single = this.decorate(this._prettify(this.result.from) + this.options.values_separator + this._prettify(this.result.to), this.result.to);
          }
          text_from = this.decorate(this._prettify(this.result.from), this.result.from);
          text_to = this.decorate(this._prettify(this.result.to), this.result.to);
          this.$cache.single.html(text_single);
          this.$cache.from.html(text_from);
          this.$cache.to.html(text_to);
        }
        this.calcLabels();
        var min = Math.min(this.labels.p_single_left, this.labels.p_from_left), single_left = this.labels.p_single_left + this.labels.p_single, to_left = this.labels.p_to_left + this.labels.p_to, max = Math.max(single_left, to_left);
        if (this.labels.p_from_left + this.labels.p_from >= this.labels.p_to_left) {
          this.$cache.from[0].style.visibility = 'hidden';
          this.$cache.to[0].style.visibility = 'hidden';
          this.$cache.single[0].style.visibility = 'visible';
          if (this.result.from === this.result.to) {
            this.$cache.from[0].style.visibility = 'visible';
            this.$cache.single[0].style.visibility = 'hidden';
            max = to_left;
          } else {
            this.$cache.from[0].style.visibility = 'hidden';
            this.$cache.single[0].style.visibility = 'visible';
            max = Math.max(single_left, to_left);
          }
        } else {
          this.$cache.from[0].style.visibility = 'visible';
          this.$cache.to[0].style.visibility = 'visible';
          this.$cache.single[0].style.visibility = 'hidden';
        }
        if (min < this.labels.p_min + 1) {
          this.$cache.min[0].style.visibility = 'hidden';
        } else {
          this.$cache.min[0].style.visibility = 'visible';
        }
        if (max > 100 - this.labels.p_max - 1) {
          this.$cache.max[0].style.visibility = 'hidden';
        } else {
          this.$cache.max[0].style.visibility = 'visible';
        }
      }
    },
    drawShadow: function () {
      var o = this.options, c = this.$cache, is_from_min = typeof o.from_min === 'number' && !isNaN(o.from_min), is_from_max = typeof o.from_max === 'number' && !isNaN(o.from_max), is_to_min = typeof o.to_min === 'number' && !isNaN(o.to_min), is_to_max = typeof o.to_max === 'number' && !isNaN(o.to_max), from_min, from_max, to_min, to_max;
      if (o.type === 'single') {
        if (o.from_shadow && (is_from_min || is_from_max)) {
          from_min = this.calcPercent(o.from_min || o.min);
          from_max = this.calcPercent(o.from_max || o.max) - from_min;
          from_min = this.toFixed(from_min - this.coords.p_handle / 100 * from_min);
          from_max = this.toFixed(from_max - this.coords.p_handle / 100 * from_max);
          from_min = from_min + this.coords.p_handle / 2;
          c.shad_single[0].style.display = 'block';
          c.shad_single[0].style.left = from_min + '%';
          c.shad_single[0].style.width = from_max + '%';
        } else {
          c.shad_single[0].style.display = 'none';
        }
      } else {
        if (o.from_shadow && (is_from_min || is_from_max)) {
          from_min = this.calcPercent(o.from_min || o.min);
          from_max = this.calcPercent(o.from_max || o.max) - from_min;
          from_min = this.toFixed(from_min - this.coords.p_handle / 100 * from_min);
          from_max = this.toFixed(from_max - this.coords.p_handle / 100 * from_max);
          from_min = from_min + this.coords.p_handle / 2;
          c.shad_from[0].style.display = 'block';
          c.shad_from[0].style.left = from_min + '%';
          c.shad_from[0].style.width = from_max + '%';
        } else {
          c.shad_from[0].style.display = 'none';
        }
        if (o.to_shadow && (is_to_min || is_to_max)) {
          to_min = this.calcPercent(o.to_min || o.min);
          to_max = this.calcPercent(o.to_max || o.max) - to_min;
          to_min = this.toFixed(to_min - this.coords.p_handle / 100 * to_min);
          to_max = this.toFixed(to_max - this.coords.p_handle / 100 * to_max);
          to_min = to_min + this.coords.p_handle / 2;
          c.shad_to[0].style.display = 'block';
          c.shad_to[0].style.left = to_min + '%';
          c.shad_to[0].style.width = to_max + '%';
        } else {
          c.shad_to[0].style.display = 'none';
        }
      }
    },
    toggleInput: function () {
      this.$cache.input.toggleClass('irs-hidden-input');
    },
    calcPercent: function (num) {
      var w = (this.options.max - this.options.min) / 100, percent = (num - this.options.min) / w;
      return this.toFixed(percent);
    },
    calcReal: function (percent) {
      var min = this.options.min, max = this.options.max, min_decimals = min.toString().split('.')[1], max_decimals = max.toString().split('.')[1], min_length, max_length, avg_decimals = 0, abs = 0;
      if (min_decimals) {
        min_length = min_decimals.length;
        avg_decimals = min_length;
      }
      if (max_decimals) {
        max_length = max_decimals.length;
        avg_decimals = max_length;
      }
      if (min_length && max_length) {
        avg_decimals = min_length >= max_length ? min_length : max_length;
      }
      if (min < 0) {
        abs = Math.abs(min);
        min = +(min + abs).toFixed(avg_decimals);
        max = +(max + abs).toFixed(avg_decimals);
      }
      var number = (max - min) / 100 * percent + min, string = this.options.step.toString().split('.')[1], result;
      if (string) {
        if (number !== min && number !== max) {
          number = +number.toFixed(string.length);
        } else {
          number = +number.toFixed(avg_decimals);
        }
      } else {
        number = number / this.options.step;
        number = number * this.options.step;
        number = +number.toFixed(0);
      }
      if (abs) {
        number -= abs;
        min = this.options.min;
        max = this.options.max;
      }
      if (string) {
        if (number !== min && number !== max) {
          result = +number.toFixed(string.length);
        } else {
          result = +number.toFixed(avg_decimals);
        }
      } else {
        result = this.toFixed(number);
      }
      if (result < this.options.min) {
        result = this.options.min;
      } else if (result > this.options.max) {
        result = this.options.max;
      }
      return result;
    },
    calcWithStep: function (percent) {
      var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;
      if (rounded > 100) {
        rounded = 100;
      }
      if (percent === 100) {
        rounded = 100;
      }
      return this.toFixed(rounded);
    },
    checkMinInterval: function (p_current, p_next, type) {
      var o = this.options, current, next;
      if (!o.min_interval) {
        return p_current;
      }
      current = this.calcReal(p_current);
      next = this.calcReal(p_next);
      if (type === 'from') {
        if (next - current < o.min_interval) {
          current = next - o.min_interval;
        }
      } else {
        if (current - next < o.min_interval) {
          current = next + o.min_interval;
        }
      }
      return this.calcPercent(current);
    },
    checkMaxInterval: function (p_current, p_next, type) {
      var o = this.options, current, next;
      if (!o.max_interval) {
        return p_current;
      }
      current = this.calcReal(p_current);
      next = this.calcReal(p_next);
      if (type === 'from') {
        if (next - current > o.max_interval) {
          current = next - o.max_interval;
        }
      } else {
        if (current - next > o.max_interval) {
          current = next + o.max_interval;
        }
      }
      return this.calcPercent(current);
    },
    checkDiapason: function (p_num, min, max) {
      var num = this.calcReal(p_num), o = this.options;
      if (!min || typeof min !== 'number') {
        min = o.min;
      }
      if (!max || typeof max !== 'number') {
        max = o.max;
      }
      if (num < min) {
        num = min;
      }
      if (num > max) {
        num = max;
      }
      return this.calcPercent(num);
    },
    toFixed: function (num) {
      num = num.toFixed(5);
      return +num;
    },
    _prettify: function (num) {
      if (!this.options.prettify_enabled) {
        return num;
      }
      if (this.options.prettify && typeof this.options.prettify === 'function') {
        return this.options.prettify(num);
      } else {
        return this.prettify(num);
      }
    },
    prettify: function (num) {
      var n = num.toString();
      return n.replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, '$1' + this.options.prettify_separator);
    },
    checkEdges: function (left, width) {
      if (!this.options.force_edges) {
        return this.toFixed(left);
      }
      if (left < 0) {
        left = 0;
      } else if (left > 100 - width) {
        left = 100 - width;
      }
      return this.toFixed(left);
    },
    validate: function () {
      var o = this.options, r = this.result, v = o.values, vl = v.length, value, i;
      if (typeof o.min === 'string')
        o.min = +o.min;
      if (typeof o.max === 'string')
        o.max = +o.max;
      if (typeof o.from === 'string')
        o.from = +o.from;
      if (typeof o.to === 'string')
        o.to = +o.to;
      if (typeof o.step === 'string')
        o.step = +o.step;
      if (typeof o.from_min === 'string')
        o.from_min = +o.from_min;
      if (typeof o.from_max === 'string')
        o.from_max = +o.from_max;
      if (typeof o.to_min === 'string')
        o.to_min = +o.to_min;
      if (typeof o.to_max === 'string')
        o.to_max = +o.to_max;
      if (typeof o.keyboard_step === 'string')
        o.keyboard_step = +o.keyboard_step;
      if (typeof o.grid_num === 'string')
        o.grid_num = +o.grid_num;
      if (o.max <= o.min) {
        if (o.min) {
          o.max = o.min * 2;
        } else {
          o.max = o.min + 1;
        }
        o.step = 1;
      }
      if (vl) {
        o.p_values = [];
        o.min = 0;
        o.max = vl - 1;
        o.step = 1;
        o.grid_num = o.max;
        o.grid_snap = true;
        for (i = 0; i < vl; i++) {
          value = +v[i];
          if (!isNaN(value)) {
            v[i] = value;
            value = this._prettify(value);
          } else {
            value = v[i];
          }
          o.p_values.push(value);
        }
      }
      if (typeof o.from !== 'number' || isNaN(o.from)) {
        o.from = o.min;
      }
      if (typeof o.to !== 'number' || isNaN(o.from)) {
        o.to = o.max;
      }
      if (o.type === 'single') {
        if (o.from < o.min) {
          o.from = o.min;
        }
        if (o.from > o.max) {
          o.from = o.max;
        }
      } else {
        if (o.from < o.min || o.from > o.max) {
          o.from = o.min;
        }
        if (o.to > o.max || o.to < o.min) {
          o.to = o.max;
        }
        if (o.from > o.to) {
          o.from = o.to;
        }
      }
      if (typeof o.step !== 'number' || isNaN(o.step) || !o.step || o.step < 0) {
        o.step = 1;
      }
      if (typeof o.keyboard_step !== 'number' || isNaN(o.keyboard_step) || !o.keyboard_step || o.keyboard_step < 0) {
        o.keyboard_step = 5;
      }
      if (o.from_min && o.from < o.from_min) {
        o.from = o.from_min;
      }
      if (o.from_max && o.from > o.from_max) {
        o.from = o.from_max;
      }
      if (o.to_min && o.to < o.to_min) {
        o.to = o.to_min;
      }
      if (o.to_max && o.from > o.to_max) {
        o.to = o.to_max;
      }
      if (r) {
        if (r.min !== o.min) {
          r.min = o.min;
        }
        if (r.max !== o.max) {
          r.max = o.max;
        }
        if (r.from < r.min || r.from > r.max) {
          r.from = o.from;
        }
        if (r.to < r.min || r.to > r.max) {
          r.to = o.to;
        }
      }
      if (typeof o.min_interval !== 'number' || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {
        o.min_interval = 0;
      }
      if (typeof o.max_interval !== 'number' || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {
        o.max_interval = 0;
      }
      if (o.min_interval && o.min_interval > o.max - o.min) {
        o.min_interval = o.max - o.min;
      }
      if (o.max_interval && o.max_interval > o.max - o.min) {
        o.max_interval = o.max - o.min;
      }
    },
    decorate: function (num, original) {
      var decorated = '', o = this.options;
      if (o.prefix) {
        decorated += o.prefix;
      }
      decorated += num;
      if (o.max_postfix) {
        if (o.values.length && num === o.p_values[o.max]) {
          decorated += o.max_postfix;
          if (o.postfix) {
            decorated += ' ';
          }
        } else if (original === o.max) {
          decorated += o.max_postfix;
          if (o.postfix) {
            decorated += ' ';
          }
        }
      }
      if (o.postfix) {
        decorated += o.postfix;
      }
      return decorated;
    },
    updateFrom: function () {
      this.result.from = this.options.from;
      this.result.from_percent = this.calcPercent(this.result.from);
      if (this.options.values) {
        this.result.from_value = this.options.values[this.result.from];
      }
    },
    updateTo: function () {
      this.result.to = this.options.to;
      this.result.to_percent = this.calcPercent(this.result.to);
      if (this.options.values) {
        this.result.to_value = this.options.values[this.result.to];
      }
    },
    updateResult: function () {
      this.result.min = this.options.min;
      this.result.max = this.options.max;
      this.updateFrom();
      this.updateTo();
    },
    appendGrid: function () {
      if (!this.options.grid) {
        return;
      }
      var o = this.options, i, z, total = o.max - o.min, big_num = o.grid_num, big_p = 0, big_w = 0, small_max = 4, local_small_max, small_p, small_w = 0, result, html = '';
      this.calcGridMargin();
      if (o.grid_snap) {
        big_num = total / o.step;
        big_p = this.toFixed(o.step / (total / 100));
      } else {
        big_p = this.toFixed(100 / big_num);
      }
      if (big_num > 4) {
        small_max = 3;
      }
      if (big_num > 7) {
        small_max = 2;
      }
      if (big_num > 14) {
        small_max = 1;
      }
      if (big_num > 28) {
        small_max = 0;
      }
      for (i = 0; i < big_num + 1; i++) {
        local_small_max = small_max;
        big_w = this.toFixed(big_p * i);
        if (big_w > 100) {
          big_w = 100;
          local_small_max -= 2;
          if (local_small_max < 0) {
            local_small_max = 0;
          }
        }
        this.coords.big[i] = big_w;
        small_p = (big_w - big_p * (i - 1)) / (local_small_max + 1);
        for (z = 1; z <= local_small_max; z++) {
          if (big_w === 0) {
            break;
          }
          small_w = this.toFixed(big_w - small_p * z);
          html += '<span class="irs-grid-pol small" style="left: ' + small_w + '%"></span>';
        }
        html += '<span class="irs-grid-pol" style="left: ' + big_w + '%"></span>';
        result = this.calcReal(big_w);
        if (o.values.length) {
          result = o.p_values[result];
        } else {
          result = this._prettify(result);
        }
        html += '<span class="irs-grid-text js-grid-text-' + i + '" style="left: ' + big_w + '%">' + result + '</span>';
      }
      this.coords.big_num = Math.ceil(big_num + 1);
      this.$cache.cont.addClass('irs-with-grid');
      this.$cache.grid.html(html);
      this.cacheGridLabels();
    },
    cacheGridLabels: function () {
      var $label, i, num = this.coords.big_num;
      for (i = 0; i < num; i++) {
        $label = this.$cache.grid.find('.js-grid-text-' + i);
        this.$cache.grid_labels.push($label);
      }
      this.calcGridLabels();
    },
    calcGridLabels: function () {
      var i, label, start = [], finish = [], num = this.coords.big_num;
      for (i = 0; i < num; i++) {
        this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);
        this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);
        this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);
        start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);
        finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);
      }
      if (this.options.force_edges) {
        if (start[0] < -this.coords.grid_gap) {
          start[0] = -this.coords.grid_gap;
          finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);
          this.coords.big_x[0] = this.coords.grid_gap;
        }
        if (finish[num - 1] > 100 + this.coords.grid_gap) {
          finish[num - 1] = 100 + this.coords.grid_gap;
          start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);
          this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);
        }
      }
      this.calcGridCollision(2, start, finish);
      this.calcGridCollision(4, start, finish);
      for (i = 0; i < num; i++) {
        label = this.$cache.grid_labels[i][0];
        label.style.marginLeft = -this.coords.big_x[i] + '%';
      }
    },
    calcGridCollision: function (step, start, finish) {
      var i, next_i, label, num = this.coords.big_num;
      for (i = 0; i < num; i += step) {
        next_i = i + step / 2;
        if (next_i >= num) {
          break;
        }
        label = this.$cache.grid_labels[next_i][0];
        if (finish[i] <= start[next_i]) {
          label.style.visibility = 'visible';
        } else {
          label.style.visibility = 'hidden';
        }
      }
    },
    calcGridMargin: function () {
      if (!this.options.grid_margin) {
        return;
      }
      this.coords.w_rs = this.$cache.rs.outerWidth(false);
      if (!this.coords.w_rs) {
        return;
      }
      if (this.options.type === 'single') {
        this.coords.w_handle = this.$cache.s_single.outerWidth(false);
      } else {
        this.coords.w_handle = this.$cache.s_from.outerWidth(false);
      }
      this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);
      this.coords.grid_gap = this.toFixed(this.coords.p_handle / 2 - 0.1);
      this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + '%';
      this.$cache.grid[0].style.left = this.coords.grid_gap + '%';
    },
    update: function (options) {
      if (!this.input) {
        return;
      }
      this.is_update = true;
      this.options.from = this.result.from;
      this.options.to = this.result.to;
      this.options = $.extend(this.options, options);
      this.validate();
      this.updateResult(options);
      this.toggleInput();
      this.remove();
      this.init(true);
    },
    reset: function () {
      if (!this.input) {
        return;
      }
      this.updateResult();
      this.update();
    },
    destroy: function () {
      if (!this.input) {
        return;
      }
      this.toggleInput();
      this.$cache.input.prop('readonly', false);
      $.data(this.input, 'ionRangeSlider', null);
      this.remove();
      this.input = null;
      this.options = null;
    }
  };
  $.fn.ionRangeSlider = function (options) {
    return this.each(function () {
      if (!$.data(this, 'ionRangeSlider')) {
        $.data(this, 'ionRangeSlider', new IonRangeSlider(this, options, plugin_count++));
      }
    });
  };
  // =================================================================================================================
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
  // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
  // MIT license
  (function () {
    var lastTime = 0;
    var vendors = [
        'ms',
        'moz',
        'webkit',
        'o'
      ];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame)
      window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
          }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    if (!window.cancelAnimationFrame)
      window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };
  }());
}(jQuery, document, window, navigator));/*! DataTables 1.10.7
 * ©2008-2014 SpryMedia Ltd - datatables.net/license
 */
/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.7
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2008-2014 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */
/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
(function (window, document, undefined) {
  (function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
      // Define as an AMD module if possible
      define('datatables', ['jquery'], factory);
    } else if (typeof exports === 'object') {
      // Node/CommonJS
      module.exports = factory(require('jquery'));
    } else if (jQuery && !jQuery.fn.dataTable) {
      // Define using browser globals otherwise
      // Prevent multiple instantiations if the script is loaded twice
      factory(jQuery);
    }
  }(function ($) {
    'use strict';
    /**
	 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	 * flexible tool, based upon the foundations of progressive enhancement,
	 * which will add advanced interaction controls to any HTML table. For a
	 * full list of features please refer to
	 * [DataTables.net](href="http://datatables.net).
	 *
	 * Note that the `DataTable` object is not a global variable but is aliased
	 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
	 * be  accessed.
	 *
	 *  @class
	 *  @param {object} [init={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.7+
	 *
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
	 *
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "paginate": false,
	 *        "sort": false
	 *      } );
	 *    } );
	 */
    var DataTable;
    /*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don't leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
    // Defined else where
    //  _selector_run
    //  _selector_opts
    //  _selector_first
    //  _selector_row_indexes
    var _ext;
    // DataTable.ext
    var _Api;
    // DataTable.Api
    var _api_register;
    // DataTable.Api.register
    var _api_registerPlural;
    // DataTable.Api.registerPlural
    var _re_dic = {};
    var _re_new_lines = /[\r\n]/g;
    var _re_html = /<.*?>/g;
    var _re_date_start = /^[\w\+\-]/;
    var _re_date_end = /[\w\+\-]$/;
    // Escape regular expression special characters
    var _re_escape_regex = new RegExp('(\\' + [
        '/',
        '.',
        '*',
        '+',
        '?',
        '|',
        '(',
        ')',
        '[',
        ']',
        '{',
        '}',
        '\\',
        '$',
        '^',
        '-'
      ].join('|\\') + ')', 'g');
    // http://en.wikipedia.org/wiki/Foreign_exchange_market
    // - \u20BD - Russian ruble.
    // - \u20a9 - South Korean Won
    // - \u20BA - Turkish Lira
    // - \u20B9 - Indian Rupee
    // - R - Brazil (R$) and South Africa
    // - fr - Swiss Franc
    // - kr - Swedish krona, Norwegian krone and Danish krone
    // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
    //   standards as thousands separators.
    var _re_formatted_numeric = /[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
    var _empty = function (d) {
      return !d || d === true || d === '-' ? true : false;
    };
    var _intVal = function (s) {
      var integer = parseInt(s, 10);
      return !isNaN(integer) && isFinite(s) ? integer : null;
    };
    // Convert from a formatted number with characters other than `.` as the
    // decimal place, to a Javascript number
    var _numToDecimal = function (num, decimalPoint) {
      // Cache created regular expressions for speed as this function is called often
      if (!_re_dic[decimalPoint]) {
        _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
      }
      return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
    };
    var _isNumber = function (d, decimalPoint, formatted) {
      var strType = typeof d === 'string';
      // If empty return immediately so there must be a number if it is a
      // formatted string (this stops the string "k", or "kr", etc being detected
      // as a formatted number for currency
      if (_empty(d)) {
        return true;
      }
      if (decimalPoint && strType) {
        d = _numToDecimal(d, decimalPoint);
      }
      if (formatted && strType) {
        d = d.replace(_re_formatted_numeric, '');
      }
      return !isNaN(parseFloat(d)) && isFinite(d);
    };
    // A string without HTML in it can be considered to be HTML still
    var _isHtml = function (d) {
      return _empty(d) || typeof d === 'string';
    };
    var _htmlNumeric = function (d, decimalPoint, formatted) {
      if (_empty(d)) {
        return true;
      }
      var html = _isHtml(d);
      return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
    };
    var _pluck = function (a, prop, prop2) {
      var out = [];
      var i = 0, ien = a.length;
      // Could have the test in the loop for slightly smaller code, but speed
      // is essential here
      if (prop2 !== undefined) {
        for (; i < ien; i++) {
          if (a[i] && a[i][prop]) {
            out.push(a[i][prop][prop2]);
          }
        }
      } else {
        for (; i < ien; i++) {
          if (a[i]) {
            out.push(a[i][prop]);
          }
        }
      }
      return out;
    };
    // Basically the same as _pluck, but rather than looping over `a` we use `order`
    // as the indexes to pick from `a`
    var _pluck_order = function (a, order, prop, prop2) {
      var out = [];
      var i = 0, ien = order.length;
      // Could have the test in the loop for slightly smaller code, but speed
      // is essential here
      if (prop2 !== undefined) {
        for (; i < ien; i++) {
          if (a[order[i]][prop]) {
            out.push(a[order[i]][prop][prop2]);
          }
        }
      } else {
        for (; i < ien; i++) {
          out.push(a[order[i]][prop]);
        }
      }
      return out;
    };
    var _range = function (len, start) {
      var out = [];
      var end;
      if (start === undefined) {
        start = 0;
        end = len;
      } else {
        end = start;
        start = len;
      }
      for (var i = start; i < end; i++) {
        out.push(i);
      }
      return out;
    };
    var _removeEmpty = function (a) {
      var out = [];
      for (var i = 0, ien = a.length; i < ien; i++) {
        if (a[i]) {
          // careful - will remove all falsy values!
          out.push(a[i]);
        }
      }
      return out;
    };
    var _stripHtml = function (d) {
      return d.replace(_re_html, '');
    };
    /**
	 * Find the unique elements in a source array.
	 *
	 * @param  {array} src Source array
	 * @return {array} Array of unique items
	 * @ignore
	 */
    var _unique = function (src) {
      // A faster unique method is to use object keys to identify used values,
      // but this doesn't work with arrays or objects, which we must also
      // consider. See jsperf.com/compare-array-unique-versions/4 for more
      // information.
      var out = [], val, i, ien = src.length, j, k = 0;
      again:
        for (i = 0; i < ien; i++) {
          val = src[i];
          for (j = 0; j < k; j++) {
            if (out[j] === val) {
              continue again;
            }
          }
          out.push(val);
          k++;
        }
      return out;
    };
    /**
	 * Create a mapping object that allows camel case parameters to be looked up
	 * for their Hungarian counterparts. The mapping is stored in a private
	 * parameter called `_hungarianMap` which can be accessed on the source object.
	 *  @param {object} o
	 *  @memberof DataTable#oApi
	 */
    function _fnHungarianMap(o) {
      var hungarian = 'a aa ai ao as b fn i m o s ', match, newKey, map = {};
      $.each(o, function (key, val) {
        match = key.match(/^([^A-Z]+?)([A-Z])/);
        if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
          newKey = key.replace(match[0], match[2].toLowerCase());
          map[newKey] = key;
          if (match[1] === 'o') {
            _fnHungarianMap(o[key]);
          }
        }
      });
      o._hungarianMap = map;
    }
    /**
	 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	 * created by _fnHungarianMap.
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 *  @memberof DataTable#oApi
	 */
    function _fnCamelToHungarian(src, user, force) {
      if (!src._hungarianMap) {
        _fnHungarianMap(src);
      }
      var hungarianKey;
      $.each(user, function (key, val) {
        hungarianKey = src._hungarianMap[key];
        if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
          // For objects, we need to buzz down into the object to copy parameters
          if (hungarianKey.charAt(0) === 'o') {
            // Copy the camelCase options over to the hungarian
            if (!user[hungarianKey]) {
              user[hungarianKey] = {};
            }
            $.extend(true, user[hungarianKey], user[key]);
            _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
          } else {
            user[hungarianKey] = user[key];
          }
        }
      });
    }
    /**
	 * Language compatibility - when certain options are given, and others aren't, we
	 * need to duplicate the values over, in order to provide backwards compatibility
	 * with older language files.
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnLanguageCompat(lang) {
      var defaults = DataTable.defaults.oLanguage;
      var zeroRecords = lang.sZeroRecords;
      /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
		 * sZeroRecords - assuming that is given.
		 */
      if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === 'No data available in table') {
        _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
      }
      /* Likewise with loading records */
      if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === 'Loading...') {
        _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
      }
      // Old parameter name of the thousands separator mapped onto the new
      if (lang.sInfoThousands) {
        lang.sThousands = lang.sInfoThousands;
      }
      var decimal = lang.sDecimal;
      if (decimal) {
        _addNumericSort(decimal);
      }
    }
    /**
	 * Map one parameter onto another
	 *  @param {object} o Object to map
	 *  @param {*} knew The new parameter name
	 *  @param {*} old The old parameter name
	 */
    var _fnCompatMap = function (o, knew, old) {
      if (o[knew] !== undefined) {
        o[old] = o[knew];
      }
    };
    /**
	 * Provide backwards compatibility for the main DT options. Note that the new
	 * options are mapped onto the old parameters, so this is an external interface
	 * change only.
	 *  @param {object} init Object to map
	 */
    function _fnCompatOpts(init) {
      _fnCompatMap(init, 'ordering', 'bSort');
      _fnCompatMap(init, 'orderMulti', 'bSortMulti');
      _fnCompatMap(init, 'orderClasses', 'bSortClasses');
      _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');
      _fnCompatMap(init, 'order', 'aaSorting');
      _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');
      _fnCompatMap(init, 'paging', 'bPaginate');
      _fnCompatMap(init, 'pagingType', 'sPaginationType');
      _fnCompatMap(init, 'pageLength', 'iDisplayLength');
      _fnCompatMap(init, 'searching', 'bFilter');
      // Column search objects are in an array, so it needs to be converted
      // element by element
      var searchCols = init.aoSearchCols;
      if (searchCols) {
        for (var i = 0, ien = searchCols.length; i < ien; i++) {
          if (searchCols[i]) {
            _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
          }
        }
      }
    }
    /**
	 * Provide backwards compatibility for column options. Note that the new options
	 * are mapped onto the old parameters, so this is an external interface change
	 * only.
	 *  @param {object} init Object to map
	 */
    function _fnCompatCols(init) {
      _fnCompatMap(init, 'orderable', 'bSortable');
      _fnCompatMap(init, 'orderData', 'aDataSort');
      _fnCompatMap(init, 'orderSequence', 'asSorting');
      _fnCompatMap(init, 'orderDataType', 'sortDataType');
      // orderData can be given as an integer
      var dataSort = init.aDataSort;
      if (dataSort && !$.isArray(dataSort)) {
        init.aDataSort = [dataSort];
      }
    }
    /**
	 * Browser feature detection for capabilities, quirks
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnBrowserDetect(settings) {
      var browser = settings.oBrowser;
      // Scrolling feature / quirks detection
      var n = $('<div/>').css({
          position: 'absolute',
          top: 0,
          left: 0,
          height: 1,
          width: 1,
          overflow: 'hidden'
        }).append($('<div/>').css({
          position: 'absolute',
          top: 1,
          left: 1,
          width: 100,
          overflow: 'scroll'
        }).append($('<div class="test"/>').css({
          width: '100%',
          height: 10
        }))).appendTo('body');
      var test = n.find('.test');
      // IE6/7 will oversize a width 100% element inside a scrolling element, to
      // include the width of the scrollbar, while other browsers ensure the inner
      // element is contained without forcing scrolling
      browser.bScrollOversize = test[0].offsetWidth === 100;
      // In rtl text layout, some browsers (most, but not all) will place the
      // scrollbar on the left, rather than the right.
      browser.bScrollbarLeft = Math.round(test.offset().left) !== 1;
      n.remove();
    }
    /**
	 * Array.prototype reduce[Right] method, used for browsers which don't support
	 * JS 1.6. Done this way to reduce code size, since we iterate either way
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnReduce(that, fn, init, start, end, inc) {
      var i = start, value, isSet = false;
      if (init !== undefined) {
        value = init;
        isSet = true;
      }
      while (i !== end) {
        if (!that.hasOwnProperty(i)) {
          continue;
        }
        value = isSet ? fn(value, that[i], i, that) : that[i];
        isSet = true;
        i += inc;
      }
      return value;
    }
    /**
	 * Add a column to the list used for the table with default values
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nTh The th element for this column
	 *  @memberof DataTable#oApi
	 */
    function _fnAddColumn(oSettings, nTh) {
      // Add column to aoColumns array
      var oDefaults = DataTable.defaults.column;
      var iCol = oSettings.aoColumns.length;
      var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
          'nTh': nTh ? nTh : document.createElement('th'),
          'sTitle': oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
          'aDataSort': oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
          'mData': oDefaults.mData ? oDefaults.mData : iCol,
          idx: iCol
        });
      oSettings.aoColumns.push(oCol);
      // Add search object for column specific search. Note that the `searchCols[ iCol ]`
      // passed into extend can be undefined. This allows the user to give a default
      // with only some of the parameters defined, and also not give a default
      var searchCols = oSettings.aoPreSearchCols;
      searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);
      // Use the default column options function to initialise classes etc
      _fnColumnOptions(oSettings, iCol, $(nTh).data());
    }
    /**
	 * Apply options for a column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iCol column index to consider
	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	 *  @memberof DataTable#oApi
	 */
    function _fnColumnOptions(oSettings, iCol, oOptions) {
      var oCol = oSettings.aoColumns[iCol];
      var oClasses = oSettings.oClasses;
      var th = $(oCol.nTh);
      // Try to get width information from the DOM. We can't get it from CSS
      // as we'd need to parse the CSS stylesheet. `width` option can override
      if (!oCol.sWidthOrig) {
        // Width attribute
        oCol.sWidthOrig = th.attr('width') || null;
        // Style attribute
        var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
        if (t) {
          oCol.sWidthOrig = t[1];
        }
      }
      /* User specified column options */
      if (oOptions !== undefined && oOptions !== null) {
        // Backwards compatibility
        _fnCompatCols(oOptions);
        // Map camel case parameters to their Hungarian counterparts
        _fnCamelToHungarian(DataTable.defaults.column, oOptions);
        /* Backwards compatibility for mDataProp */
        if (oOptions.mDataProp !== undefined && !oOptions.mData) {
          oOptions.mData = oOptions.mDataProp;
        }
        if (oOptions.sType) {
          oCol._sManualType = oOptions.sType;
        }
        // `class` is a reserved word in Javascript, so we need to provide
        // the ability to use a valid name for the camel case input
        if (oOptions.className && !oOptions.sClass) {
          oOptions.sClass = oOptions.className;
        }
        $.extend(oCol, oOptions);
        _fnMap(oCol, oOptions, 'sWidth', 'sWidthOrig');
        /* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
        if (oOptions.iDataSort !== undefined) {
          oCol.aDataSort = [oOptions.iDataSort];
        }
        _fnMap(oCol, oOptions, 'aDataSort');
      }
      /* Cache the data get and set functions for speed */
      var mDataSrc = oCol.mData;
      var mData = _fnGetObjectDataFn(mDataSrc);
      var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
      var attrTest = function (src) {
        return typeof src === 'string' && src.indexOf('@') !== -1;
      };
      oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
      oCol.fnGetData = function (rowData, type, meta) {
        var innerData = mData(rowData, type, undefined, meta);
        return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
      };
      oCol.fnSetData = function (rowData, val, meta) {
        return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
      };
      // Indicate if DataTables should read DOM data as an object or array
      // Used in _fnGetRowElements
      if (typeof mDataSrc !== 'number') {
        oSettings._rowReadObject = true;
      }
      /* Feature sorting overrides column specific when off */
      if (!oSettings.oFeatures.bSort) {
        oCol.bSortable = false;
        th.addClass(oClasses.sSortableNone);  // Have to add class here as order event isn't called
      }
      /* Check that the class assignment is correct for sorting */
      var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
      var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
      if (!oCol.bSortable || !bAsc && !bDesc) {
        oCol.sSortingClass = oClasses.sSortableNone;
        oCol.sSortingClassJUI = '';
      } else if (bAsc && !bDesc) {
        oCol.sSortingClass = oClasses.sSortableAsc;
        oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
      } else if (!bAsc && bDesc) {
        oCol.sSortingClass = oClasses.sSortableDesc;
        oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
      } else {
        oCol.sSortingClass = oClasses.sSortable;
        oCol.sSortingClassJUI = oClasses.sSortJUI;
      }
    }
    /**
	 * Adjust the table column widths for new data. Note: you would probably want to
	 * do a redraw after calling this function!
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnAdjustColumnSizing(settings) {
      /* Not interested in doing column width calculation if auto-width is disabled */
      if (settings.oFeatures.bAutoWidth !== false) {
        var columns = settings.aoColumns;
        _fnCalculateColumnWidths(settings);
        for (var i = 0, iLen = columns.length; i < iLen; i++) {
          columns[i].nTh.style.width = columns[i].sWidth;
        }
      }
      var scroll = settings.oScroll;
      if (scroll.sY !== '' || scroll.sX !== '') {
        _fnScrollDraw(settings);
      }
      _fnCallbackFire(settings, null, 'column-sizing', [settings]);
    }
    /**
	 * Covert the index of a visible column to the index in the data array (take account
	 * of hidden columns)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iMatch Visible column index to lookup
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
    function _fnVisibleToColumnIndex(oSettings, iMatch) {
      var aiVis = _fnGetColumns(oSettings, 'bVisible');
      return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
    }
    /**
	 * Covert the index of an index in the data array and convert it to the visible
	 *   column index (take account of hidden columns)
	 *  @param {int} iMatch Column index to lookup
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
    function _fnColumnIndexToVisible(oSettings, iMatch) {
      var aiVis = _fnGetColumns(oSettings, 'bVisible');
      var iPos = $.inArray(iMatch, aiVis);
      return iPos !== -1 ? iPos : null;
    }
    /**
	 * Get the number of visible columns
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the number of visible columns
	 *  @memberof DataTable#oApi
	 */
    function _fnVisbleColumns(oSettings) {
      return _fnGetColumns(oSettings, 'bVisible').length;
    }
    /**
	 * Get an array of column indexes that match a given property
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sParam Parameter in aoColumns to look for - typically
	 *    bVisible or bSearchable
	 *  @returns {array} Array of indexes with matched properties
	 *  @memberof DataTable#oApi
	 */
    function _fnGetColumns(oSettings, sParam) {
      var a = [];
      $.map(oSettings.aoColumns, function (val, i) {
        if (val[sParam]) {
          a.push(i);
        }
      });
      return a;
    }
    /**
	 * Calculate the 'type' of a column
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnColumnTypes(settings) {
      var columns = settings.aoColumns;
      var data = settings.aoData;
      var types = DataTable.ext.type.detect;
      var i, ien, j, jen, k, ken;
      var col, cell, detectedType, cache;
      // For each column, spin over the 
      for (i = 0, ien = columns.length; i < ien; i++) {
        col = columns[i];
        cache = [];
        if (!col.sType && col._sManualType) {
          col.sType = col._sManualType;
        } else if (!col.sType) {
          for (j = 0, jen = types.length; j < jen; j++) {
            for (k = 0, ken = data.length; k < ken; k++) {
              // Use a cache array so we only need to get the type data
              // from the formatter once (when using multiple detectors)
              if (cache[k] === undefined) {
                cache[k] = _fnGetCellData(settings, k, i, 'type');
              }
              detectedType = types[j](cache[k], settings);
              // If null, then this type can't apply to this column, so
              // rather than testing all cells, break out. There is an
              // exception for the last type which is `html`. We need to
              // scan all rows since it is possible to mix string and HTML
              // types
              if (!detectedType && j !== types.length - 1) {
                break;
              }
              // Only a single match is needed for html type since it is
              // bottom of the pile and very similar to string
              if (detectedType === 'html') {
                break;
              }
            }
            // Type is valid for all data points in the column - use this
            // type
            if (detectedType) {
              col.sType = detectedType;
              break;
            }
          }
          // Fall back - if no type was detected, always use string
          if (!col.sType) {
            col.sType = 'string';
          }
        }
      }
    }
    /**
	 * Take the column definitions and static columns arrays and calculate how
	 * they relate to column indexes. The callback function will then apply the
	 * definition found for a column to a suitable configuration object.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	 *  @param {array} aoCols The aoColumns array that defines columns individually
	 *  @param {function} fn Callback function - takes two parameters, the calculated
	 *    column index and the definition for that column.
	 *  @memberof DataTable#oApi
	 */
    function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
      var i, iLen, j, jLen, k, kLen, def;
      var columns = oSettings.aoColumns;
      // Column definitions with aTargets
      if (aoColDefs) {
        /* Loop over the definitions array - loop in reverse so first instance has priority */
        for (i = aoColDefs.length - 1; i >= 0; i--) {
          def = aoColDefs[i];
          /* Each definition can target multiple columns, as it is an array */
          var aTargets = def.targets !== undefined ? def.targets : def.aTargets;
          if (!$.isArray(aTargets)) {
            aTargets = [aTargets];
          }
          for (j = 0, jLen = aTargets.length; j < jLen; j++) {
            if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
              /* Add columns that we don't yet know about */
              while (columns.length <= aTargets[j]) {
                _fnAddColumn(oSettings);
              }
              /* Integer, basic index */
              fn(aTargets[j], def);
            } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
              /* Negative integer, right to left column counting */
              fn(columns.length + aTargets[j], def);
            } else if (typeof aTargets[j] === 'string') {
              /* Class name matching on TH element */
              for (k = 0, kLen = columns.length; k < kLen; k++) {
                if (aTargets[j] == '_all' || $(columns[k].nTh).hasClass(aTargets[j])) {
                  fn(k, def);
                }
              }
            }
          }
        }
      }
      // Statically defined columns array
      if (aoCols) {
        for (i = 0, iLen = aoCols.length; i < iLen; i++) {
          fn(i, aoCols[i]);
        }
      }
    }
    /**
	 * Add a data array to the table, creating DOM node etc. This is the parallel to
	 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	 * DOM source.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aData data array to be added
	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	 *  @memberof DataTable#oApi
	 */
    function _fnAddData(oSettings, aDataIn, nTr, anTds) {
      /* Create the object for storing information about this new row */
      var iRow = oSettings.aoData.length;
      var oData = $.extend(true, {}, DataTable.models.oRow, { src: nTr ? 'dom' : 'data' });
      oData._aData = aDataIn;
      oSettings.aoData.push(oData);
      /* Create the cells */
      var nTd, sThisType;
      var columns = oSettings.aoColumns;
      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        // When working with a row, the data source object must be populated. In
        // all other cases, the data source object is already populated, so we
        // don't overwrite it, which might break bindings etc
        if (nTr) {
          _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i));
        }
        columns[i].sType = null;
      }
      /* Add to the display array */
      oSettings.aiDisplayMaster.push(iRow);
      /* Create the DOM information, or register it if already present */
      if (nTr || !oSettings.oFeatures.bDeferRender) {
        _fnCreateTr(oSettings, iRow, nTr, anTds);
      }
      return iRow;
    }
    /**
	 * Add one or more TR elements to the table. Generally we'd expect to
	 * use this for reading data from a DOM sourced table, but it could be
	 * used for an TR element. Note that if a TR is given, it is used (i.e.
	 * it is not cloned).
	 *  @param {object} settings dataTables settings object
	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	 *  @returns {array} Array of indexes for the added rows
	 *  @memberof DataTable#oApi
	 */
    function _fnAddTr(settings, trs) {
      var row;
      // Allow an individual node to be passed in
      if (!(trs instanceof $)) {
        trs = $(trs);
      }
      return trs.map(function (i, el) {
        row = _fnGetRowElements(settings, el);
        return _fnAddData(settings, row.data, el, row.cells);
      });
    }
    /**
	 * Take a TR element and convert it to an index in aoData
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n the TR element to find
	 *  @returns {int} index if the node is found, null if not
	 *  @memberof DataTable#oApi
	 */
    function _fnNodeToDataIndex(oSettings, n) {
      return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
    }
    /**
	 * Take a TD element and convert it into a column data index (not the visible index)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow The row number the TD/TH can be found in
	 *  @param {node} n The TD/TH element to find
	 *  @returns {int} index if the node is found, -1 if not
	 *  @memberof DataTable#oApi
	 */
    function _fnNodeToColumnIndex(oSettings, iRow, n) {
      return $.inArray(n, oSettings.aoData[iRow].anCells);
    }
    /**
	 * Get the data for a given cell from the internal cache, taking into account data mapping
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
	 *  @returns {*} Cell data
	 *  @memberof DataTable#oApi
	 */
    function _fnGetCellData(settings, rowIdx, colIdx, type) {
      var draw = settings.iDraw;
      var col = settings.aoColumns[colIdx];
      var rowData = settings.aoData[rowIdx]._aData;
      var defaultContent = col.sDefaultContent;
      var cellData = col.fnGetData(rowData, type, {
          settings: settings,
          row: rowIdx,
          col: colIdx
        });
      if (cellData === undefined) {
        if (settings.iDrawError != draw && defaultContent === null) {
          _fnLog(settings, 0, 'Requested unknown parameter ' + (typeof col.mData == 'function' ? '{function}' : '\'' + col.mData + '\'') + ' for row ' + rowIdx, 4);
          settings.iDrawError = draw;
        }
        return defaultContent;
      }
      /* When the data source is null, we can use default column data */
      if ((cellData === rowData || cellData === null) && defaultContent !== null) {
        cellData = defaultContent;
      } else if (typeof cellData === 'function') {
        // If the data source is a function, then we run it and use the return,
        // executing in the scope of the data object (for instances)
        return cellData.call(rowData);
      }
      if (cellData === null && type == 'display') {
        return '';
      }
      return cellData;
    }
    /**
	 * Set the value for a specific cell, into the internal data cache
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {*} val Value to set
	 *  @memberof DataTable#oApi
	 */
    function _fnSetCellData(settings, rowIdx, colIdx, val) {
      var col = settings.aoColumns[colIdx];
      var rowData = settings.aoData[rowIdx]._aData;
      col.fnSetData(rowData, val, {
        settings: settings,
        row: rowIdx,
        col: colIdx
      });
    }
    // Private variable that is used to match action syntax in the data property object
    var __reArray = /\[.*?\]$/;
    var __reFn = /\(\)$/;
    /**
	 * Split string on periods, taking into account escaped periods
	 * @param  {string} str String to split
	 * @return {array} Split string
	 */
    function _fnSplitObjNotation(str) {
      return $.map(str.match(/(\\.|[^\.])+/g), function (s) {
        return s.replace(/\\./g, '.');
      });
    }
    /**
	 * Return a function that can be used to get data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data get function
	 *  @memberof DataTable#oApi
	 */
    function _fnGetObjectDataFn(mSource) {
      if ($.isPlainObject(mSource)) {
        /* Build an object of get functions, and wrap them in a single call */
        var o = {};
        $.each(mSource, function (key, val) {
          if (val) {
            o[key] = _fnGetObjectDataFn(val);
          }
        });
        return function (data, type, row, meta) {
          var t = o[type] || o._;
          return t !== undefined ? t(data, type, row, meta) : data;
        };
      } else if (mSource === null) {
        /* Give an empty string for rendering / sorting etc */
        return function (data) {
          // type, row and meta also passed, but not used
          return data;
        };
      } else if (typeof mSource === 'function') {
        return function (data, type, row, meta) {
          return mSource(data, type, row, meta);
        };
      } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
        /* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
        var fetchData = function (data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== '') {
            var a = _fnSplitObjNotation(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              // Check if we are dealing with special notation
              arrayNotation = a[i].match(__reArray);
              funcNotation = a[i].match(__reFn);
              if (arrayNotation) {
                // Array notation
                a[i] = a[i].replace(__reArray, '');
                // Condition allows simply [] to be passed in
                if (a[i] !== '') {
                  data = data[a[i]];
                }
                out = [];
                // Get the remainder of the nested object to get
                a.splice(0, i + 1);
                innerSrc = a.join('.');
                // Traverse each entry in the array getting the properties requested
                for (var j = 0, jLen = data.length; j < jLen; j++) {
                  out.push(fetchData(data[j], type, innerSrc));
                }
                // If a string is given in between the array notation indicators, that
                // is used to join the strings together, otherwise an array is returned
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === '' ? out : out.join(join);
                // The inner call to fetchData has already traversed through the remainder
                // of the source requested, so we exit from the loop
                break;
              } else if (funcNotation) {
                // Function call
                a[i] = a[i].replace(__reFn, '');
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === undefined) {
                return undefined;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function (data, type) {
          // row and meta also passed, but not used
          return fetchData(data, type, mSource);
        };
      } else {
        /* Array or flat object mapping */
        return function (data, type) {
          // row and meta also passed, but not used
          return data[mSource];
        };
      }
    }
    /**
	 * Return a function that can be used to set data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data set function
	 *  @memberof DataTable#oApi
	 */
    function _fnSetObjectDataFn(mSource) {
      if ($.isPlainObject(mSource)) {
        /* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
        return _fnSetObjectDataFn(mSource._);
      } else if (mSource === null) {
        /* Nothing to do when the data source is null */
        return function () {
        };
      } else if (typeof mSource === 'function') {
        return function (data, val, meta) {
          mSource(data, 'set', val, meta);
        };
      } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
        /* Like the get, we need to get data from a nested object */
        var setData = function (data, val, src) {
          var a = _fnSplitObjNotation(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            // Check if we are dealing with an array notation request
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray, '');
              data[a[i]] = [];
              // Get the remainder of the nested object to set so we can recurse
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join('.');
              // Traverse each entry in the array setting the properties requested
              for (var j = 0, jLen = val.length; j < jLen; j++) {
                o = {};
                setData(o, val[j], innerSrc);
                data[a[i]].push(o);
              }
              // The inner call to setData has already traversed through the remainder
              // of the source and has set the data, thus we can exit here
              return;
            } else if (funcNotation) {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[a[i]](val);
            }
            // If the nested object doesn't currently exist - since we are
            // trying to set the value - create it
            if (data[a[i]] === null || data[a[i]] === undefined) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          // Last item in the input - i.e, the actual set
          if (aLast.match(__reFn)) {
            // Function call
            data = data[aLast.replace(__reFn, '')](val);
          } else {
            // If array notation is used, we just want to strip it and use the property name
            // and assign the value. If it isn't used, then we get the result we want anyway
            data[aLast.replace(__reArray, '')] = val;
          }
        };
        return function (data, val) {
          // meta is also passed in, but not used
          return setData(data, val, mSource);
        };
      } else {
        /* Array or flat object mapping */
        return function (data, val) {
          // meta is also passed in, but not used
          data[mSource] = val;
        };
      }
    }
    /**
	 * Return an array with the full table data
	 *  @param {object} oSettings dataTables settings object
	 *  @returns array {array} aData Master data array
	 *  @memberof DataTable#oApi
	 */
    function _fnGetDataMaster(settings) {
      return _pluck(settings.aoData, '_aData');
    }
    /**
	 * Nuke the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnClearTable(settings) {
      settings.aoData.length = 0;
      settings.aiDisplayMaster.length = 0;
      settings.aiDisplay.length = 0;
    }
    /**
	 * Take an array of integers (index array) and remove a target integer (value - not
	 * the key!)
	 *  @param {array} a Index array to target
	 *  @param {int} iTarget value to find
	 *  @memberof DataTable#oApi
	 */
    function _fnDeleteIndex(a, iTarget, splice) {
      var iTargetIndex = -1;
      for (var i = 0, iLen = a.length; i < iLen; i++) {
        if (a[i] == iTarget) {
          iTargetIndex = i;
        } else if (a[i] > iTarget) {
          a[i]--;
        }
      }
      if (iTargetIndex != -1 && splice === undefined) {
        a.splice(iTargetIndex, 1);
      }
    }
    /**
	 * Mark cached data as invalid such that a re-read of the data will occur when
	 * the cached data is next requested. Also update from the data source object.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {int}    rowIdx   Row index to invalidate
	 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	 *     or 'data'
	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	 *     row will be invalidated
	 * @memberof DataTable#oApi
	 *
	 * @todo For the modularisation of v1.11 this will need to become a callback, so
	 *   the sort and filter methods can subscribe to it. That will required
	 *   initialisation options for sorting, which is why it is not already baked in
	 */
    function _fnInvalidate(settings, rowIdx, src, colIdx) {
      var row = settings.aoData[rowIdx];
      var i, ien;
      var cellWrite = function (cell, col) {
        // This is very frustrating, but in IE if you just write directly
        // to innerHTML, and elements that are overwritten are GC'ed,
        // even if there is a reference to them elsewhere
        while (cell.childNodes.length) {
          cell.removeChild(cell.firstChild);
        }
        cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
      };
      // Are we reading last data from DOM or the data object?
      if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
        // Read the data from the DOM
        row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
      } else {
        // Reading from data object, update the DOM
        var cells = row.anCells;
        if (cells) {
          if (colIdx !== undefined) {
            cellWrite(cells[colIdx], colIdx);
          } else {
            for (i = 0, ien = cells.length; i < ien; i++) {
              cellWrite(cells[i], i);
            }
          }
        }
      }
      // For both row and cell invalidation, the cached data for sorting and
      // filtering is nulled out
      row._aSortData = null;
      row._aFilterData = null;
      // Invalidate the type for a specific column (if given) or all columns since
      // the data might have changed
      var cols = settings.aoColumns;
      if (colIdx !== undefined) {
        cols[colIdx].sType = null;
      } else {
        for (i = 0, ien = cols.length; i < ien; i++) {
          cols[i].sType = null;
        }
        // Update DataTables special `DT_*` attributes for the row
        _fnRowAttributes(row);
      }
    }
    /**
	 * Build a data source object from an HTML row, reading the contents of the
	 * cells that are in the row.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {node|object} TR element from which to read data or existing row
	 *   object from which to re-read the data from the cells
	 * @param {int} [colIdx] Optional column index
	 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	 *   parameter should also be given and will be used to write the data into.
	 *   Only the column in question will be written
	 * @returns {object} Object with two parameters: `data` the data read, in
	 *   document order, and `cells` and array of nodes (they can be useful to the
	 *   caller, so rather than needing a second traversal to get them, just return
	 *   them from here).
	 * @memberof DataTable#oApi
	 */
    function _fnGetRowElements(settings, row, colIdx, d) {
      var tds = [], td = row.firstChild, name, col, o, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
      // Allow the data object to be passed in, or construct
      d = d || objectRead ? {} : [];
      var attr = function (str, td) {
        if (typeof str === 'string') {
          var idx = str.indexOf('@');
          if (idx !== -1) {
            var attr = str.substring(idx + 1);
            var setter = _fnSetObjectDataFn(str);
            setter(d, td.getAttribute(attr));
          }
        }
      };
      // Read data from a cell and store into the data object
      var cellProcess = function (cell) {
        if (colIdx === undefined || colIdx === i) {
          col = columns[i];
          contents = $.trim(cell.innerHTML);
          if (col && col._bAttrSrc) {
            var setter = _fnSetObjectDataFn(col.mData._);
            setter(d, contents);
            attr(col.mData.sort, cell);
            attr(col.mData.type, cell);
            attr(col.mData.filter, cell);
          } else {
            // Depending on the `data` option for the columns the data can
            // be read to either an object or an array.
            if (objectRead) {
              if (!col._setter) {
                // Cache the setter function
                col._setter = _fnSetObjectDataFn(col.mData);
              }
              col._setter(d, contents);
            } else {
              d[i] = contents;
            }
          }
        }
        i++;
      };
      if (td) {
        // `tr` element was passed in
        while (td) {
          name = td.nodeName.toUpperCase();
          if (name == 'TD' || name == 'TH') {
            cellProcess(td);
            tds.push(td);
          }
          td = td.nextSibling;
        }
      } else {
        // Existing row object passed in
        tds = row.anCells;
        for (var j = 0, jen = tds.length; j < jen; j++) {
          cellProcess(tds[j]);
        }
      }
      return {
        data: d,
        cells: tds
      };
    }
    /**
	 * Create a new TR element (and it's TD children) for a row
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow Row to consider
	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @memberof DataTable#oApi
	 */
    function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
      var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen;
      if (row.nTr === null) {
        nTr = nTrIn || document.createElement('tr');
        row.nTr = nTr;
        row.anCells = cells;
        /* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
        nTr._DT_RowIndex = iRow;
        /* Special parameters can be given by the data source to be used on the row */
        _fnRowAttributes(row);
        /* Process each column */
        for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
          oCol = oSettings.aoColumns[i];
          nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
          cells.push(nTd);
          // Need to create the HTML if new, or if a rendering function is defined
          if (!nTrIn || oCol.mRender || oCol.mData !== i) {
            nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
          }
          /* Add user defined class */
          if (oCol.sClass) {
            nTd.className += ' ' + oCol.sClass;
          }
          // Visibility - add or remove as required
          if (oCol.bVisible && !nTrIn) {
            nTr.appendChild(nTd);
          } else if (!oCol.bVisible && nTrIn) {
            nTd.parentNode.removeChild(nTd);
          }
          if (oCol.fnCreatedCell) {
            oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
          }
        }
        _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [
          nTr,
          rowData,
          iRow
        ]);
      }
      // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
      // and deployed
      row.nTr.setAttribute('role', 'row');
    }
    /**
	 * Add attributes to a row based on the special `DT_*` parameters in a data
	 * source object.
	 *  @param {object} DataTables row object for the row to be modified
	 *  @memberof DataTable#oApi
	 */
    function _fnRowAttributes(row) {
      var tr = row.nTr;
      var data = row._aData;
      if (tr) {
        if (data.DT_RowId) {
          tr.id = data.DT_RowId;
        }
        if (data.DT_RowClass) {
          // Remove any classes added by DT_RowClass before
          var a = data.DT_RowClass.split(' ');
          row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
          $(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
        }
        if (data.DT_RowAttr) {
          $(tr).attr(data.DT_RowAttr);
        }
        if (data.DT_RowData) {
          $(tr).data(data.DT_RowData);
        }
      }
    }
    /**
	 * Create the HTML header for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnBuildHead(oSettings) {
      var i, ien, cell, row, column;
      var thead = oSettings.nTHead;
      var tfoot = oSettings.nTFoot;
      var createHeader = $('th, td', thead).length === 0;
      var classes = oSettings.oClasses;
      var columns = oSettings.aoColumns;
      if (createHeader) {
        row = $('<tr/>').appendTo(thead);
      }
      for (i = 0, ien = columns.length; i < ien; i++) {
        column = columns[i];
        cell = $(column.nTh).addClass(column.sClass);
        if (createHeader) {
          cell.appendTo(row);
        }
        // 1.11 move into sorting
        if (oSettings.oFeatures.bSort) {
          cell.addClass(column.sSortingClass);
          if (column.bSortable !== false) {
            cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);
            _fnSortAttachListener(oSettings, column.nTh, i);
          }
        }
        if (column.sTitle != cell.html()) {
          cell.html(column.sTitle);
        }
        _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
      }
      if (createHeader) {
        _fnDetectHeader(oSettings.aoHeader, thead);
      }
      /* ARIA role for the rows */
      $(thead).find('>tr').attr('role', 'row');
      /* Deal with the footer - add classes if required */
      $(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
      $(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH);
      // Cache the footer cells. Note that we only take the cells from the first
      // row in the footer. If there is more than one row the user wants to
      // interact with, they need to use the table().foot() method. Note also this
      // allows cells to be used for multiple columns using colspan
      if (tfoot !== null) {
        var cells = oSettings.aoFooter[0];
        for (i = 0, ien = cells.length; i < ien; i++) {
          column = columns[i];
          column.nTf = cells[i].cell;
          if (column.sClass) {
            $(column.nTf).addClass(column.sClass);
          }
        }
      }
    }
    /**
	 * Draw the header (or footer) element based on the column visibility states. The
	 * methodology here is to use the layout array from _fnDetectHeader, modified for
	 * the instantaneous column visibility, to construct the new layout. The grid is
	 * traversed over cell at a time in a rows x columns grid fashion, although each
	 * cell insert can cover multiple elements in the grid - which is tracks using the
	 * aApplied array. Cell inserts in the grid will only occur where there isn't
	 * already a cell in that position.
	 *  @param {object} oSettings dataTables settings object
	 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	 *  @memberof DataTable#oApi
	 */
    function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
      var i, iLen, j, jLen, k, kLen, n, nLocalTr;
      var aoLocal = [];
      var aApplied = [];
      var iColumns = oSettings.aoColumns.length;
      var iRowspan, iColspan;
      if (!aoSource) {
        return;
      }
      if (bIncludeHidden === undefined) {
        bIncludeHidden = false;
      }
      /* Make a copy of the master layout array, but without the visible columns in it */
      for (i = 0, iLen = aoSource.length; i < iLen; i++) {
        aoLocal[i] = aoSource[i].slice();
        aoLocal[i].nTr = aoSource[i].nTr;
        /* Remove any columns which are currently hidden */
        for (j = iColumns - 1; j >= 0; j--) {
          if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
            aoLocal[i].splice(j, 1);
          }
        }
        /* Prep the applied array - it needs an element for each row */
        aApplied.push([]);
      }
      for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
        nLocalTr = aoLocal[i].nTr;
        /* All cells are going to be replaced, so empty out the row */
        if (nLocalTr) {
          while (n = nLocalTr.firstChild) {
            nLocalTr.removeChild(n);
          }
        }
        for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
          iRowspan = 1;
          iColspan = 1;
          /* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
          if (aApplied[i][j] === undefined) {
            nLocalTr.appendChild(aoLocal[i][j].cell);
            aApplied[i][j] = 1;
            /* Expand the cell to cover as many rows as needed */
            while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
              aApplied[i + iRowspan][j] = 1;
              iRowspan++;
            }
            /* Expand the cell to cover as many columns as needed */
            while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
              /* Must update the applied array over the rows for the columns */
              for (k = 0; k < iRowspan; k++) {
                aApplied[i + k][j + iColspan] = 1;
              }
              iColspan++;
            }
            /* Do the actual expansion in the DOM */
            $(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
          }
        }
      }
    }
    /**
	 * Insert the required TR nodes into the table for display
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnDraw(oSettings) {
      /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
      var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
      if ($.inArray(false, aPreDraw) !== -1) {
        _fnProcessingDisplay(oSettings, false);
        return;
      }
      var i, iLen, n;
      var anRows = [];
      var iRowCount = 0;
      var asStripeClasses = oSettings.asStripeClasses;
      var iStripes = asStripeClasses.length;
      var iOpenRows = oSettings.aoOpenRows.length;
      var oLang = oSettings.oLanguage;
      var iInitDisplayStart = oSettings.iInitDisplayStart;
      var bServerSide = _fnDataSource(oSettings) == 'ssp';
      var aiDisplay = oSettings.aiDisplay;
      oSettings.bDrawing = true;
      /* Check and see if we have an initial draw position from state saving */
      if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
        oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
        oSettings.iInitDisplayStart = -1;
      }
      var iDisplayStart = oSettings._iDisplayStart;
      var iDisplayEnd = oSettings.fnDisplayEnd();
      /* Server-side processing draw intercept */
      if (oSettings.bDeferLoading) {
        oSettings.bDeferLoading = false;
        oSettings.iDraw++;
        _fnProcessingDisplay(oSettings, false);
      } else if (!bServerSide) {
        oSettings.iDraw++;
      } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
        return;
      }
      if (aiDisplay.length !== 0) {
        var iStart = bServerSide ? 0 : iDisplayStart;
        var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
        for (var j = iStart; j < iEnd; j++) {
          var iDataIndex = aiDisplay[j];
          var aoData = oSettings.aoData[iDataIndex];
          if (aoData.nTr === null) {
            _fnCreateTr(oSettings, iDataIndex);
          }
          var nRow = aoData.nTr;
          /* Remove the old striping classes and then add the new one */
          if (iStripes !== 0) {
            var sStripe = asStripeClasses[iRowCount % iStripes];
            if (aoData._sRowStripe != sStripe) {
              $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
              aoData._sRowStripe = sStripe;
            }
          }
          // Row callback functions - might want to manipulate the row
          // iRowCount and j are not currently documented. Are they at all
          // useful?
          _fnCallbackFire(oSettings, 'aoRowCallback', null, [
            nRow,
            aoData._aData,
            iRowCount,
            j
          ]);
          anRows.push(nRow);
          iRowCount++;
        }
      } else {
        /* Table is empty - create a row with an empty message in it */
        var sZero = oLang.sZeroRecords;
        if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
          sZero = oLang.sLoadingRecords;
        } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
          sZero = oLang.sEmptyTable;
        }
        anRows[0] = $('<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' }).append($('<td />', {
          'valign': 'top',
          'colSpan': _fnVisbleColumns(oSettings),
          'class': oSettings.oClasses.sRowEmpty
        }).html(sZero))[0];
      }
      /* Header and footer callbacks */
      _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [
        $(oSettings.nTHead).children('tr')[0],
        _fnGetDataMaster(oSettings),
        iDisplayStart,
        iDisplayEnd,
        aiDisplay
      ]);
      _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [
        $(oSettings.nTFoot).children('tr')[0],
        _fnGetDataMaster(oSettings),
        iDisplayStart,
        iDisplayEnd,
        aiDisplay
      ]);
      var body = $(oSettings.nTBody);
      body.children().detach();
      body.append($(anRows));
      /* Call all required callback functions for the end of a draw */
      _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
      /* Draw is complete, sorting and filtering must be as well */
      oSettings.bSorted = false;
      oSettings.bFiltered = false;
      oSettings.bDrawing = false;
    }
    /**
	 * Redraw the table - taking account of the various features which are enabled
	 *  @param {object} oSettings dataTables settings object
	 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	 *    the paging is reset to the first page
	 *  @memberof DataTable#oApi
	 */
    function _fnReDraw(settings, holdPosition) {
      var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
      if (sort) {
        _fnSort(settings);
      }
      if (filter) {
        _fnFilterComplete(settings, settings.oPreviousSearch);
      } else {
        // No filtering, so we want to just use the display master
        settings.aiDisplay = settings.aiDisplayMaster.slice();
      }
      if (holdPosition !== true) {
        settings._iDisplayStart = 0;
      }
      // Let any modules know about the draw hold position state (used by
      // scrolling internally)
      settings._drawHold = holdPosition;
      _fnDraw(settings);
      settings._drawHold = false;
    }
    /**
	 * Add the options to the page HTML for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnAddOptionsHtml(oSettings) {
      var classes = oSettings.oClasses;
      var table = $(oSettings.nTable);
      var holding = $('<div/>').insertBefore(table);
      // Holding element for speed
      var features = oSettings.oFeatures;
      // All DataTables are wrapped in a div
      var insert = $('<div/>', {
          id: oSettings.sTableId + '_wrapper',
          'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
        });
      oSettings.nHolding = holding[0];
      oSettings.nTableWrapper = insert[0];
      oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
      /* Loop over the user set positioning and place the elements as needed */
      var aDom = oSettings.sDom.split('');
      var featureNode, cOption, nNewNode, cNext, sAttr, j;
      for (var i = 0; i < aDom.length; i++) {
        featureNode = null;
        cOption = aDom[i];
        if (cOption == '<') {
          /* New container div */
          nNewNode = $('<div/>')[0];
          /* Check to see if we should append an id and/or a class name to the container */
          cNext = aDom[i + 1];
          if (cNext == '\'' || cNext == '"') {
            sAttr = '';
            j = 2;
            while (aDom[i + j] != cNext) {
              sAttr += aDom[i + j];
              j++;
            }
            /* Replace jQuery UI constants @todo depreciated */
            if (sAttr == 'H') {
              sAttr = classes.sJUIHeader;
            } else if (sAttr == 'F') {
              sAttr = classes.sJUIFooter;
            }
            /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
					 * breaks the string into parts and applies them as needed
					 */
            if (sAttr.indexOf('.') != -1) {
              var aSplit = sAttr.split('.');
              nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
              nNewNode.className = aSplit[1];
            } else if (sAttr.charAt(0) == '#') {
              nNewNode.id = sAttr.substr(1, sAttr.length - 1);
            } else {
              nNewNode.className = sAttr;
            }
            i += j;  /* Move along the position array */
          }
          insert.append(nNewNode);
          insert = $(nNewNode);
        } else if (cOption == '>') {
          /* End container div */
          insert = insert.parent();
        }  // @todo Move options into their own plugins?
        else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
          /* Length */
          featureNode = _fnFeatureHtmlLength(oSettings);
        } else if (cOption == 'f' && features.bFilter) {
          /* Filter */
          featureNode = _fnFeatureHtmlFilter(oSettings);
        } else if (cOption == 'r' && features.bProcessing) {
          /* pRocessing */
          featureNode = _fnFeatureHtmlProcessing(oSettings);
        } else if (cOption == 't') {
          /* Table */
          featureNode = _fnFeatureHtmlTable(oSettings);
        } else if (cOption == 'i' && features.bInfo) {
          /* Info */
          featureNode = _fnFeatureHtmlInfo(oSettings);
        } else if (cOption == 'p' && features.bPaginate) {
          /* Pagination */
          featureNode = _fnFeatureHtmlPaginate(oSettings);
        } else if (DataTable.ext.feature.length !== 0) {
          /* Plug-in features */
          var aoFeatures = DataTable.ext.feature;
          for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
            if (cOption == aoFeatures[k].cFeature) {
              featureNode = aoFeatures[k].fnInit(oSettings);
              break;
            }
          }
        }
        /* Add to the 2D features array */
        if (featureNode) {
          var aanFeatures = oSettings.aanFeatures;
          if (!aanFeatures[cOption]) {
            aanFeatures[cOption] = [];
          }
          aanFeatures[cOption].push(featureNode);
          insert.append(featureNode);
        }
      }
      /* Built our DOM structure - replace the holding div with what we want */
      holding.replaceWith(insert);
    }
    /**
	 * Use the DOM source to create up an array of header cells. The idea here is to
	 * create a layout grid (array) of rows x columns, which contains a reference
	 * to the cell that that point in the grid (regardless of col/rowspan), such that
	 * any column / row could be removed and the new grid constructed
	 *  @param array {object} aLayout Array to store the calculated layout in
	 *  @param {node} nThead The header/footer element for the table
	 *  @memberof DataTable#oApi
	 */
    function _fnDetectHeader(aLayout, nThead) {
      var nTrs = $(nThead).children('tr');
      var nTr, nCell;
      var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
      var bUnique;
      var fnShiftCol = function (a, i, j) {
        var k = a[i];
        while (k[j]) {
          j++;
        }
        return j;
      };
      aLayout.splice(0, aLayout.length);
      /* We know how many rows there are in the layout - so prep it */
      for (i = 0, iLen = nTrs.length; i < iLen; i++) {
        aLayout.push([]);
      }
      /* Calculate a layout array */
      for (i = 0, iLen = nTrs.length; i < iLen; i++) {
        nTr = nTrs[i];
        iColumn = 0;
        /* For every cell in the row... */
        nCell = nTr.firstChild;
        while (nCell) {
          if (nCell.nodeName.toUpperCase() == 'TD' || nCell.nodeName.toUpperCase() == 'TH') {
            /* Get the col and rowspan attributes from the DOM and sanitise them */
            iColspan = nCell.getAttribute('colspan') * 1;
            iRowspan = nCell.getAttribute('rowspan') * 1;
            iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
            iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
            /* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
            iColShifted = fnShiftCol(aLayout, i, iColumn);
            /* Cache calculation for unique columns */
            bUnique = iColspan === 1 ? true : false;
            /* If there is col / rowspan, copy the information into the layout grid */
            for (l = 0; l < iColspan; l++) {
              for (k = 0; k < iRowspan; k++) {
                aLayout[i + k][iColShifted + l] = {
                  'cell': nCell,
                  'unique': bUnique
                };
                aLayout[i + k].nTr = nTr;
              }
            }
          }
          nCell = nCell.nextSibling;
        }
      }
    }
    /**
	 * Get an array of unique th elements, one for each column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nHeader automatically detect the layout from this node - optional
	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	 *  @returns array {node} aReturn list of unique th's
	 *  @memberof DataTable#oApi
	 */
    function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
      var aReturn = [];
      if (!aLayout) {
        aLayout = oSettings.aoHeader;
        if (nHeader) {
          aLayout = [];
          _fnDetectHeader(aLayout, nHeader);
        }
      }
      for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
        for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
          if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
            aReturn[j] = aLayout[i][j].cell;
          }
        }
      }
      return aReturn;
    }
    /**
	 * Create an Ajax call based on the table's settings, taking into account that
	 * parameters can have multiple forms, and backwards compatibility.
	 *
	 * @param {object} oSettings dataTables settings object
	 * @param {array} data Data to send to the server, required by
	 *     DataTables - may be augmented by developer callbacks
	 * @param {function} fn Callback function to run when data is obtained
	 */
    function _fnBuildAjax(oSettings, data, fn) {
      // Compatibility with 1.9-, allow fnServerData and event to manipulate
      _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);
      // Convert to object based for 1.10+ if using the old array scheme which can
      // come from server-side processing or serverParams
      if (data && $.isArray(data)) {
        var tmp = {};
        var rbracket = /(.*?)\[\]$/;
        $.each(data, function (key, val) {
          var match = val.name.match(rbracket);
          if (match) {
            // Support for arrays
            var name = match[0];
            if (!tmp[name]) {
              tmp[name] = [];
            }
            tmp[name].push(val.value);
          } else {
            tmp[val.name] = val.value;
          }
        });
        data = tmp;
      }
      var ajaxData;
      var ajax = oSettings.ajax;
      var instance = oSettings.oInstance;
      var callback = function (json) {
        _fnCallbackFire(oSettings, null, 'xhr', [
          oSettings,
          json,
          oSettings.jqXHR
        ]);
        fn(json);
      };
      if ($.isPlainObject(ajax) && ajax.data) {
        ajaxData = ajax.data;
        var newData = $.isFunction(ajaxData) ? ajaxData(data, oSettings) : ajaxData;
        // an object object or array to merge
        // If the function returned something, use that alone
        data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData);
        // Remove the data property as we've resolved it already and don't want
        // jQuery to do it again (it is restored at the end of the function)
        delete ajax.data;
      }
      var baseAjax = {
          'data': data,
          'success': function (json) {
            var error = json.error || json.sError;
            if (error) {
              _fnLog(oSettings, 0, error);
            }
            oSettings.json = json;
            callback(json);
          },
          'dataType': 'json',
          'cache': false,
          'type': oSettings.sServerMethod,
          'error': function (xhr, error, thrown) {
            var ret = _fnCallbackFire(oSettings, null, 'xhr', [
                oSettings,
                null,
                oSettings.jqXHR
              ]);
            if ($.inArray(true, ret) === -1) {
              if (error == 'parsererror') {
                _fnLog(oSettings, 0, 'Invalid JSON response', 1);
              } else if (xhr.readyState === 4) {
                _fnLog(oSettings, 0, 'Ajax error', 7);
              }
            }
            _fnProcessingDisplay(oSettings, false);
          }
        };
      // Store the data submitted for the API
      oSettings.oAjaxData = data;
      // Allow plug-ins and external processes to modify the data
      _fnCallbackFire(oSettings, null, 'preXhr', [
        oSettings,
        data
      ]);
      if (oSettings.fnServerData) {
        // DataTables 1.9- compatibility
        oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
          // Need to convert back to 1.9 trad format
          return {
            name: key,
            value: val
          };
        }), callback, oSettings);
      } else if (oSettings.sAjaxSource || typeof ajax === 'string') {
        // DataTables 1.9- compatibility
        oSettings.jqXHR = $.ajax($.extend(baseAjax, { url: ajax || oSettings.sAjaxSource }));
      } else if ($.isFunction(ajax)) {
        // Is a function - let the caller define what needs to be done
        oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
      } else {
        // Object to extend the base settings
        oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));
        // Restore for next time around
        ajax.data = ajaxData;
      }
    }
    /**
	 * Update the table using an Ajax call
	 *  @param {object} settings dataTables settings object
	 *  @returns {boolean} Block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
    function _fnAjaxUpdate(settings) {
      if (settings.bAjaxDataGet) {
        settings.iDraw++;
        _fnProcessingDisplay(settings, true);
        _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
          _fnAjaxUpdateDraw(settings, json);
        });
        return false;
      }
      return true;
    }
    /**
	 * Build up the parameters in an object needed for a server-side processing
	 * request. Note that this is basically done twice, is different ways - a modern
	 * method which is used by default in DataTables 1.10 which uses objects and
	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	 * option is set.
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {bool} block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
    function _fnAjaxParameters(settings) {
      var columns = settings.aoColumns, columnCount = columns.length, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, i, data = [], dataProp, column, columnSearch, sort = _fnSortFlatten(settings), displayStart = settings._iDisplayStart, displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;
      var param = function (name, value) {
        data.push({
          'name': name,
          'value': value
        });
      };
      // DataTables 1.9- compatible method
      param('sEcho', settings.iDraw);
      param('iColumns', columnCount);
      param('sColumns', _pluck(columns, 'sName').join(','));
      param('iDisplayStart', displayStart);
      param('iDisplayLength', displayLength);
      // DataTables 1.10+ method
      var d = {
          draw: settings.iDraw,
          columns: [],
          order: [],
          start: displayStart,
          length: displayLength,
          search: {
            value: preSearch.sSearch,
            regex: preSearch.bRegex
          }
        };
      for (i = 0; i < columnCount; i++) {
        column = columns[i];
        columnSearch = preColSearch[i];
        dataProp = typeof column.mData == 'function' ? 'function' : column.mData;
        d.columns.push({
          data: dataProp,
          name: column.sName,
          searchable: column.bSearchable,
          orderable: column.bSortable,
          search: {
            value: columnSearch.sSearch,
            regex: columnSearch.bRegex
          }
        });
        param('mDataProp_' + i, dataProp);
        if (features.bFilter) {
          param('sSearch_' + i, columnSearch.sSearch);
          param('bRegex_' + i, columnSearch.bRegex);
          param('bSearchable_' + i, column.bSearchable);
        }
        if (features.bSort) {
          param('bSortable_' + i, column.bSortable);
        }
      }
      if (features.bFilter) {
        param('sSearch', preSearch.sSearch);
        param('bRegex', preSearch.bRegex);
      }
      if (features.bSort) {
        $.each(sort, function (i, val) {
          d.order.push({
            column: val.col,
            dir: val.dir
          });
          param('iSortCol_' + i, val.col);
          param('sSortDir_' + i, val.dir);
        });
        param('iSortingCols', sort.length);
      }
      // If the legacy.ajax parameter is null, then we automatically decide which
      // form to use, based on sAjaxSource
      var legacy = DataTable.ext.legacy.ajax;
      if (legacy === null) {
        return settings.sAjaxSource ? data : d;
      }
      // Otherwise, if legacy has been specified then we use that to decide on the
      // form
      return legacy ? data : d;
    }
    /**
	 * Data the data from the server (nuking the old) and redraw the table
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} json json data return from the server.
	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	 *  @param {array} json.aaData The data to display on this page
	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	 *  @memberof DataTable#oApi
	 */
    function _fnAjaxUpdateDraw(settings, json) {
      // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
      // Support both
      var compat = function (old, modern) {
        return json[old] !== undefined ? json[old] : json[modern];
      };
      var data = _fnAjaxDataSrc(settings, json);
      var draw = compat('sEcho', 'draw');
      var recordsTotal = compat('iTotalRecords', 'recordsTotal');
      var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');
      if (draw) {
        // Protect against out of sequence returns
        if (draw * 1 < settings.iDraw) {
          return;
        }
        settings.iDraw = draw * 1;
      }
      _fnClearTable(settings);
      settings._iRecordsTotal = parseInt(recordsTotal, 10);
      settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
      for (var i = 0, ien = data.length; i < ien; i++) {
        _fnAddData(settings, data[i]);
      }
      settings.aiDisplay = settings.aiDisplayMaster.slice();
      settings.bAjaxDataGet = false;
      _fnDraw(settings);
      if (!settings._bInitComplete) {
        _fnInitComplete(settings, json);
      }
      settings.bAjaxDataGet = true;
      _fnProcessingDisplay(settings, false);
    }
    /**
	 * Get the data from the JSON data source to use for drawing a table. Using
	 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	 * source object, or from a processing function.
	 *  @param {object} oSettings dataTables settings object
	 *  @param  {object} json Data source object / array from the server
	 *  @return {array} Array of data to use
	 */
    function _fnAjaxDataSrc(oSettings, json) {
      var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp;
      // Compatibility with 1.9-.
      // Compatibility with 1.9-. In order to read from aaData, check if the
      // default has been changed, if not, check for aaData
      if (dataSrc === 'data') {
        return json.aaData || json[dataSrc];
      }
      return dataSrc !== '' ? _fnGetObjectDataFn(dataSrc)(json) : json;
    }
    /**
	 * Generate the node required for filtering text
	 *  @returns {node} Filter control element
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnFeatureHtmlFilter(settings) {
      var classes = settings.oClasses;
      var tableId = settings.sTableId;
      var language = settings.oLanguage;
      var previousSearch = settings.oPreviousSearch;
      var features = settings.aanFeatures;
      var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
      var str = language.sSearch;
      str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;
      var filter = $('<div/>', {
          'id': !features.f ? tableId + '_filter' : null,
          'class': classes.sFilter
        }).append($('<label/>').append(str));
      var searchFn = function () {
        /* Update all other filter input elements for the new display */
        var n = features.f;
        var val = !this.value ? '' : this.value;
        // mental IE8 fix :-(
        /* Now do the filter */
        if (val != previousSearch.sSearch) {
          _fnFilterComplete(settings, {
            'sSearch': val,
            'bRegex': previousSearch.bRegex,
            'bSmart': previousSearch.bSmart,
            'bCaseInsensitive': previousSearch.bCaseInsensitive
          });
          // Need to redraw, without resorting
          settings._iDisplayStart = 0;
          _fnDraw(settings);
        }
      };
      var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;
      var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).bind('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).bind('keypress.DT', function (e) {
          /* Prevent form submission */
          if (e.keyCode == 13) {
            return false;
          }
        }).attr('aria-controls', tableId);
      // Update the input elements whenever the table is filtered
      $(settings.nTable).on('search.dt.DT', function (ev, s) {
        if (settings === s) {
          // IE9 throws an 'unknown error' if document.activeElement is used
          // inside an iframe or frame...
          try {
            if (jqFilter[0] !== document.activeElement) {
              jqFilter.val(previousSearch.sSearch);
            }
          } catch (e) {
          }
        }
      });
      return filter[0];
    }
    /**
	 * Filter the table using both the global filter and column based filtering
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oSearch search information
	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	 *  @memberof DataTable#oApi
	 */
    function _fnFilterComplete(oSettings, oInput, iForce) {
      var oPrevSearch = oSettings.oPreviousSearch;
      var aoPrevSearch = oSettings.aoPreSearchCols;
      var fnSaveFilter = function (oFilter) {
        /* Save the filtering values */
        oPrevSearch.sSearch = oFilter.sSearch;
        oPrevSearch.bRegex = oFilter.bRegex;
        oPrevSearch.bSmart = oFilter.bSmart;
        oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
      };
      var fnRegex = function (o) {
        // Backwards compatibility with the bEscapeRegex option
        return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
      };
      // Resolve any column types that are unknown due to addition or invalidation
      // @todo As per sort - can this be moved into an event handler?
      _fnColumnTypes(oSettings);
      /* In server-side processing all filtering is done by the server, so no point hanging around here */
      if (_fnDataSource(oSettings) != 'ssp') {
        /* Global filter */
        _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
        fnSaveFilter(oInput);
        /* Now do the individual column filter */
        for (var i = 0; i < aoPrevSearch.length; i++) {
          _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
        }
        /* Custom filtering */
        _fnFilterCustom(oSettings);
      } else {
        fnSaveFilter(oInput);
      }
      /* Tell the draw function we have been filtering */
      oSettings.bFiltered = true;
      _fnCallbackFire(oSettings, null, 'search', [oSettings]);
    }
    /**
	 * Apply custom filtering functions
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnFilterCustom(settings) {
      var filters = DataTable.ext.search;
      var displayRows = settings.aiDisplay;
      var row, rowIdx;
      for (var i = 0, ien = filters.length; i < ien; i++) {
        var rows = [];
        // Loop over each row and see if it should be included
        for (var j = 0, jen = displayRows.length; j < jen; j++) {
          rowIdx = displayRows[j];
          row = settings.aoData[rowIdx];
          if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
            rows.push(rowIdx);
          }
        }
        // So the array reference doesn't break set the results into the
        // existing array
        displayRows.length = 0;
        displayRows.push.apply(displayRows, rows);
      }
    }
    /**
	 * Filter the table on a per-column basis
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sInput string to filter on
	 *  @param {int} iColumn column to filter
	 *  @param {bool} bRegex treat search string as a regular expression or not
	 *  @param {bool} bSmart use smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
    function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
      if (searchStr === '') {
        return;
      }
      var data;
      var display = settings.aiDisplay;
      var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);
      for (var i = display.length - 1; i >= 0; i--) {
        data = settings.aoData[display[i]]._aFilterData[colIdx];
        if (!rpSearch.test(data)) {
          display.splice(i, 1);
        }
      }
    }
    /**
	 * Filter the data table based on user input and draw the table
	 *  @param {object} settings dataTables settings object
	 *  @param {string} input string to filter on
	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	 *  @param {bool} regex treat as a regular expression or not
	 *  @param {bool} smart perform smart filtering or not
	 *  @param {bool} caseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
    function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
      var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
      var prevSearch = settings.oPreviousSearch.sSearch;
      var displayMaster = settings.aiDisplayMaster;
      var display, invalidated, i;
      // Need to take account of custom filtering functions - always filter
      if (DataTable.ext.search.length !== 0) {
        force = true;
      }
      // Check if any of the rows were invalidated
      invalidated = _fnFilterData(settings);
      // If the input is blank - we just want the full data set
      if (input.length <= 0) {
        settings.aiDisplay = displayMaster.slice();
      } else {
        // New search - start from the master array
        if (invalidated || force || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted) {
          settings.aiDisplay = displayMaster.slice();
        }
        // Search the display array
        display = settings.aiDisplay;
        for (i = display.length - 1; i >= 0; i--) {
          if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
            display.splice(i, 1);
          }
        }
      }
    }
    /**
	 * Build a regular expression object suitable for searching a table
	 *  @param {string} sSearch string to search for
	 *  @param {bool} bRegex treat as a regular expression or not
	 *  @param {bool} bSmart perform smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @returns {RegExp} constructed object
	 *  @memberof DataTable#oApi
	 */
    function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
      search = regex ? search : _fnEscapeRegex(search);
      if (smart) {
        /* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 * 
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
        var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
            if (word.charAt(0) === '"') {
              var m = word.match(/^"(.*)"$/);
              word = m ? m[1] : word;
            }
            return word.replace('"', '');
          });
        search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
      }
      return new RegExp(search, caseInsensitive ? 'i' : '');
    }
    /**
	 * Escape a string such that it can be used in a regular expression
	 *  @param {string} sVal string to escape
	 *  @returns {string} escaped string
	 *  @memberof DataTable#oApi
	 */
    function _fnEscapeRegex(sVal) {
      return sVal.replace(_re_escape_regex, '\\$1');
    }
    var __filter_div = $('<div>')[0];
    var __filter_div_textContent = __filter_div.textContent !== undefined;
    // Update the filtering data for each row if needed (by invalidation or first run)
    function _fnFilterData(settings) {
      var columns = settings.aoColumns;
      var column;
      var i, j, ien, jen, filterData, cellData, row;
      var fomatters = DataTable.ext.type.search;
      var wasInvalidated = false;
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        row = settings.aoData[i];
        if (!row._aFilterData) {
          filterData = [];
          for (j = 0, jen = columns.length; j < jen; j++) {
            column = columns[j];
            if (column.bSearchable) {
              cellData = _fnGetCellData(settings, i, j, 'filter');
              if (fomatters[column.sType]) {
                cellData = fomatters[column.sType](cellData);
              }
              // Search in DataTables 1.10 is string based. In 1.11 this
              // should be altered to also allow strict type checking.
              if (cellData === null) {
                cellData = '';
              }
              if (typeof cellData !== 'string' && cellData.toString) {
                cellData = cellData.toString();
              }
            } else {
              cellData = '';
            }
            // If it looks like there is an HTML entity in the string,
            // attempt to decode it so sorting works as expected. Note that
            // we could use a single line of jQuery to do this, but the DOM
            // method used here is much faster http://jsperf.com/html-decode
            if (cellData.indexOf && cellData.indexOf('&') !== -1) {
              __filter_div.innerHTML = cellData;
              cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
            }
            if (cellData.replace) {
              cellData = cellData.replace(/[\r\n]/g, '');
            }
            filterData.push(cellData);
          }
          row._aFilterData = filterData;
          row._sFilterRow = filterData.join('  ');
          wasInvalidated = true;
        }
      }
      return wasInvalidated;
    }
    /**
	 * Convert from the internal Hungarian notation to camelCase for external
	 * interaction
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
    function _fnSearchToCamel(obj) {
      return {
        search: obj.sSearch,
        smart: obj.bSmart,
        regex: obj.bRegex,
        caseInsensitive: obj.bCaseInsensitive
      };
    }
    /**
	 * Convert from camelCase notation to the internal Hungarian. We could use the
	 * Hungarian convert function here, but this is cleaner
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
    function _fnSearchToHung(obj) {
      return {
        sSearch: obj.search,
        bSmart: obj.smart,
        bRegex: obj.regex,
        bCaseInsensitive: obj.caseInsensitive
      };
    }
    /**
	 * Generate the node required for the info display
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Information element
	 *  @memberof DataTable#oApi
	 */
    function _fnFeatureHtmlInfo(settings) {
      var tid = settings.sTableId, nodes = settings.aanFeatures.i, n = $('<div/>', {
          'class': settings.oClasses.sInfo,
          'id': !nodes ? tid + '_info' : null
        });
      if (!nodes) {
        // Update display on each draw
        settings.aoDrawCallback.push({
          'fn': _fnUpdateInfo,
          'sName': 'information'
        });
        n.attr('role', 'status').attr('aria-live', 'polite');
        // Table is described by our info div
        $(settings.nTable).attr('aria-describedby', tid + '_info');
      }
      return n[0];
    }
    /**
	 * Update the information elements in the display
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnUpdateInfo(settings) {
      /* Show information about the table */
      var nodes = settings.aanFeatures.i;
      if (nodes.length === 0) {
        return;
      }
      var lang = settings.oLanguage, start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? lang.sInfo : lang.sInfoEmpty;
      if (total !== max) {
        /* Record set after filtering */
        out += ' ' + lang.sInfoFiltered;
      }
      // Convert the macros
      out += lang.sInfoPostFix;
      out = _fnInfoMacros(settings, out);
      var callback = lang.fnInfoCallback;
      if (callback !== null) {
        out = callback.call(settings.oInstance, settings, start, end, max, total, out);
      }
      $(nodes).html(out);
    }
    function _fnInfoMacros(settings, str) {
      // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
      // internally
      var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), all = len === -1;
      return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
    }
    /**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnInitialise(settings) {
      var i, iLen, iAjaxStart = settings.iInitDisplayStart;
      var columns = settings.aoColumns, column;
      var features = settings.oFeatures;
      /* Ensure that the table data is fully initialised */
      if (!settings.bInitialised) {
        setTimeout(function () {
          _fnInitialise(settings);
        }, 200);
        return;
      }
      /* Show the display HTML options */
      _fnAddOptionsHtml(settings);
      /* Build and draw the header / footer for the table */
      _fnBuildHead(settings);
      _fnDrawHead(settings, settings.aoHeader);
      _fnDrawHead(settings, settings.aoFooter);
      /* Okay to show that something is going on now */
      _fnProcessingDisplay(settings, true);
      /* Calculate sizes for columns */
      if (features.bAutoWidth) {
        _fnCalculateColumnWidths(settings);
      }
      for (i = 0, iLen = columns.length; i < iLen; i++) {
        column = columns[i];
        if (column.sWidth) {
          column.nTh.style.width = _fnStringToCss(column.sWidth);
        }
      }
      // If there is default sorting required - let's do it. The sort function
      // will do the drawing for us. Otherwise we draw the table regardless of the
      // Ajax source - this allows the table to look initialised for Ajax sourcing
      // data (show 'loading' message possibly)
      _fnReDraw(settings);
      // Server-side processing init complete is done by _fnAjaxUpdateDraw
      var dataSrc = _fnDataSource(settings);
      if (dataSrc != 'ssp') {
        // if there is an ajax source load the data
        if (dataSrc == 'ajax') {
          _fnBuildAjax(settings, [], function (json) {
            var aData = _fnAjaxDataSrc(settings, json);
            // Got the data - add it to the table
            for (i = 0; i < aData.length; i++) {
              _fnAddData(settings, aData[i]);
            }
            // Reset the init display for cookie saving. We've already done
            // a filter, and therefore cleared it before. So we need to make
            // it appear 'fresh'
            settings.iInitDisplayStart = iAjaxStart;
            _fnReDraw(settings);
            _fnProcessingDisplay(settings, false);
            _fnInitComplete(settings, json);
          }, settings);
        } else {
          _fnProcessingDisplay(settings, false);
          _fnInitComplete(settings);
        }
      }
    }
    /**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	 *    with client-side processing (optional)
	 *  @memberof DataTable#oApi
	 */
    function _fnInitComplete(settings, json) {
      settings._bInitComplete = true;
      // On an Ajax load we now have data and therefore want to apply the column
      // sizing
      if (json) {
        _fnAdjustColumnSizing(settings);
      }
      _fnCallbackFire(settings, 'aoInitComplete', 'init', [
        settings,
        json
      ]);
    }
    function _fnLengthChange(settings, val) {
      var len = parseInt(val, 10);
      settings._iDisplayLength = len;
      _fnLengthOverflow(settings);
      // Fire length change event
      _fnCallbackFire(settings, null, 'length', [
        settings,
        len
      ]);
    }
    /**
	 * Generate the node required for user display length changing
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Display length feature node
	 *  @memberof DataTable#oApi
	 */
    function _fnFeatureHtmlLength(settings) {
      var classes = settings.oClasses, tableId = settings.sTableId, menu = settings.aLengthMenu, d2 = $.isArray(menu[0]), lengths = d2 ? menu[0] : menu, language = d2 ? menu[1] : menu;
      var select = $('<select/>', {
          'name': tableId + '_length',
          'aria-controls': tableId,
          'class': classes.sLengthSelect
        });
      for (var i = 0, ien = lengths.length; i < ien; i++) {
        select[0][i] = new Option(language[i], lengths[i]);
      }
      var div = $('<div><label/></div>').addClass(classes.sLength);
      if (!settings.aanFeatures.l) {
        div[0].id = tableId + '_length';
      }
      div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML));
      // Can't use `select` variable as user might provide their own and the
      // reference is broken by the use of outerHTML
      $('select', div).val(settings._iDisplayLength).bind('change.DT', function (e) {
        _fnLengthChange(settings, $(this).val());
        _fnDraw(settings);
      });
      // Update node value whenever anything changes the table's length
      $(settings.nTable).bind('length.dt.DT', function (e, s, len) {
        if (settings === s) {
          $('select', div).val(len);
        }
      });
      return div[0];
    }
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
    /**
	 * Generate the node required for default pagination
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Pagination feature node
	 *  @memberof DataTable#oApi
	 */
    function _fnFeatureHtmlPaginate(settings) {
      var type = settings.sPaginationType, plugin = DataTable.ext.pager[type], modern = typeof plugin === 'function', redraw = function (settings) {
          _fnDraw(settings);
        }, node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0], features = settings.aanFeatures;
      if (!modern) {
        plugin.fnInit(settings, node, redraw);
      }
      /* Add a draw callback for the pagination on first instance, to update the paging display */
      if (!features.p) {
        node.id = settings.sTableId + '_paginate';
        settings.aoDrawCallback.push({
          'fn': function (settings) {
            if (modern) {
              var start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin(page, pages), i, ien;
              for (i = 0, ien = features.p.length; i < ien; i++) {
                _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
              }
            } else {
              plugin.fnUpdate(settings, redraw);
            }
          },
          'sName': 'pagination'
        });
      }
      return node;
    }
    /**
	 * Alter the display settings to change the page
	 *  @param {object} settings DataTables settings object
	 *  @param {string|int} action Paging action to take: "first", "previous",
	 *    "next" or "last" or page number to jump to (integer)
	 *  @param [bool] redraw Automatically draw the update or not
	 *  @returns {bool} true page has changed, false - no change
	 *  @memberof DataTable#oApi
	 */
    function _fnPageChange(settings, action, redraw) {
      var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
      if (records === 0 || len === -1) {
        start = 0;
      } else if (typeof action === 'number') {
        start = action * len;
        if (start > records) {
          start = 0;
        }
      } else if (action == 'first') {
        start = 0;
      } else if (action == 'previous') {
        start = len >= 0 ? start - len : 0;
        if (start < 0) {
          start = 0;
        }
      } else if (action == 'next') {
        if (start + len < records) {
          start += len;
        }
      } else if (action == 'last') {
        start = Math.floor((records - 1) / len) * len;
      } else {
        _fnLog(settings, 0, 'Unknown paging action: ' + action, 5);
      }
      var changed = settings._iDisplayStart !== start;
      settings._iDisplayStart = start;
      if (changed) {
        _fnCallbackFire(settings, null, 'page', [settings]);
        if (redraw) {
          _fnDraw(settings);
        }
      }
      return changed;
    }
    /**
	 * Generate the node required for the processing node
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Processing element
	 *  @memberof DataTable#oApi
	 */
    function _fnFeatureHtmlProcessing(settings) {
      return $('<div/>', {
        'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
        'class': settings.oClasses.sProcessing
      }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
    }
    /**
	 * Display or hide the processing indicator
	 *  @param {object} settings dataTables settings object
	 *  @param {bool} show Show the processing indicator (true) or not (false)
	 *  @memberof DataTable#oApi
	 */
    function _fnProcessingDisplay(settings, show) {
      if (settings.oFeatures.bProcessing) {
        $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
      }
      _fnCallbackFire(settings, null, 'processing', [
        settings,
        show
      ]);
    }
    /**
	 * Add any control elements for the table - specifically scrolling
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Node to add to the DOM
	 *  @memberof DataTable#oApi
	 */
    function _fnFeatureHtmlTable(settings) {
      var table = $(settings.nTable);
      // Add the ARIA grid role to the table
      table.attr('role', 'grid');
      // Scrolling from here on in
      var scroll = settings.oScroll;
      if (scroll.sX === '' && scroll.sY === '') {
        return settings.nTable;
      }
      var scrollX = scroll.sX;
      var scrollY = scroll.sY;
      var classes = settings.oClasses;
      var caption = table.children('caption');
      var captionSide = caption.length ? caption[0]._captionSide : null;
      var headerClone = $(table[0].cloneNode(false));
      var footerClone = $(table[0].cloneNode(false));
      var footer = table.children('tfoot');
      var _div = '<div/>';
      var size = function (s) {
        return !s ? null : _fnStringToCss(s);
      };
      // This is fairly messy, but with x scrolling enabled, if the table has a
      // width attribute, regardless of any width applied using the column width
      // options, the browser will shrink or grow the table as needed to fit into
      // that 100%. That would make the width options useless. So we remove it.
      // This is okay, under the assumption that width:100% is applied to the
      // table in CSS (it is in the default stylesheet) which will set the table
      // width as appropriate (the attribute and css behave differently...)
      if (scroll.sX && table.attr('width') === '100%') {
        table.removeAttr('width');
      }
      if (!footer.length) {
        footer = null;
      }
      /*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
      var scroller = $(_div, { 'class': classes.sScrollWrapper }).append($(_div, { 'class': classes.sScrollHead }).css({
          overflow: 'hidden',
          position: 'relative',
          border: 0,
          width: scrollX ? size(scrollX) : '100%'
        }).append($(_div, { 'class': classes.sScrollHeadInner }).css({
          'box-sizing': 'content-box',
          width: scroll.sXInner || '100%'
        }).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, { 'class': classes.sScrollBody }).css({
          overflow: 'auto',
          height: size(scrollY),
          width: size(scrollX)
        }).append(table));
      if (footer) {
        scroller.append($(_div, { 'class': classes.sScrollFoot }).css({
          overflow: 'hidden',
          border: 0,
          width: scrollX ? size(scrollX) : '100%'
        }).append($(_div, { 'class': classes.sScrollFootInner }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
      }
      var children = scroller.children();
      var scrollHead = children[0];
      var scrollBody = children[1];
      var scrollFoot = footer ? children[2] : null;
      // When the body is scrolled, then we also want to scroll the headers
      if (scrollX) {
        $(scrollBody).on('scroll.DT', function (e) {
          var scrollLeft = this.scrollLeft;
          scrollHead.scrollLeft = scrollLeft;
          if (footer) {
            scrollFoot.scrollLeft = scrollLeft;
          }
        });
      }
      settings.nScrollHead = scrollHead;
      settings.nScrollBody = scrollBody;
      settings.nScrollFoot = scrollFoot;
      // On redraw - align columns
      settings.aoDrawCallback.push({
        'fn': _fnScrollDraw,
        'sName': 'scrolling'
      });
      return scroller[0];
    }
    /**
	 * Update the header, footer and body tables for resizing - i.e. column
	 * alignment.
	 *
	 * Welcome to the most horrible function DataTables. The process that this
	 * function follows is basically:
	 *   1. Re-create the table inside the scrolling div
	 *   2. Take live measurements from the DOM
	 *   3. Apply the measurements to align the columns
	 *   4. Clean up
	 *
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnScrollDraw(settings) {
      // Given that this is such a monster function, a lot of variables are use
      // to try and keep the minimised size as small as possible
      var scroll = settings.oScroll, scrollX = scroll.sX, scrollXInner = scroll.sXInner, scrollY = scroll.sY, barWidth = scroll.iBarWidth, divHeader = $(settings.nScrollHead), divHeaderStyle = divHeader[0].style, divHeaderInner = divHeader.children('div'), divHeaderInnerStyle = divHeaderInner[0].style, divHeaderTable = divHeaderInner.children('table'), divBodyEl = settings.nScrollBody, divBody = $(divBodyEl), divBodyStyle = divBodyEl.style, divFooter = $(settings.nScrollFoot), divFooterInner = divFooter.children('div'), divFooterTable = divFooterInner.children('table'), header = $(settings.nTHead), table = $(settings.nTable), tableEl = table[0], tableStyle = tableEl.style, footer = settings.nTFoot ? $(settings.nTFoot) : null, browser = settings.oBrowser, ie67 = browser.bScrollOversize, headerTrgEls, footerTrgEls, headerSrcEls, footerSrcEls, headerCopy, footerCopy, headerWidths = [], footerWidths = [], headerContent = [], idx, correction, sanityWidth, zeroOut = function (nSizer) {
          var style = nSizer.style;
          style.paddingTop = '0';
          style.paddingBottom = '0';
          style.borderTopWidth = '0';
          style.borderBottomWidth = '0';
          style.height = 0;
        };
      /*
		 * 1. Re-create the table inside the scrolling div
		 */
      // Remove the old minimised thead and tfoot elements in the inner table
      table.children('thead, tfoot').remove();
      // Clone the current header and footer elements and then place it into the inner table
      headerCopy = header.clone().prependTo(table);
      headerTrgEls = header.find('tr');
      // original header is in its own table
      headerSrcEls = headerCopy.find('tr');
      headerCopy.find('th, td').removeAttr('tabindex');
      if (footer) {
        footerCopy = footer.clone().prependTo(table);
        footerTrgEls = footer.find('tr');
        // the original tfoot is in its own table and must be sized
        footerSrcEls = footerCopy.find('tr');
      }
      /*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
      // Remove old sizing and apply the calculated column widths
      // Get the unique column headers in the newly created (cloned) header. We want to apply the
      // calculated sizes to this header
      if (!scrollX) {
        divBodyStyle.width = '100%';
        divHeader[0].style.width = '100%';
      }
      $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
        idx = _fnVisibleToColumnIndex(settings, i);
        el.style.width = settings.aoColumns[idx].sWidth;
      });
      if (footer) {
        _fnApplyToChildren(function (n) {
          n.style.width = '';
        }, footerSrcEls);
      }
      // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
      // will end up forcing the scrollbar to appear, making our measurements wrong for when we
      // then hide it (end of this function), so add the header height to the body scroller.
      if (scroll.bCollapse && scrollY !== '') {
        divBodyStyle.height = divBody[0].offsetHeight + header[0].offsetHeight + 'px';
      }
      // Size the table as a whole
      sanityWidth = table.outerWidth();
      if (scrollX === '') {
        // No x scrolling
        tableStyle.width = '100%';
        // IE7 will make the width of the table when 100% include the scrollbar
        // - which is shouldn't. When there is a scrollbar we need to take this
        // into account.
        if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')) {
          tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
        }
      } else {
        // x scrolling
        if (scrollXInner !== '') {
          // x scroll inner has been given - use it
          tableStyle.width = _fnStringToCss(scrollXInner);
        } else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {
          // There is y-scrolling - try to take account of the y scroll bar
          tableStyle.width = _fnStringToCss(sanityWidth - barWidth);
          if (table.outerWidth() > sanityWidth - barWidth) {
            // Not possible to take account of it
            tableStyle.width = _fnStringToCss(sanityWidth);
          }
        } else {
          // When all else fails
          tableStyle.width = _fnStringToCss(sanityWidth);
        }
      }
      // Recalculate the sanity width - now that we've applied the required width,
      // before it was a temporary variable. This is required because the column
      // width calculation is done before this table DOM is created.
      sanityWidth = table.outerWidth();
      // Hidden header should have zero height, so remove padding and borders. Then
      // set the width based on the real headers
      // Apply all styles in one pass
      _fnApplyToChildren(zeroOut, headerSrcEls);
      // Read all widths in next pass
      _fnApplyToChildren(function (nSizer) {
        headerContent.push(nSizer.innerHTML);
        headerWidths.push(_fnStringToCss($(nSizer).css('width')));
      }, headerSrcEls);
      // Apply all widths in final pass
      _fnApplyToChildren(function (nToSize, i) {
        nToSize.style.width = headerWidths[i];
      }, headerTrgEls);
      $(headerSrcEls).height(0);
      /* Same again with the footer if we have one */
      if (footer) {
        _fnApplyToChildren(zeroOut, footerSrcEls);
        _fnApplyToChildren(function (nSizer) {
          footerWidths.push(_fnStringToCss($(nSizer).css('width')));
        }, footerSrcEls);
        _fnApplyToChildren(function (nToSize, i) {
          nToSize.style.width = footerWidths[i];
        }, footerTrgEls);
        $(footerSrcEls).height(0);
      }
      /*
		 * 3. Apply the measurements
		 */
      // "Hide" the header and footer that we used for the sizing. We need to keep
      // the content of the cell so that the width applied to the header and body
      // both match, but we want to hide it completely. We want to also fix their
      // width to what they currently are
      _fnApplyToChildren(function (nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
        nSizer.style.width = headerWidths[i];
      }, headerSrcEls);
      if (footer) {
        _fnApplyToChildren(function (nSizer, i) {
          nSizer.innerHTML = '';
          nSizer.style.width = footerWidths[i];
        }, footerSrcEls);
      }
      // Sanity check that the table is of a sensible width. If not then we are going to get
      // misalignment - try to prevent this by not allowing the table to shrink below its min width
      if (table.outerWidth() < sanityWidth) {
        // The min width depends upon if we have a vertical scrollbar visible or not */
        correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll' ? sanityWidth + barWidth : sanityWidth;
        // IE6/7 are a law unto themselves...
        if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')) {
          tableStyle.width = _fnStringToCss(correction - barWidth);
        }
        // And give the user a warning that we've stopped the table getting too small
        if (scrollX === '' || scrollXInner !== '') {
          _fnLog(settings, 1, 'Possible column misalignment', 6);
        }
      } else {
        correction = '100%';
      }
      // Apply to the container elements
      divBodyStyle.width = _fnStringToCss(correction);
      divHeaderStyle.width = _fnStringToCss(correction);
      if (footer) {
        settings.nScrollFoot.style.width = _fnStringToCss(correction);
      }
      /*
		 * 4. Clean up
		 */
      if (!scrollY) {
        /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don't want to do it in any other browsers.
			 */
        if (ie67) {
          divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
        }
      }
      if (scrollY && scroll.bCollapse) {
        divBodyStyle.height = _fnStringToCss(scrollY);
        var iExtra = scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth ? barWidth : 0;
        if (tableEl.offsetHeight < divBodyEl.offsetHeight) {
          divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra);
        }
      }
      /* Finally set the width's of the header and footer tables */
      var iOuterWidth = table.outerWidth();
      divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
      divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);
      // Figure out if there are scrollbar present - if so then we need a the header and footer to
      // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
      var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == 'scroll';
      var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
      divHeaderInnerStyle[padding] = bScrolling ? barWidth + 'px' : '0px';
      if (footer) {
        divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
        divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
        divFooterInner[0].style[padding] = bScrolling ? barWidth + 'px' : '0px';
      }
      /* Adjust the position of the header in case we loose the y-scrollbar */
      divBody.scroll();
      // If sorting or filtering has occurred, jump the scrolling back to the top
      // only if we aren't holding the position
      if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
        divBodyEl.scrollTop = 0;
      }
    }
    /**
	 * Apply a given function to the display child nodes of an element array (typically
	 * TD children of TR rows
	 *  @param {function} fn Method to apply to the objects
	 *  @param array {nodes} an1 List of elements to look through for display children
	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	 *  @memberof DataTable#oApi
	 */
    function _fnApplyToChildren(fn, an1, an2) {
      var index = 0, i = 0, iLen = an1.length;
      var nNode1, nNode2;
      while (i < iLen) {
        nNode1 = an1[i].firstChild;
        nNode2 = an2 ? an2[i].firstChild : null;
        while (nNode1) {
          if (nNode1.nodeType === 1) {
            if (an2) {
              fn(nNode1, nNode2, index);
            } else {
              fn(nNode1, index);
            }
            index++;
          }
          nNode1 = nNode1.nextSibling;
          nNode2 = an2 ? nNode2.nextSibling : null;
        }
        i++;
      }
    }
    var __re_html_remove = /<.*?>/g;
    /**
	 * Calculate the width of columns for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnCalculateColumnWidths(oSettings) {
      var table = oSettings.nTable, columns = oSettings.aoColumns, scroll = oSettings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, columnCount = columns.length, visibleColumns = _fnGetColumns(oSettings, 'bVisible'), headerCells = $('th', oSettings.nTHead), tableWidthAttr = table.getAttribute('width'),
        // from DOM element
        tableContainer = table.parentNode, userInputs = false, i, column, columnIdx, width, outerWidth;
      var styleWidth = table.style.width;
      if (styleWidth && styleWidth.indexOf('%') !== -1) {
        tableWidthAttr = styleWidth;
      }
      /* Convert any user input sizes into pixel sizes */
      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];
        if (column.sWidth !== null) {
          column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
          userInputs = true;
        }
      }
      /* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
      if (!userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
        for (i = 0; i < columnCount; i++) {
          columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      } else {
        // Otherwise construct a single row, worst case, table with the widest
        // node in the data, assign any user defined widths, then insert it into
        // the DOM and allow the browser to do all the hard work of calculating
        // table widths
        var tmpTable = $(table).clone().css('visibility', 'hidden').removeAttr('id');
        // Clean up the table body
        tmpTable.find('tbody tr').remove();
        var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));
        // Remove any assigned widths from the footer (from scrolling)
        tmpTable.find('tfoot th, tfoot td').css('width', '');
        // Apply custom sizing to the cloned header
        headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);
        for (i = 0; i < visibleColumns.length; i++) {
          column = columns[visibleColumns[i]];
          headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : '';
        }
        // Find the widest cell for each column and put it into the table
        if (oSettings.aoData.length) {
          for (i = 0; i < visibleColumns.length; i++) {
            columnIdx = visibleColumns[i];
            column = columns[columnIdx];
            $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
          }
        }
        // Table has been built, attach to the document so we can work with it
        tmpTable.appendTo(tableContainer);
        // When scrolling (X or Y) we want to set the width of the table as 
        // appropriate. However, when not scrolling leave the table width as it
        // is. This results in slightly different, but I think correct behaviour
        if (scrollX && scrollXInner) {
          tmpTable.width(scrollXInner);
        } else if (scrollX) {
          tmpTable.css('width', 'auto');
          if (tmpTable.width() < tableContainer.offsetWidth) {
            tmpTable.width(tableContainer.offsetWidth);
          }
        } else if (scrollY) {
          tmpTable.width(tableContainer.offsetWidth);
        } else if (tableWidthAttr) {
          tmpTable.width(tableWidthAttr);
        }
        // Take into account the y scrollbar
        _fnScrollingWidthAdjust(oSettings, tmpTable[0]);
        // Browsers need a bit of a hand when a width is assigned to any columns
        // when x-scrolling as they tend to collapse the table to the min-width,
        // even if we sent the column widths. So we need to keep track of what
        // the table width should be by summing the user given values, and the
        // automatic values
        if (scrollX) {
          var total = 0;
          for (i = 0; i < visibleColumns.length; i++) {
            column = columns[visibleColumns[i]];
            outerWidth = $(headerCells[i]).outerWidth();
            total += column.sWidthOrig === null ? outerWidth : parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width();
          }
          tmpTable.width(_fnStringToCss(total));
          table.style.width = _fnStringToCss(total);
        }
        // Get the width of each column in the constructed table
        for (i = 0; i < visibleColumns.length; i++) {
          column = columns[visibleColumns[i]];
          width = $(headerCells[i]).width();
          if (width) {
            column.sWidth = _fnStringToCss(width);
          }
        }
        table.style.width = _fnStringToCss(tmpTable.css('width'));
        // Finished with the table - ditch it
        tmpTable.remove();
      }
      // If there is a width attr, we want to attach an event listener which
      // allows the table sizing to automatically adjust when the window is
      // resized. Use the width attr rather than CSS, since we can't know if the
      // CSS is a relative value or absolute - DOM read is always px.
      if (tableWidthAttr) {
        table.style.width = _fnStringToCss(tableWidthAttr);
      }
      if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
        var bindResize = function () {
          $(window).bind('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
            _fnAdjustColumnSizing(oSettings);
          }));
        };
        // IE6/7 will crash if we bind a resize event handler on page load.
        // To be removed in 1.11 which drops IE6/7 support
        if (oSettings.oBrowser.bScrollOversize) {
          setTimeout(bindResize, 1000);
        } else {
          bindResize();
        }
        oSettings._reszEvt = true;
      }
    }
    /**
	 * Throttle the calls to a function. Arguments and context are maintained for
	 * the throttled function
	 *  @param {function} fn Function to be called
	 *  @param {int} [freq=200] call frequency in mS
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#oApi
	 */
    function _fnThrottle(fn, freq) {
      var frequency = freq !== undefined ? freq : 200, last, timer;
      return function () {
        var that = this, now = +new Date(), args = arguments;
        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function () {
            last = undefined;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    }
    /**
	 * Convert a CSS unit width to pixels (e.g. 2em)
	 *  @param {string} width width to be converted
	 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
    function _fnConvertToWidth(width, parent) {
      if (!width) {
        return 0;
      }
      var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);
      var val = n[0].offsetWidth;
      n.remove();
      return val;
    }
    /**
	 * Adjust a table's width to take account of vertical scroll bar
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n table node
	 *  @memberof DataTable#oApi
	 */
    function _fnScrollingWidthAdjust(settings, n) {
      var scroll = settings.oScroll;
      if (scroll.sX || scroll.sY) {
        // When y-scrolling only, we want to remove the width of the scroll bar
        // so the table + scroll bar will fit into the area available, otherwise
        // we fix the table at its current size with no adjustment
        var correction = !scroll.sX ? scroll.iBarWidth : 0;
        n.style.width = _fnStringToCss($(n).outerWidth() - correction);
      }
    }
    /**
	 * Get the widest node
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {node} widest table node
	 *  @memberof DataTable#oApi
	 */
    function _fnGetWidestNode(settings, colIdx) {
      var idx = _fnGetMaxLenString(settings, colIdx);
      if (idx < 0) {
        return null;
      }
      var data = settings.aoData[idx];
      return !data.nTr ? $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
    }
    /**
	 * Get the maximum strlen for each data column
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {string} max string length for each column
	 *  @memberof DataTable#oApi
	 */
    function _fnGetMaxLenString(settings, colIdx) {
      var s, max = -1, maxIdx = -1;
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        s = _fnGetCellData(settings, i, colIdx, 'display') + '';
        s = s.replace(__re_html_remove, '');
        if (s.length > max) {
          max = s.length;
          maxIdx = i;
        }
      }
      return maxIdx;
    }
    /**
	 * Append a CSS unit (only if required) to a string
	 *  @param {string} value to css-ify
	 *  @returns {string} value with css unit
	 *  @memberof DataTable#oApi
	 */
    function _fnStringToCss(s) {
      if (s === null) {
        return '0px';
      }
      if (typeof s == 'number') {
        return s < 0 ? '0px' : s + 'px';
      }
      // Check it has a unit character already
      return s.match(/\d$/) ? s + 'px' : s;
    }
    /**
	 * Get the width of a scroll bar in this browser being used
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
    function _fnScrollBarWidth() {
      // On first run a static variable is set, since this is only needed once.
      // Subsequent runs will just use the previously calculated value
      var width = DataTable.__scrollbarWidth;
      if (width === undefined) {
        var sizer = $('<p/>').css({
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: 150,
            padding: 0,
            overflow: 'scroll',
            visibility: 'hidden'
          }).appendTo('body');
        width = sizer[0].offsetWidth - sizer[0].clientWidth;
        DataTable.__scrollbarWidth = width;
        sizer.remove();
      }
      return width;
    }
    function _fnSortFlatten(settings) {
      var i, iLen, k, kLen, aSort = [], aiOrig = [], aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $.isPlainObject(fixed), nestedSort = [], add = function (a) {
          if (a.length && !$.isArray(a[0])) {
            // 1D array
            nestedSort.push(a);
          } else {
            // 2D array
            nestedSort.push.apply(nestedSort, a);
          }
        };
      // Build the sort array, with pre-fix and post-fix options if they have been
      // specified
      if ($.isArray(fixed)) {
        add(fixed);
      }
      if (fixedObj && fixed.pre) {
        add(fixed.pre);
      }
      add(settings.aaSorting);
      if (fixedObj && fixed.post) {
        add(fixed.post);
      }
      for (i = 0; i < nestedSort.length; i++) {
        srcCol = nestedSort[i][0];
        aDataSort = aoColumns[srcCol].aDataSort;
        for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
          iCol = aDataSort[k];
          sType = aoColumns[iCol].sType || 'string';
          if (nestedSort[i]._idx === undefined) {
            nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
          }
          aSort.push({
            src: srcCol,
            col: iCol,
            dir: nestedSort[i][1],
            index: nestedSort[i]._idx,
            type: sType,
            formatter: DataTable.ext.type.order[sType + '-pre']
          });
        }
      }
      return aSort;
    }
    /**
	 * Change the order of the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 *  @todo This really needs split up!
	 */
    function _fnSort(oSettings) {
      var i, ien, iLen, j, jLen, k, kLen, sDataType, nTh, aiOrig = [], oExtSort = DataTable.ext.type.order, aoData = oSettings.aoData, aoColumns = oSettings.aoColumns, aDataSort, data, iCol, sType, oSort, formatters = 0, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
      // Resolve any column types that are unknown due to addition or invalidation
      // @todo Can this be moved into a 'data-ready' handler which is called when
      //   data is going to be used in the table?
      _fnColumnTypes(oSettings);
      aSort = _fnSortFlatten(oSettings);
      for (i = 0, ien = aSort.length; i < ien; i++) {
        sortCol = aSort[i];
        // Track if we can use the fast sort algorithm
        if (sortCol.formatter) {
          formatters++;
        }
        // Load the data needed for the sort, for each cell
        _fnSortData(oSettings, sortCol.col);
      }
      /* No sorting required if server-side or no sorting array */
      if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
        // Create a value - key array of the current row positions such that we can use their
        // current position during the sort, if values match, in order to perform stable sorting
        for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
          aiOrig[displayMaster[i]] = i;
        }
        /* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
			 * follow on it's own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort['string-asc']('data11', 'data12');
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort['numeric-desc']('data21', 'data22');
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
        if (formatters === aSort.length) {
          // All sort types have formatting functions
          displayMaster.sort(function (a, b) {
            var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
            for (k = 0; k < len; k++) {
              sort = aSort[k];
              x = dataA[sort.col];
              y = dataB[sort.col];
              test = x < y ? -1 : x > y ? 1 : 0;
              if (test !== 0) {
                return sort.dir === 'asc' ? test : -test;
              }
            }
            x = aiOrig[a];
            y = aiOrig[b];
            return x < y ? -1 : x > y ? 1 : 0;
          });
        } else {
          // Depreciated - remove in 1.11 (providing a plug-in option)
          // Not all sort types have formatting methods, so we have to call their sorting
          // methods.
          displayMaster.sort(function (a, b) {
            var x, y, k, l, test, sort, fn, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
            for (k = 0; k < len; k++) {
              sort = aSort[k];
              x = dataA[sort.col];
              y = dataB[sort.col];
              fn = oExtSort[sort.type + '-' + sort.dir] || oExtSort['string-' + sort.dir];
              test = fn(x, y);
              if (test !== 0) {
                return test;
              }
            }
            x = aiOrig[a];
            y = aiOrig[b];
            return x < y ? -1 : x > y ? 1 : 0;
          });
        }
      }
      /* Tell the draw function that we have sorted the data */
      oSettings.bSorted = true;
    }
    function _fnSortAria(settings) {
      var label;
      var nextSort;
      var columns = settings.aoColumns;
      var aSort = _fnSortFlatten(settings);
      var oAria = settings.oLanguage.oAria;
      // ARIA attributes - need to loop all columns, to update all (removing old
      // attributes as needed)
      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        var col = columns[i];
        var asSorting = col.asSorting;
        var sTitle = col.sTitle.replace(/<.*?>/g, '');
        var th = col.nTh;
        // IE7 is throwing an error when setting these properties with jQuery's
        // attr() and removeAttr() methods...
        th.removeAttribute('aria-sort');
        /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
        if (col.bSortable) {
          if (aSort.length > 0 && aSort[0].col == i) {
            th.setAttribute('aria-sort', aSort[0].dir == 'asc' ? 'ascending' : 'descending');
            nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
          } else {
            nextSort = asSorting[0];
          }
          label = sTitle + (nextSort === 'asc' ? oAria.sSortAscending : oAria.sSortDescending);
        } else {
          label = sTitle;
        }
        th.setAttribute('aria-label', label);
      }
    }
    /**
	 * Function to run on user sort request
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {boolean} [append=false] Append the requested sort to the existing
	 *    sort if true (i.e. multi-column sort)
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
    function _fnSortListener(settings, colIdx, append, callback) {
      var col = settings.aoColumns[colIdx];
      var sorting = settings.aaSorting;
      var asSorting = col.asSorting;
      var nextSortIdx;
      var next = function (a, overflow) {
        var idx = a._idx;
        if (idx === undefined) {
          idx = $.inArray(a[1], asSorting);
        }
        return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
      };
      // Convert to 2D array if needed
      if (typeof sorting[0] === 'number') {
        sorting = settings.aaSorting = [sorting];
      }
      // If appending the sort then we are multi-column sorting
      if (append && settings.oFeatures.bSortMulti) {
        // Are we already doing some kind of sort on this column?
        var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));
        if (sortIdx !== -1) {
          // Yes, modify the sort
          nextSortIdx = next(sorting[sortIdx], true);
          if (nextSortIdx === null && sorting.length === 1) {
            nextSortIdx = 0;  // can't remove sorting completely
          }
          if (nextSortIdx === null) {
            sorting.splice(sortIdx, 1);
          } else {
            sorting[sortIdx][1] = asSorting[nextSortIdx];
            sorting[sortIdx]._idx = nextSortIdx;
          }
        } else {
          // No sort on this column yet
          sorting.push([
            colIdx,
            asSorting[0],
            0
          ]);
          sorting[sorting.length - 1]._idx = 0;
        }
      } else if (sorting.length && sorting[0][0] == colIdx) {
        // Single column - already sorting on this column, modify the sort
        nextSortIdx = next(sorting[0]);
        sorting.length = 1;
        sorting[0][1] = asSorting[nextSortIdx];
        sorting[0]._idx = nextSortIdx;
      } else {
        // Single column - sort only on this column
        sorting.length = 0;
        sorting.push([
          colIdx,
          asSorting[0]
        ]);
        sorting[0]._idx = 0;
      }
      // Run the sort by calling a full redraw
      _fnReDraw(settings);
      // callback used for async user interaction
      if (typeof callback == 'function') {
        callback(settings);
      }
    }
    /**
	 * Attach a sort handler (click) to a node
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
    function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
      var col = settings.aoColumns[colIdx];
      _fnBindAction(attachTo, {}, function (e) {
        /* If the column is not sortable - don't to anything */
        if (col.bSortable === false) {
          return;
        }
        // If processing is enabled use a timeout to allow the processing
        // display to be shown - otherwise to it synchronously
        if (settings.oFeatures.bProcessing) {
          _fnProcessingDisplay(settings, true);
          setTimeout(function () {
            _fnSortListener(settings, colIdx, e.shiftKey, callback);
            // In server-side processing, the draw callback will remove the
            // processing display
            if (_fnDataSource(settings) !== 'ssp') {
              _fnProcessingDisplay(settings, false);
            }
          }, 0);
        } else {
          _fnSortListener(settings, colIdx, e.shiftKey, callback);
        }
      });
    }
    /**
	 * Set the sorting classes on table's body, Note: it is safe to call this function
	 * when bSort and bSortClasses are false
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnSortingClasses(settings) {
      var oldSort = settings.aLastSort;
      var sortClass = settings.oClasses.sSortColumn;
      var sort = _fnSortFlatten(settings);
      var features = settings.oFeatures;
      var i, ien, colIdx;
      if (features.bSort && features.bSortClasses) {
        // Remove old sorting classes
        for (i = 0, ien = oldSort.length; i < ien; i++) {
          colIdx = oldSort[i].src;
          // Remove column sorting
          $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
        }
        // Add new column sorting
        for (i = 0, ien = sort.length; i < ien; i++) {
          colIdx = sort[i].src;
          $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
        }
      }
      settings.aLastSort = sort;
    }
    // Get the data to sort a column, be it from cache, fresh (populating the
    // cache), or from a sort formatter
    function _fnSortData(settings, idx) {
      // Custom sorting function - provided by the sort data type
      var column = settings.aoColumns[idx];
      var customSort = DataTable.ext.order[column.sSortDataType];
      var customData;
      if (customSort) {
        customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
      }
      // Use / populate cache
      var row, cellData;
      var formatter = DataTable.ext.type.order[column.sType + '-pre'];
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        row = settings.aoData[i];
        if (!row._aSortData) {
          row._aSortData = [];
        }
        if (!row._aSortData[idx] || customSort) {
          cellData = customSort ? customData[i] : _fnGetCellData(settings, i, idx, 'sort');
          row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
        }
      }
    }
    /**
	 * Save the state of a table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
    function _fnSaveState(settings) {
      if (!settings.oFeatures.bStateSave || settings.bDestroying) {
        return;
      }
      /* Store the interesting variables */
      var state = {
          time: +new Date(),
          start: settings._iDisplayStart,
          length: settings._iDisplayLength,
          order: $.extend(true, [], settings.aaSorting),
          search: _fnSearchToCamel(settings.oPreviousSearch),
          columns: $.map(settings.aoColumns, function (col, i) {
            return {
              visible: col.bVisible,
              search: _fnSearchToCamel(settings.aoPreSearchCols[i])
            };
          })
        };
      _fnCallbackFire(settings, 'aoStateSaveParams', 'stateSaveParams', [
        settings,
        state
      ]);
      settings.oSavedState = state;
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
    /**
	 * Attempt to load a saved table state
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oInit DataTables init object so we can override settings
	 *  @memberof DataTable#oApi
	 */
    function _fnLoadState(settings, oInit) {
      var i, ien;
      var columns = settings.aoColumns;
      if (!settings.oFeatures.bStateSave) {
        return;
      }
      var state = settings.fnStateLoadCallback.call(settings.oInstance, settings);
      if (!state || !state.time) {
        return;
      }
      /* Allow custom and plug-in manipulation functions to alter the saved data set and
		 * cancelling of loading by returning false
		 */
      var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [
          settings,
          state
        ]);
      if ($.inArray(false, abStateLoad) !== -1) {
        return;
      }
      /* Reject old data */
      var duration = settings.iStateDuration;
      if (duration > 0 && state.time < +new Date() - duration * 1000) {
        return;
      }
      // Number of columns have changed - all bets are off, no restore of settings
      if (columns.length !== state.columns.length) {
        return;
      }
      // Store the saved state so it might be accessed at any time
      settings.oLoadedState = $.extend(true, {}, state);
      // Restore key features - todo - for 1.11 this needs to be done by
      // subscribed events
      if (state.start !== undefined) {
        settings._iDisplayStart = state.start;
        settings.iInitDisplayStart = state.start;
      }
      if (state.length !== undefined) {
        settings._iDisplayLength = state.length;
      }
      // Order
      if (state.order !== undefined) {
        settings.aaSorting = [];
        $.each(state.order, function (i, col) {
          settings.aaSorting.push(col[0] >= columns.length ? [
            0,
            col[1]
          ] : col);
        });
      }
      // Search
      if (state.search !== undefined) {
        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search));
      }
      // Columns
      for (i = 0, ien = state.columns.length; i < ien; i++) {
        var col = state.columns[i];
        // Visibility
        if (col.visible !== undefined) {
          columns[i].bVisible = col.visible;
        }
        // Search
        if (col.search !== undefined) {
          $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
        }
      }
      _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [
        settings,
        state
      ]);
    }
    /**
	 * Return the settings object for a particular table
	 *  @param {node} table table we are using as a dataTable
	 *  @returns {object} Settings object - or null if not found
	 *  @memberof DataTable#oApi
	 */
    function _fnSettingsFromNode(table) {
      var settings = DataTable.settings;
      var idx = $.inArray(table, _pluck(settings, 'nTable'));
      return idx !== -1 ? settings[idx] : null;
    }
    /**
	 * Log an error message
	 *  @param {object} settings dataTables settings object
	 *  @param {int} level log error messages, or display them to the user
	 *  @param {string} msg error message
	 *  @param {int} tn Technical note id to get more information about the error.
	 *  @memberof DataTable#oApi
	 */
    function _fnLog(settings, level, msg, tn) {
      msg = 'DataTables warning: ' + (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg;
      if (tn) {
        msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
      }
      if (!level) {
        // Backwards compatibility pre 1.10
        var ext = DataTable.ext;
        var type = ext.sErrMode || ext.errMode;
        _fnCallbackFire(settings, null, 'error', [
          settings,
          tn,
          msg
        ]);
        if (type == 'alert') {
          alert(msg);
        } else if (type == 'throw') {
          throw new Error(msg);
        } else if (typeof type == 'function') {
          type(settings, tn, msg);
        }
      } else if (window.console && console.log) {
        console.log(msg);
      }
    }
    /**
	 * See if a property is defined on one object, if so assign it to the other object
	 *  @param {object} ret target object
	 *  @param {object} src source object
	 *  @param {string} name property
	 *  @param {string} [mappedName] name to map too - optional, name used if not given
	 *  @memberof DataTable#oApi
	 */
    function _fnMap(ret, src, name, mappedName) {
      if ($.isArray(name)) {
        $.each(name, function (i, val) {
          if ($.isArray(val)) {
            _fnMap(ret, src, val[0], val[1]);
          } else {
            _fnMap(ret, src, val);
          }
        });
        return;
      }
      if (mappedName === undefined) {
        mappedName = name;
      }
      if (src[name] !== undefined) {
        ret[mappedName] = src[name];
      }
    }
    /**
	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	 * shallow copy arrays. The reason we need to do this, is that we don't want to
	 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	 * able to override them, but we do want to deep copy arrays.
	 *  @param {object} out Object to extend
	 *  @param {object} extender Object from which the properties will be applied to
	 *      out
	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	 *      independent copy with the exception of the `data` or `aaData` parameters
	 *      if they are present. This is so you can pass in a collection to
	 *      DataTables and have that used as your data source without breaking the
	 *      references
	 *  @returns {object} out Reference, just for convenience - out === the return.
	 *  @memberof DataTable#oApi
	 *  @todo This doesn't take account of arrays inside the deep copied objects.
	 */
    function _fnExtend(out, extender, breakRefs) {
      var val;
      for (var prop in extender) {
        if (extender.hasOwnProperty(prop)) {
          val = extender[prop];
          if ($.isPlainObject(val)) {
            if (!$.isPlainObject(out[prop])) {
              out[prop] = {};
            }
            $.extend(true, out[prop], val);
          } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
            out[prop] = val.slice();
          } else {
            out[prop] = val;
          }
        }
      }
      return out;
    }
    /**
	 * Bind an event handers to allow a click or return key to activate the callback.
	 * This is good for accessibility since a return on the keyboard will have the
	 * same effect as a click, if the element has focus.
	 *  @param {element} n Element to bind the action to
	 *  @param {object} oData Data object to pass to the triggered function
	 *  @param {function} fn Callback function for when the event is triggered
	 *  @memberof DataTable#oApi
	 */
    function _fnBindAction(n, oData, fn) {
      $(n).bind('click.DT', oData, function (e) {
        n.blur();
        // Remove focus outline for mouse users
        fn(e);
      }).bind('keypress.DT', oData, function (e) {
        if (e.which === 13) {
          e.preventDefault();
          fn(e);
        }
      }).bind('selectstart.DT', function () {
        /* Take the brutal approach to cancelling text selection */
        return false;
      });
    }
    /**
	 * Register a callback function. Easily allows a callback function to be added to
	 * an array store of callback functions that can then all be called together.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	 *  @param {function} fn Function to be called back
	 *  @param {string} sName Identifying name for the callback (i.e. a label)
	 *  @memberof DataTable#oApi
	 */
    function _fnCallbackReg(oSettings, sStore, fn, sName) {
      if (fn) {
        oSettings[sStore].push({
          'fn': fn,
          'sName': sName
        });
      }
    }
    /**
	 * Fire callback functions and trigger events. Note that the loop over the
	 * callback array store is done backwards! Further note that you do not want to
	 * fire off triggers in time sensitive applications (for example cell creation)
	 * as its slow.
	 *  @param {object} settings dataTables settings object
	 *  @param {string} callbackArr Name of the array storage for the callbacks in
	 *      oSettings
	 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	 *      null no trigger is fired
	 *  @param {array} args Array of arguments to pass to the callback function /
	 *      trigger
	 *  @memberof DataTable#oApi
	 */
    function _fnCallbackFire(settings, callbackArr, eventName, args) {
      var ret = [];
      if (callbackArr) {
        ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
          return val.fn.apply(settings.oInstance, args);
        });
      }
      if (eventName !== null) {
        var e = $.Event(eventName + '.dt');
        $(settings.nTable).trigger(e, args);
        ret.push(e.result);
      }
      return ret;
    }
    function _fnLengthOverflow(settings) {
      var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
      /* If we have space to show extra rows (backing up from the end point - then do so */
      if (start >= end) {
        start = end - len;
      }
      // Keep the start record on the current page
      start -= start % len;
      if (len === -1 || start < 0) {
        start = 0;
      }
      settings._iDisplayStart = start;
    }
    function _fnRenderer(settings, type) {
      var renderer = settings.renderer;
      var host = DataTable.ext.renderer[type];
      if ($.isPlainObject(renderer) && renderer[type]) {
        // Specific renderer for this type. If available use it, otherwise use
        // the default.
        return host[renderer[type]] || host._;
      } else if (typeof renderer === 'string') {
        // Common renderer - if there is one available for this type use it,
        // otherwise use the default
        return host[renderer] || host._;
      }
      // Use the default
      return host._;
    }
    /**
	 * Detect the data source being used for the table. Used to simplify the code
	 * a little (ajax) and to make it compress a little smaller.
	 *
	 *  @param {object} settings dataTables settings object
	 *  @returns {string} Data source
	 *  @memberof DataTable#oApi
	 */
    function _fnDataSource(settings) {
      if (settings.oFeatures.bServerSide) {
        return 'ssp';
      } else if (settings.ajax || settings.sAjaxSource) {
        return 'ajax';
      }
      return 'dom';
    }
    DataTable = function (options) {
      /**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
      this.$ = function (sSelector, oOpts) {
        return this.api(true).$(sSelector, oOpts);
      };
      /**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
		 *    entry in the array.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"search": "applied"});
		 *
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the search" );
		 *    } );
		 */
      this._ = function (sSelector, oOpts) {
        return this.api(true).rows(sSelector, oOpts).data();
      };
      /**
		 * Create a DataTables Api instance, with the currently selected tables for
		 * the Api's context.
		 * @param {boolean} [traditional=false] Set the API instance's context to be
		 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
		 *   or if all tables captured in the jQuery object should be used.
		 * @return {DataTables.Api}
		 */
      this.api = function (traditional) {
        return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this);
      };
      /**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} data The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mData</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
		 *    </ul>
		 *  @param {bool} [redraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
		 *    the table.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *
		 *      giCount++;
		 *    }
		 */
      this.fnAddData = function (data, redraw) {
        var api = this.api(true);
        /* Check if we want to add multiple rows or not */
        var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);
        if (redraw === undefined || redraw) {
          api.draw();
        }
        return rows.flatten().toArray();
      };
      /**
		 * This function will make DataTables recalculate the column sizes, based on the data
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
		 * through the sWidth parameter). This can be useful when the width of the table's
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *
		 *      $(window).bind('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
      this.fnAdjustColumnSizing = function (bRedraw) {
        var api = this.api(true).columns.adjust();
        var settings = api.settings()[0];
        var scroll = settings.oScroll;
        if (bRedraw === undefined || bRedraw) {
          api.draw(false);
        } else if (scroll.sX !== '' || scroll.sY !== '') {
          /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
          _fnScrollDraw(settings);
        }
      };
      /**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
      this.fnClearTable = function (bRedraw) {
        var api = this.api(true).clear();
        if (bRedraw === undefined || bRedraw) {
          api.draw();
        }
      };
      /**
		 * The exact opposite of 'opening' a row, this function will close any rows which
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
      this.fnClose = function (nTr) {
        this.api(true).row(nTr).child.hide();
      };
      /**
		 * Remove a row for the table
		 *  @param {mixed} target The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [callBack] Callback function
		 *  @param {bool} [redraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
      this.fnDeleteRow = function (target, callback, redraw) {
        var api = this.api(true);
        var rows = api.rows(target);
        var settings = rows.settings()[0];
        var data = settings.aoData[rows[0][0]];
        rows.remove();
        if (callback) {
          callback.call(this, settings, data);
        }
        if (redraw === undefined || redraw) {
          api.draw();
        }
        return data;
      };
      /**
		 * Restore the table to it's original state in the DOM by removing all of DataTables
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [remove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
      this.fnDestroy = function (remove) {
        this.api(true).destroy(remove);
      };
      /**
		 * Redraw the table
		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
      this.fnDraw = function (complete) {
        // Note that this isn't an exact match to the old call to _fnDraw - it takes
        // into account the new data, but can hold position.
        this.api(true).draw(complete);
      };
      /**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
      this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
        var api = this.api(true);
        if (iColumn === null || iColumn === undefined) {
          api.search(sInput, bRegex, bSmart, bCaseInsensitive);
        } else {
          api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
        }
        api.draw();
      };
      /**
		 * Get the data for the whole table, an individual row or an individual cell based on the
		 * provided parameters.
		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [col] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
      this.fnGetData = function (src, col) {
        var api = this.api(true);
        if (src !== undefined) {
          var type = src.nodeName ? src.nodeName.toLowerCase() : '';
          return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
        }
        return api.data().toArray();
      };
      /**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will
		 * typically want to use the '$' API method in preference to this as it is more
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
      this.fnGetNodes = function (iRow) {
        var api = this.api(true);
        return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
      };
      /**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} node this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible),
		 *    column index (all)] is given.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
      this.fnGetPosition = function (node) {
        var api = this.api(true);
        var nodeName = node.nodeName.toUpperCase();
        if (nodeName == 'TR') {
          return api.row(node).index();
        } else if (nodeName == 'TD' || nodeName == 'TH') {
          var cell = api.cell(node).index();
          return [
            cell.row,
            cell.columnVisible,
            cell.column
          ];
        }
        return null;
      };
      /**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
      this.fnIsOpen = function (nTr) {
        return this.api(true).row(nTr).child.isShown();
      };
      /**
		 * This function will place a new row directly after a row which is currently
		 * on display on the page, with the HTML contents that is passed into the
		 * function. This can be used, for example, to ask for confirmation that a
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
      this.fnOpen = function (nTr, mHtml, sClass) {
        return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
      };
      /**
		 * Change the pagination - provides the internal logic for pagination in a simple API
		 * function. With this function you can have a DataTables table go to the next,
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
      this.fnPageChange = function (mAction, bRedraw) {
        var api = this.api(true).page(mAction);
        if (bRedraw === undefined || bRedraw) {
          api.draw(false);
        }
      };
      /**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
      this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
        var api = this.api(true).column(iCol).visible(bShow);
        if (bRedraw === undefined || bRedraw) {
          api.columns.adjust().draw();
        }
      };
      /**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
      this.fnSettings = function () {
        return _fnSettingsFromNode(this[_ext.iApiIndex]);
      };
      /**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
      this.fnSort = function (aaSort) {
        this.api(true).order(aaSort).draw();
      };
      /**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
      this.fnSortListener = function (nNode, iColumn, fnCallback) {
        this.api(true).order.listener(nNode, iColumn, fnCallback);
      };
      /**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update, give as null or undefined to
		 *    update a whole row.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
		 *    } );
		 */
      this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
        var api = this.api(true);
        if (iColumn === undefined || iColumn === null) {
          api.row(mRow).data(mData);
        } else {
          api.cell(mRow, iColumn).data(mData);
        }
        if (bAction === undefined || bAction) {
          api.columns.adjust();
        }
        if (bRedraw === undefined || bRedraw) {
          api.draw();
        }
        return 0;
      };
      /**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
      this.fnVersionCheck = _ext.fnVersionCheck;
      var _that = this;
      var emptyInit = options === undefined;
      var len = this.length;
      if (emptyInit) {
        options = {};
      }
      this.oApi = this.internal = _ext.internal;
      // Extend with old style plug-in API methods
      for (var fn in DataTable.ext.internal) {
        if (fn) {
          this[fn] = _fnExternApiFunc(fn);
        }
      }
      this.each(function () {
        // For each initialisation we want to give it a clean initialisation
        // object that can be bashed around
        var o = {};
        var oInit = len > 1 ? _fnExtend(o, options, true) : options;
        /*global oInit,_that,emptyInit*/
        var i = 0, iLen, j, jLen, k, kLen;
        var sId = this.getAttribute('id');
        var bInitHandedOff = false;
        var defaults = DataTable.defaults;
        var $this = $(this);
        /* Sanity check */
        if (this.nodeName.toLowerCase() != 'table') {
          _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);
          return;
        }
        /* Backwards compatibility for the defaults */
        _fnCompatOpts(defaults);
        _fnCompatCols(defaults.column);
        /* Convert the camel-case defaults to Hungarian */
        _fnCamelToHungarian(defaults, defaults, true);
        _fnCamelToHungarian(defaults.column, defaults.column, true);
        /* Setting up the initialisation object */
        _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));
        /* Check to see if we are re-initialising a table */
        var allSettings = DataTable.settings;
        for (i = 0, iLen = allSettings.length; i < iLen; i++) {
          var s = allSettings[i];
          /* Base check on table node */
          if (s.nTable == this || s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
            var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
            var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
            if (emptyInit || bRetrieve) {
              return s.oInstance;
            } else if (bDestroy) {
              s.oInstance.fnDestroy();
              break;
            } else {
              _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);
              return;
            }
          }
          /* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
          if (s.sTableId == this.id) {
            allSettings.splice(i, 1);
            break;
          }
        }
        /* Ensure the table has an ID - required for accessibility */
        if (sId === null || sId === '') {
          sId = 'DataTables_Table_' + DataTable.ext._unique++;
          this.id = sId;
        }
        /* Create the settings object for this table and set some of the default parameters */
        var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
            'sDestroyWidth': $this[0].style.width,
            'sInstance': sId,
            'sTableId': sId
          });
        oSettings.nTable = this;
        oSettings.oApi = _that.internal;
        oSettings.oInit = oInit;
        allSettings.push(oSettings);
        // Need to add the instance after the instance after the settings object has been added
        // to the settings array, so we can self reference the table instance if more than one
        oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
        // Backwards compatibility, before we apply all the defaults
        _fnCompatOpts(oInit);
        if (oInit.oLanguage) {
          _fnLanguageCompat(oInit.oLanguage);
        }
        // If the length menu is given, but the init display length is not, use the length menu
        if (oInit.aLengthMenu && !oInit.iDisplayLength) {
          oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
        }
        // Apply the defaults and init options to make a single init object will all
        // options defined from defaults and instance options.
        oInit = _fnExtend($.extend(true, {}, defaults), oInit);
        // Map the initialisation options onto the settings object
        _fnMap(oSettings.oFeatures, oInit, [
          'bPaginate',
          'bLengthChange',
          'bFilter',
          'bSort',
          'bSortMulti',
          'bInfo',
          'bProcessing',
          'bAutoWidth',
          'bSortClasses',
          'bServerSide',
          'bDeferRender'
        ]);
        _fnMap(oSettings, oInit, [
          'asStripeClasses',
          'ajax',
          'fnServerData',
          'fnFormatNumber',
          'sServerMethod',
          'aaSorting',
          'aaSortingFixed',
          'aLengthMenu',
          'sPaginationType',
          'sAjaxSource',
          'sAjaxDataProp',
          'iStateDuration',
          'sDom',
          'bSortCellsTop',
          'iTabIndex',
          'fnStateLoadCallback',
          'fnStateSaveCallback',
          'renderer',
          'searchDelay',
          [
            'iCookieDuration',
            'iStateDuration'
          ],
          [
            'oSearch',
            'oPreviousSearch'
          ],
          [
            'aoSearchCols',
            'aoPreSearchCols'
          ],
          [
            'iDisplayLength',
            '_iDisplayLength'
          ],
          [
            'bJQueryUI',
            'bJUI'
          ]
        ]);
        _fnMap(oSettings.oScroll, oInit, [
          [
            'sScrollX',
            'sX'
          ],
          [
            'sScrollXInner',
            'sXInner'
          ],
          [
            'sScrollY',
            'sY'
          ],
          [
            'bScrollCollapse',
            'bCollapse'
          ]
        ]);
        _fnMap(oSettings.oLanguage, oInit, 'fnInfoCallback');
        /* Callback functions which are array driven */
        _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
        _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
        _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
        _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
        _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
        _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
        _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
        _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
        _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
        _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
        _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');
        var oClasses = oSettings.oClasses;
        // @todo Remove in 1.11
        if (oInit.bJQueryUI) {
          /* Use the JUI classes object for display. You could clone the oStdClasses object if
				 * you want to have multiple tables with multiple independent classes
				 */
          $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses);
          if (oInit.sDom === defaults.sDom && defaults.sDom === 'lfrtip') {
            /* Set the DOM to use a layout suitable for jQuery UI's theming */
            oSettings.sDom = '<"H"lfr>t<"F"ip>';
          }
          if (!oSettings.renderer) {
            oSettings.renderer = 'jqueryui';
          } else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {
            oSettings.renderer.header = 'jqueryui';
          }
        } else {
          $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
        }
        $this.addClass(oClasses.sTable);
        /* Calculate the scroll bar width and cache it for use later on */
        if (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '') {
          oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
        }
        if (oSettings.oScroll.sX === true) {
          // Easy initialisation of x-scrolling
          oSettings.oScroll.sX = '100%';
        }
        if (oSettings.iInitDisplayStart === undefined) {
          /* Display start point, taking into account the save saving */
          oSettings.iInitDisplayStart = oInit.iDisplayStart;
          oSettings._iDisplayStart = oInit.iDisplayStart;
        }
        if (oInit.iDeferLoading !== null) {
          oSettings.bDeferLoading = true;
          var tmp = $.isArray(oInit.iDeferLoading);
          oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
          oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
        }
        /* Language definitions */
        var oLanguage = oSettings.oLanguage;
        $.extend(true, oLanguage, oInit.oLanguage);
        if (oLanguage.sUrl !== '') {
          /* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
          $.ajax({
            dataType: 'json',
            url: oLanguage.sUrl,
            success: function (json) {
              _fnLanguageCompat(json);
              _fnCamelToHungarian(defaults.oLanguage, json);
              $.extend(true, oLanguage, json);
              _fnInitialise(oSettings);
            },
            error: function () {
              // Error occurred loading language file, continue on as best we can
              _fnInitialise(oSettings);
            }
          });
          bInitHandedOff = true;
        }
        /*
			 * Stripes
			 */
        if (oInit.asStripeClasses === null) {
          oSettings.asStripeClasses = [
            oClasses.sStripeOdd,
            oClasses.sStripeEven
          ];
        }
        /* Remove row stripe classes if they are already on the table row */
        var stripeClasses = oSettings.asStripeClasses;
        var rowOne = $this.children('tbody').find('tr').eq(0);
        if ($.inArray(true, $.map(stripeClasses, function (el, i) {
            return rowOne.hasClass(el);
          })) !== -1) {
          $('tbody tr', this).removeClass(stripeClasses.join(' '));
          oSettings.asDestroyStripes = stripeClasses.slice();
        }
        /*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
        var anThs = [];
        var aoColumnsInit;
        var nThead = this.getElementsByTagName('thead');
        if (nThead.length !== 0) {
          _fnDetectHeader(oSettings.aoHeader, nThead[0]);
          anThs = _fnGetUniqueThs(oSettings);
        }
        /* If not given a column array, generate one with nulls */
        if (oInit.aoColumns === null) {
          aoColumnsInit = [];
          for (i = 0, iLen = anThs.length; i < iLen; i++) {
            aoColumnsInit.push(null);
          }
        } else {
          aoColumnsInit = oInit.aoColumns;
        }
        /* Add the columns */
        for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
          _fnAddColumn(oSettings, anThs ? anThs[i] : null);
        }
        /* Apply the column definitions */
        _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
          _fnColumnOptions(oSettings, iCol, oDef);
        });
        /* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
        if (rowOne.length) {
          var a = function (cell, name) {
            return cell.getAttribute('data-' + name) !== null ? name : null;
          };
          $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {
            var col = oSettings.aoColumns[i];
            if (col.mData === i) {
              var sort = a(cell, 'sort') || a(cell, 'order');
              var filter = a(cell, 'filter') || a(cell, 'search');
              if (sort !== null || filter !== null) {
                col.mData = {
                  _: i + '.display',
                  sort: sort !== null ? i + '.@data-' + sort : undefined,
                  type: sort !== null ? i + '.@data-' + sort : undefined,
                  filter: filter !== null ? i + '.@data-' + filter : undefined
                };
                _fnColumnOptions(oSettings, i);
              }
            }
          });
        }
        var features = oSettings.oFeatures;
        /* Must be done after everything which can be overridden by the state saving! */
        if (oInit.bStateSave) {
          features.bStateSave = true;
          _fnLoadState(oSettings, oInit);
          _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
        }
        /*
			 * Sorting
			 * @todo For modularisation (1.11) this needs to do into a sort start up handler
			 */
        // If aaSorting is not defined, then we use the first indicator in asSorting
        // in case that has been altered, so the default sort reflects that option
        if (oInit.aaSorting === undefined) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        /* Do a first pass on the sorting classes (allows any size changes to be taken into
			 * account, and also will apply sorting disabled classes if disabled
			 */
        _fnSortingClasses(oSettings);
        if (features.bSort) {
          _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);
              var sortedColumns = {};
              $.each(aSort, function (i, val) {
                sortedColumns[val.src] = val.dir;
              });
              _fnCallbackFire(oSettings, null, 'order', [
                oSettings,
                aSort,
                sortedColumns
              ]);
              _fnSortAria(oSettings);
            }
          });
        }
        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
          if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, 'sc');
        /*
			 * Final init
			 * Cache the header, body and footer as required, creating them if needed
			 */
        /* Browser support detection */
        _fnBrowserDetect(oSettings);
        // Work around for Webkit bug 83867 - store the caption-side before removing from doc
        var captions = $this.children('caption').each(function () {
            this._captionSide = $this.css('caption-side');
          });
        var thead = $this.children('thead');
        if (thead.length === 0) {
          thead = $('<thead/>').appendTo(this);
        }
        oSettings.nTHead = thead[0];
        var tbody = $this.children('tbody');
        if (tbody.length === 0) {
          tbody = $('<tbody/>').appendTo(this);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children('tfoot');
        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '')) {
          // If we are a scrolling table, and no footer has been given, then we need to create
          // a tfoot element for the caption element to be appended to
          tfoot = $('<tfoot/>').appendTo(this);
        }
        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];
          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        /* Check if there is data passing into the constructor */
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData(oSettings, oInit.aaData[i]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
          /* Grab the data from the page - only do this when deferred loading or no Ajax
				 * source since there is no point in reading the DOM data if we are then going
				 * to replace it with Ajax data
				 */
          _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
        }
        /* Copy the data index array */
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        /* Initialisation complete - table can be drawn */
        oSettings.bInitialised = true;
        /* Check if we need to initialise the table (it might not have been handed off to the
			 * language processor)
			 */
        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      });
      _that = null;
      return this;
    };
    /**
	 * Computed structure of the DataTables API, defined by the options passed to
	 * `DataTable.Api.register()` when building the API.
	 *
	 * The structure is built in order to speed creation and extension of the Api
	 * objects since the extensions are effectively pre-parsed.
	 *
	 * The array is an array of objects with the following structure, where this
	 * base array represents the Api prototype base:
	 *
	 *     [
	 *       {
	 *         name:      'data'                -- string   - Property name
	 *         val:       function () {},       -- function - Api method (or undefined if just an object
	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	 *       },
	 *       {
	 *         name:     'row'
	 *         val:       {},
	 *         methodExt: [ ... ],
	 *         propExt:   [
	 *           {
	 *             name:      'data'
	 *             val:       function () {},
	 *             methodExt: [ ... ],
	 *             propExt:   [ ... ]
	 *           },
	 *           ...
	 *         ]
	 *       }
	 *     ]
	 *
	 * @type {Array}
	 * @ignore
	 */
    var __apiStruct = [];
    /**
	 * `Array.prototype` reference.
	 *
	 * @type object
	 * @ignore
	 */
    var __arrayProto = Array.prototype;
    /**
	 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	 * take several different forms for ease of use.
	 *
	 * Each of the input parameter types will be converted to a DataTables settings
	 * object where possible.
	 *
	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	 *   of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 *   * `DataTables.Api` - API instance
	 * @return {array|null} Matching DataTables settings objects. `null` or
	 *   `undefined` is returned if no matching DataTable is found.
	 * @ignore
	 */
    var _toSettings = function (mixed) {
      var idx, jq;
      var settings = DataTable.settings;
      var tables = $.map(settings, function (el, i) {
          return el.nTable;
        });
      if (!mixed) {
        return [];
      } else if (mixed.nTable && mixed.oApi) {
        // DataTables settings object
        return [mixed];
      } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
        // Table node
        idx = $.inArray(mixed, tables);
        return idx !== -1 ? [settings[idx]] : null;
      } else if (mixed && typeof mixed.settings === 'function') {
        return mixed.settings().toArray();
      } else if (typeof mixed === 'string') {
        // jQuery selector
        jq = $(mixed);
      } else if (mixed instanceof $) {
        // jQuery object (also DataTables instance)
        jq = mixed;
      }
      if (jq) {
        return jq.map(function (i) {
          idx = $.inArray(this, tables);
          return idx !== -1 ? settings[idx] : null;
        }).toArray();
      }
    };
    /**
	 * DataTables API class - used to control and interface with  one or more
	 * DataTables enhanced tables.
	 *
	 * The API class is heavily based on jQuery, presenting a chainable interface
	 * that you can use to interact with tables. Each instance of the API class has
	 * a "context" - i.e. the tables that it will operate on. This could be a single
	 * table, all tables on a page or a sub-set thereof.
	 *
	 * Additionally the API is designed to allow you to easily work with the data in
	 * the tables, retrieving and manipulating it as required. This is done by
	 * presenting the API class as an array like interface. The contents of the
	 * array depend upon the actions requested by each method (for example
	 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	 * return an array of objects or arrays depending upon your table's
	 * configuration). The API object has a number of array like methods (`push`,
	 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	 * `unique` etc) to assist your working with the data held in a table.
	 *
	 * Most methods (those which return an Api instance) are chainable, which means
	 * the return from a method call also has all of the methods available that the
	 * top level object had. For example, these two calls are equivalent:
	 *
	 *     // Not chained
	 *     api.row.add( {...} );
	 *     api.draw();
	 *
	 *     // Chained
	 *     api.row.add( {...} ).draw();
	 *
	 * @class DataTable.Api
	 * @param {array|object|string|jQuery} context DataTable identifier. This is
	 *   used to define which DataTables enhanced tables this API will operate on.
	 *   Can be one of:
	 *
	 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	 *     with be found and used.
	 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	 *   * `object` - DataTables settings object
	 * @param {array} [data] Data to initialise the Api instance with.
	 *
	 * @example
	 *   // Direct initialisation during DataTables construction
	 *   var api = $('#example').DataTable();
	 *
	 * @example
	 *   // Initialisation using a DataTables jQuery object
	 *   var api = $('#example').dataTable().api();
	 *
	 * @example
	 *   // Initialisation as a constructor
	 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	 */
    _Api = function (context, data) {
      if (!(this instanceof _Api)) {
        return new _Api(context, data);
      }
      var settings = [];
      var ctxSettings = function (o) {
        var a = _toSettings(o);
        if (a) {
          settings.push.apply(settings, a);
        }
      };
      if ($.isArray(context)) {
        for (var i = 0, ien = context.length; i < ien; i++) {
          ctxSettings(context[i]);
        }
      } else {
        ctxSettings(context);
      }
      // Remove duplicates
      this.context = _unique(settings);
      // Initial data
      if (data) {
        this.push.apply(this, data.toArray ? data.toArray() : data);
      }
      // selector
      this.selector = {
        rows: null,
        cols: null,
        opts: null
      };
      _Api.extend(this, this, __apiStruct);
    };
    DataTable.Api = _Api;
    _Api.prototype = {
      any: function () {
        return this.flatten().length !== 0;
      },
      concat: __arrayProto.concat,
      context: [],
      each: function (fn) {
        for (var i = 0, ien = this.length; i < ien; i++) {
          fn.call(this, this[i], i, this);
        }
        return this;
      },
      eq: function (idx) {
        var ctx = this.context;
        return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
      },
      filter: function (fn) {
        var a = [];
        if (__arrayProto.filter) {
          a = __arrayProto.filter.call(this, fn, this);
        } else {
          // Compatibility for browsers without EMCA-252-5 (JS 1.6)
          for (var i = 0, ien = this.length; i < ien; i++) {
            if (fn.call(this, this[i], i, this)) {
              a.push(this[i]);
            }
          }
        }
        return new _Api(this.context, a);
      },
      flatten: function () {
        var a = [];
        return new _Api(this.context, a.concat.apply(a, this.toArray()));
      },
      join: __arrayProto.join,
      indexOf: __arrayProto.indexOf || function (obj, start) {
        for (var i = start || 0, ien = this.length; i < ien; i++) {
          if (this[i] === obj) {
            return i;
          }
        }
        return -1;
      },
      iterator: function (flatten, type, fn, alwaysNew) {
        var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
        // Argument shifting
        if (typeof flatten === 'string') {
          alwaysNew = fn;
          fn = type;
          type = flatten;
          flatten = false;
        }
        for (i = 0, ien = context.length; i < ien; i++) {
          var apiInst = new _Api(context[i]);
          if (type === 'table') {
            ret = fn.call(apiInst, context[i], i);
            if (ret !== undefined) {
              a.push(ret);
            }
          } else if (type === 'columns' || type === 'rows') {
            // this has same length as context - one entry for each table
            ret = fn.call(apiInst, context[i], this[i], i);
            if (ret !== undefined) {
              a.push(ret);
            }
          } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
            // columns and rows share the same structure.
            // 'this' is an array of column indexes for each context
            items = this[i];
            if (type === 'column-rows') {
              rows = _selector_row_indexes(context[i], selector.opts);
            }
            for (j = 0, jen = items.length; j < jen; j++) {
              item = items[j];
              if (type === 'cell') {
                ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
              } else {
                ret = fn.call(apiInst, context[i], item, i, j, rows);
              }
              if (ret !== undefined) {
                a.push(ret);
              }
            }
          }
        }
        if (a.length || alwaysNew) {
          var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
          var apiSelector = api.selector;
          apiSelector.rows = selector.rows;
          apiSelector.cols = selector.cols;
          apiSelector.opts = selector.opts;
          return api;
        }
        return this;
      },
      lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
        // Bit cheeky...
        return this.indexOf.apply(this.toArray.reverse(), arguments);
      },
      length: 0,
      map: function (fn) {
        var a = [];
        if (__arrayProto.map) {
          a = __arrayProto.map.call(this, fn, this);
        } else {
          // Compatibility for browsers without EMCA-252-5 (JS 1.6)
          for (var i = 0, ien = this.length; i < ien; i++) {
            a.push(fn.call(this, this[i], i));
          }
        }
        return new _Api(this.context, a);
      },
      pluck: function (prop) {
        return this.map(function (el) {
          return el[prop];
        });
      },
      pop: __arrayProto.pop,
      push: __arrayProto.push,
      reduce: __arrayProto.reduce || function (fn, init) {
        return _fnReduce(this, fn, init, 0, this.length, 1);
      },
      reduceRight: __arrayProto.reduceRight || function (fn, init) {
        return _fnReduce(this, fn, init, this.length - 1, -1, -1);
      },
      reverse: __arrayProto.reverse,
      selector: null,
      shift: __arrayProto.shift,
      sort: __arrayProto.sort,
      splice: __arrayProto.splice,
      toArray: function () {
        return __arrayProto.slice.call(this);
      },
      to$: function () {
        return $(this);
      },
      toJQuery: function () {
        return $(this);
      },
      unique: function () {
        return new _Api(this.context, _unique(this));
      },
      unshift: __arrayProto.unshift
    };
    _Api.extend = function (scope, obj, ext) {
      // Only extend API instances and static properties of the API
      if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
        return;
      }
      var i, ien, j, jen, struct, inner, methodScoping = function (scope, fn, struc) {
          return function () {
            var ret = fn.apply(scope, arguments);
            // Method extension
            _Api.extend(ret, ret, struc.methodExt);
            return ret;
          };
        };
      for (i = 0, ien = ext.length; i < ien; i++) {
        struct = ext[i];
        // Value
        obj[struct.name] = typeof struct.val === 'function' ? methodScoping(scope, struct.val, struct) : $.isPlainObject(struct.val) ? {} : struct.val;
        obj[struct.name].__dt_wrapper = true;
        // Property extension
        _Api.extend(scope, obj[struct.name], struct.propExt);
      }
    };
    // @todo - Is there need for an augment function?
    // _Api.augment = function ( inst, name )
    // {
    // 	// Find src object in the structure from the name
    // 	var parts = name.split('.');
    // 	_Api.extend( inst, obj );
    // };
    //     [
    //       {
    //         name:      'data'                -- string   - Property name
    //         val:       function () {},       -- function - Api method (or undefined if just an object
    //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
    //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
    //       },
    //       {
    //         name:     'row'
    //         val:       {},
    //         methodExt: [ ... ],
    //         propExt:   [
    //           {
    //             name:      'data'
    //             val:       function () {},
    //             methodExt: [ ... ],
    //             propExt:   [ ... ]
    //           },
    //           ...
    //         ]
    //       }
    //     ]
    _Api.register = _api_register = function (name, val) {
      if ($.isArray(name)) {
        for (var j = 0, jen = name.length; j < jen; j++) {
          _Api.register(name[j], val);
        }
        return;
      }
      var i, ien, heir = name.split('.'), struct = __apiStruct, key, method;
      var find = function (src, name) {
        for (var i = 0, ien = src.length; i < ien; i++) {
          if (src[i].name === name) {
            return src[i];
          }
        }
        return null;
      };
      for (i = 0, ien = heir.length; i < ien; i++) {
        method = heir[i].indexOf('()') !== -1;
        key = method ? heir[i].replace('()', '') : heir[i];
        var src = find(struct, key);
        if (!src) {
          src = {
            name: key,
            val: {},
            methodExt: [],
            propExt: []
          };
          struct.push(src);
        }
        if (i === ien - 1) {
          src.val = val;
        } else {
          struct = method ? src.methodExt : src.propExt;
        }
      }
    };
    _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {
      _Api.register(pluralName, val);
      _Api.register(singularName, function () {
        var ret = val.apply(this, arguments);
        if (ret === this) {
          // Returned item is the API instance that was passed in, return it
          return this;
        } else if (ret instanceof _Api) {
          // New API instance returned, want the value from the first item
          // in the returned array for the singular result.
          return ret.length ? $.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : ret[0] : undefined;
        }
        // Non-API return - just fire it back
        return ret;
      });
    };
    /**
	 * Selector for HTML tables. Apply the given selector to the give array of
	 * DataTables settings objects.
	 *
	 * @param {string|integer} [selector] jQuery selector string or integer
	 * @param  {array} Array of DataTables settings objects to be filtered
	 * @return {array}
	 * @ignore
	 */
    var __table_selector = function (selector, a) {
      // Integer is used to pick out a table by index
      if (typeof selector === 'number') {
        return [a[selector]];
      }
      // Perform a jQuery selector on the table nodes
      var nodes = $.map(a, function (el, i) {
          return el.nTable;
        });
      return $(nodes).filter(selector).map(function (i) {
        // Need to translate back from the table node to the settings
        var idx = $.inArray(this, nodes);
        return a[idx];
      }).toArray();
    };
    /**
	 * Context selector for the API's context (i.e. the tables the API instance
	 * refers to.
	 *
	 * @name    DataTable.Api#tables
	 * @param {string|integer} [selector] Selector to pick which tables the iterator
	 *   should operate on. If not given, all tables in the current context are
	 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	 *   select multiple tables or as an integer to select a single table.
	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	 */
    _api_register('tables()', function (selector) {
      // A new instance is created if there was a selector specified
      return selector ? new _Api(__table_selector(selector, this.context)) : this;
    });
    _api_register('table()', function (selector) {
      var tables = this.tables(selector);
      var ctx = tables.context;
      // Truncate to the first matched table
      return ctx.length ? new _Api(ctx[0]) : tables;
    });
    _api_registerPlural('tables().nodes()', 'table().node()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTable;
      }, 1);
    });
    _api_registerPlural('tables().body()', 'table().body()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTBody;
      }, 1);
    });
    _api_registerPlural('tables().header()', 'table().header()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTHead;
      }, 1);
    });
    _api_registerPlural('tables().footer()', 'table().footer()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTFoot;
      }, 1);
    });
    _api_registerPlural('tables().containers()', 'table().container()', function () {
      return this.iterator('table', function (ctx) {
        return ctx.nTableWrapper;
      }, 1);
    });
    /**
	 * Redraw the tables in the current context.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
    _api_register('draw()', function (resetPaging) {
      return this.iterator('table', function (settings) {
        _fnReDraw(settings, resetPaging === false);
      });
    });
    /**
	 * Get the current page index.
	 *
	 * @return {integer} Current page index (zero based)
	 */
    /**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * `integer` - The page index to jump to
	 *  * `string` - An action to take:
	 *    * `first` - Jump to first page.
	 *    * `next` - Jump to the next page
	 *    * `previous` - Jump to previous page
	 *    * `last` - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */
    _api_register('page()', function (action) {
      if (action === undefined) {
        return this.page.info().page;  // not an expensive call
      }
      // else, have an action to take on all tables
      return this.iterator('table', function (settings) {
        _fnPageChange(settings, action);
      });
    });
    /**
	 * Paging information for the first table in the current context.
	 *
	 * If you require paging information for another table, use the `table()` method
	 * with a suitable selector.
	 *
	 * @return {object} Object with the following properties set:
	 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	 *  * `pages` - Total number of pages
	 *  * `start` - Display index for the first record shown on the current page
	 *  * `end` - Display index for the last record shown on the current page
	 *  * `length` - Display length (number of records). Note that generally `start
	 *    + length = end`, but this is not always true, for example if there are
	 *    only 2 records to show on the final page, with a length of 10.
	 *  * `recordsTotal` - Full data set length
	 *  * `recordsDisplay` - Data set length once the current filtering criterion
	 *    are applied.
	 */
    _api_register('page.info()', function (action) {
      if (this.context.length === 0) {
        return undefined;
      }
      var settings = this.context[0], start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1;
      return {
        'page': all ? 0 : Math.floor(start / len),
        'pages': all ? 1 : Math.ceil(visRecords / len),
        'start': start,
        'end': settings.fnDisplayEnd(),
        'length': len,
        'recordsTotal': settings.fnRecordsTotal(),
        'recordsDisplay': visRecords
      };
    });
    /**
	 * Get the current page length.
	 *
	 * @return {integer} Current page length. Note `-1` indicates that all records
	 *   are to be shown.
	 */
    /**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use `-1` to show all records.
	 * @returns {DataTables.Api} this
	 */
    _api_register('page.len()', function (len) {
      // Note that we can't call this function 'length()' because `length`
      // is a Javascript property of functions which defines how many arguments
      // the function expects.
      if (len === undefined) {
        return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
      }
      // else, set the page length
      return this.iterator('table', function (settings) {
        _fnLengthChange(settings, len);
      });
    });
    var __reload = function (settings, holdPosition, callback) {
      // Use the draw event to trigger a callback
      if (callback) {
        var api = new _Api(settings);
        api.one('draw', function () {
          callback(api.ajax.json());
        });
      }
      if (_fnDataSource(settings) == 'ssp') {
        _fnReDraw(settings, holdPosition);
      } else {
        // Trigger xhr
        _fnProcessingDisplay(settings, true);
        _fnBuildAjax(settings, [], function (json) {
          _fnClearTable(settings);
          var data = _fnAjaxDataSrc(settings, json);
          for (var i = 0, ien = data.length; i < ien; i++) {
            _fnAddData(settings, data[i]);
          }
          _fnReDraw(settings, holdPosition);
          _fnProcessingDisplay(settings, false);
        });
      }
    };
    /**
	 * Get the JSON response from the last Ajax request that DataTables made to the
	 * server. Note that this returns the JSON from the first table in the current
	 * context.
	 *
	 * @return {object} JSON received from the server.
	 */
    _api_register('ajax.json()', function () {
      var ctx = this.context;
      if (ctx.length > 0) {
        return ctx[0].json;
      }  // else return undefined;
    });
    /**
	 * Get the data submitted in the last Ajax request
	 */
    _api_register('ajax.params()', function () {
      var ctx = this.context;
      if (ctx.length > 0) {
        return ctx[0].oAjaxData;
      }  // else return undefined;
    });
    /**
	 * Reload tables from the Ajax data source. Note that this function will
	 * automatically re-draw the table when the remote data has been loaded.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
    _api_register('ajax.reload()', function (callback, resetPaging) {
      return this.iterator('table', function (settings) {
        __reload(settings, resetPaging === false, callback);
      });
    });
    /**
	 * Get the current Ajax URL. Note that this returns the URL from the first
	 * table in the current context.
	 *
	 * @return {string} Current Ajax source URL
	 */
    /**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */
    _api_register('ajax.url()', function (url) {
      var ctx = this.context;
      if (url === undefined) {
        // get
        if (ctx.length === 0) {
          return undefined;
        }
        ctx = ctx[0];
        return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
      }
      // set
      return this.iterator('table', function (settings) {
        if ($.isPlainObject(settings.ajax)) {
          settings.ajax.url = url;
        } else {
          settings.ajax = url;
        }  // No need to consider sAjaxSource here since DataTables gives priority
           // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
           // value of `sAjaxSource` redundant.
      });
    });
    /**
	 * Load data from the newly set Ajax URL. Note that this method is only
	 * available when `ajax.url()` is used to set a URL. Additionally, this method
	 * has the same effect as calling `ajax.reload()` but is provided for
	 * convenience when setting a new URL. Like `ajax.reload()` it will
	 * automatically redraw the table once the remote data has been loaded.
	 *
	 * @returns {DataTables.Api} this
	 */
    _api_register('ajax.url().load()', function (callback, resetPaging) {
      // Same as a reload, but makes sense to present it for easy access after a
      // url change
      return this.iterator('table', function (ctx) {
        __reload(ctx, resetPaging === false, callback);
      });
    });
    var _selector_run = function (type, selector, selectFn, settings, opts) {
      var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
      // Can't just check for isArray here, as an API or jQuery instance might be
      // given with their array like look
      if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
        selector = [selector];
      }
      for (i = 0, ien = selector.length; i < ien; i++) {
        a = selector[i] && selector[i].split ? selector[i].split(',') : [selector[i]];
        for (j = 0, jen = a.length; j < jen; j++) {
          res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);
          if (res && res.length) {
            out.push.apply(out, res);
          }
        }
      }
      // selector extensions
      var ext = _ext.selector[type];
      if (ext.length) {
        for (i = 0, ien = ext.length; i < ien; i++) {
          out = ext[i](settings, opts, out);
        }
      }
      return out;
    };
    var _selector_opts = function (opts) {
      if (!opts) {
        opts = {};
      }
      // Backwards compatibility for 1.9- which used the terminology filter rather
      // than search
      if (opts.filter && opts.search === undefined) {
        opts.search = opts.filter;
      }
      return $.extend({
        search: 'none',
        order: 'current',
        page: 'all'
      }, opts);
    };
    var _selector_first = function (inst) {
      // Reduce the API instance to the first item found
      for (var i = 0, ien = inst.length; i < ien; i++) {
        if (inst[i].length > 0) {
          // Assign the first element to the first item in the instance
          // and truncate the instance and context
          inst[0] = inst[i];
          inst[0].length = 1;
          inst.length = 1;
          inst.context = [inst.context[i]];
          return inst;
        }
      }
      // Not found - return an empty instance
      inst.length = 0;
      return inst;
    };
    var _selector_row_indexes = function (settings, opts) {
      var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
      var search = opts.search,
        // none, applied, removed
        order = opts.order,
        // applied, current, index (original - compatibility with 1.9)
        page = opts.page;
      // all, current
      if (_fnDataSource(settings) == 'ssp') {
        // In server-side processing mode, most options are irrelevant since
        // rows not shown don't exist and the index order is the applied order
        // Removed is a special case - for consistency just return an empty
        // array
        return search === 'removed' ? [] : _range(0, displayMaster.length);
      } else if (page == 'current') {
        // Current page implies that order=current and fitler=applied, since it is
        // fairly senseless otherwise, regardless of what order and search actually
        // are
        for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
          a.push(displayFiltered[i]);
        }
      } else if (order == 'current' || order == 'applied') {
        a = search == 'none' ? displayMaster.slice() : search == 'applied' ? displayFiltered.slice() : $.map(displayMaster, function (el, i) {
          // removed search
          return $.inArray(el, displayFiltered) === -1 ? el : null;
        });
      } else if (order == 'index' || order == 'original') {
        for (i = 0, ien = settings.aoData.length; i < ien; i++) {
          if (search == 'none') {
            a.push(i);
          } else {
            // applied | removed
            tmp = $.inArray(i, displayFiltered);
            if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
              a.push(i);
            }
          }
        }
      }
      return a;
    };
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
    var __row_selector = function (settings, selector, opts) {
      var run = function (sel) {
        var selInt = _intVal(sel);
        var i, ien;
        // Short cut - selector is a number and no options provided (default is
        // all records, so no need to check if the index is in there, since it
        // must be - dev error if the index doesn't exist).
        if (selInt !== null && !opts) {
          return [selInt];
        }
        var rows = _selector_row_indexes(settings, opts);
        if (selInt !== null && $.inArray(selInt, rows) !== -1) {
          // Selector - integer
          return [selInt];
        } else if (!sel) {
          // Selector - none
          return rows;
        }
        // Selector - function
        if (typeof sel === 'function') {
          return $.map(rows, function (idx) {
            var row = settings.aoData[idx];
            return sel(idx, row._aData, row.nTr) ? idx : null;
          });
        }
        // Get nodes in the order from the `rows` array with null values removed
        var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr'));
        // Selector - node
        if (sel.nodeName) {
          if ($.inArray(sel, nodes) !== -1) {
            return [sel._DT_RowIndex];  // sel is a TR node that is in the table
                                        // and DataTables adds a prop for fast lookup
          }
        }
        // Selector - jQuery selector string, array of nodes or jQuery object/
        // As jQuery's .filter() allows jQuery objects to be passed in filter,
        // it also allows arrays, so this will cope with all three options
        return $(nodes).filter(sel).map(function () {
          return this._DT_RowIndex;
        }).toArray();
      };
      return _selector_run('row', selector, run, settings, opts);
    };
    _api_register('rows()', function (selector, opts) {
      // argument shifting
      if (selector === undefined) {
        selector = '';
      } else if ($.isPlainObject(selector)) {
        opts = selector;
        selector = '';
      }
      opts = _selector_opts(opts);
      var inst = this.iterator('table', function (settings) {
          return __row_selector(settings, selector, opts);
        }, 1);
      // Want argument shifting here and in __row_selector?
      inst.selector.rows = selector;
      inst.selector.opts = opts;
      return inst;
    });
    _api_register('rows().nodes()', function () {
      return this.iterator('row', function (settings, row) {
        return settings.aoData[row].nTr || undefined;
      }, 1);
    });
    _api_register('rows().data()', function () {
      return this.iterator(true, 'rows', function (settings, rows) {
        return _pluck_order(settings.aoData, rows, '_aData');
      }, 1);
    });
    _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
      return this.iterator('row', function (settings, row) {
        var r = settings.aoData[row];
        return type === 'search' ? r._aFilterData : r._aSortData;
      }, 1);
    });
    _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
      return this.iterator('row', function (settings, row) {
        _fnInvalidate(settings, row, src);
      });
    });
    _api_registerPlural('rows().indexes()', 'row().index()', function () {
      return this.iterator('row', function (settings, row) {
        return row;
      }, 1);
    });
    _api_registerPlural('rows().remove()', 'row().remove()', function () {
      var that = this;
      return this.iterator('row', function (settings, row, thatIdx) {
        var data = settings.aoData;
        data.splice(row, 1);
        // Update the _DT_RowIndex parameter on all rows in the table
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i].nTr !== null) {
            data[i].nTr._DT_RowIndex = i;
          }
        }
        // Remove the target row from the search array
        var displayIndex = $.inArray(row, settings.aiDisplay);
        // Delete from the display arrays
        _fnDeleteIndex(settings.aiDisplayMaster, row);
        _fnDeleteIndex(settings.aiDisplay, row);
        _fnDeleteIndex(that[thatIdx], row, false);
        // maintain local indexes
        // Check for an 'overflow' they case for displaying the table
        _fnLengthOverflow(settings);
      });
    });
    _api_register('rows.add()', function (rows) {
      var newRows = this.iterator('table', function (settings) {
          var row, i, ien;
          var out = [];
          for (i = 0, ien = rows.length; i < ien; i++) {
            row = rows[i];
            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
              out.push(_fnAddTr(settings, row)[0]);
            } else {
              out.push(_fnAddData(settings, row));
            }
          }
          return out;
        }, 1);
      // Return an Api.rows() extended instance, so rows().nodes() etc can be used
      var modRows = this.rows(-1);
      modRows.pop();
      modRows.push.apply(modRows, newRows.toArray());
      return modRows;
    });
    /**
	 *
	 */
    _api_register('row()', function (selector, opts) {
      return _selector_first(this.rows(selector, opts));
    });
    _api_register('row().data()', function (data) {
      var ctx = this.context;
      if (data === undefined) {
        // Get
        return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
      }
      // Set
      ctx[0].aoData[this[0]]._aData = data;
      // Automatically invalidate
      _fnInvalidate(ctx[0], this[0], 'data');
      return this;
    });
    _api_register('row().node()', function () {
      var ctx = this.context;
      return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
    });
    _api_register('row.add()', function (row) {
      // Allow a jQuery object to be passed in - only a single row is added from
      // it though - the first element in the set
      if (row instanceof $ && row.length) {
        row = row[0];
      }
      var rows = this.iterator('table', function (settings) {
          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
            return _fnAddTr(settings, row)[0];
          }
          return _fnAddData(settings, row);
        });
      // Return an Api.rows() extended instance, with the newly added row selected
      return this.row(rows[0]);
    });
    var __details_add = function (ctx, row, data, klass) {
      // Convert to array of TR elements
      var rows = [];
      var addRow = function (r, k) {
        // Recursion to allow for arrays of jQuery objects
        if ($.isArray(r) || r instanceof $) {
          for (var i = 0, ien = r.length; i < ien; i++) {
            addRow(r[i], k);
          }
          return;
        }
        // If we get a TR element, then just add it directly - up to the dev
        // to add the correct number of columns etc
        if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
          rows.push(r);
        } else {
          // Otherwise create a row with a wrapper
          var created = $('<tr><td/></tr>').addClass(k);
          $('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
          rows.push(created[0]);
        }
      };
      addRow(data, klass);
      if (row._details) {
        row._details.remove();
      }
      row._details = $(rows);
      // If the children were already shown, that state should be retained
      if (row._detailsShow) {
        row._details.insertAfter(row.nTr);
      }
    };
    var __details_remove = function (api, idx) {
      var ctx = api.context;
      if (ctx.length) {
        var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];
        if (row._details) {
          row._details.remove();
          row._detailsShow = undefined;
          row._details = undefined;
        }
      }
    };
    var __details_display = function (api, show) {
      var ctx = api.context;
      if (ctx.length && api.length) {
        var row = ctx[0].aoData[api[0]];
        if (row._details) {
          row._detailsShow = show;
          if (show) {
            row._details.insertAfter(row.nTr);
          } else {
            row._details.detach();
          }
          __details_events(ctx[0]);
        }
      }
    };
    var __details_events = function (settings) {
      var api = new _Api(settings);
      var namespace = '.dt.DT_details';
      var drawEvent = 'draw' + namespace;
      var colvisEvent = 'column-visibility' + namespace;
      var destroyEvent = 'destroy' + namespace;
      var data = settings.aoData;
      api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);
      if (_pluck(data, '_details').length > 0) {
        // On each draw, insert the required elements into the document
        api.on(drawEvent, function (e, ctx) {
          if (settings !== ctx) {
            return;
          }
          api.rows({ page: 'current' }).eq(0).each(function (idx) {
            // Internal data grab
            var row = data[idx];
            if (row._detailsShow) {
              row._details.insertAfter(row.nTr);
            }
          });
        });
        // Column visibility change - update the colspan
        api.on(colvisEvent, function (e, ctx, idx, vis) {
          if (settings !== ctx) {
            return;
          }
          // Update the colspan for the details rows (note, only if it already has
          // a colspan)
          var row, visible = _fnVisbleColumns(ctx);
          for (var i = 0, ien = data.length; i < ien; i++) {
            row = data[i];
            if (row._details) {
              row._details.children('td[colspan]').attr('colspan', visible);
            }
          }
        });
        // Table destroyed - nuke any child rows
        api.on(destroyEvent, function (e, ctx) {
          if (settings !== ctx) {
            return;
          }
          for (var i = 0, ien = data.length; i < ien; i++) {
            if (data[i]._details) {
              __details_remove(api, i);
            }
          }
        });
      }
    };
    // Strings for the method names to help minification
    var _emp = '';
    var _child_obj = _emp + 'row().child';
    var _child_mth = _child_obj + '()';
    // data can be:
    //  tr
    //  string
    //  jQuery or array of any of the above
    _api_register(_child_mth, function (data, klass) {
      var ctx = this.context;
      if (data === undefined) {
        // get
        return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
      } else if (data === true) {
        // show
        this.child.show();
      } else if (data === false) {
        // remove
        __details_remove(this);
      } else if (ctx.length && this.length) {
        // set
        __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
      }
      return this;
    });
    _api_register([
      _child_obj + '.show()',
      _child_mth + '.show()'
    ], function (show) {
      // it returns an object and this method is not executed)
      __details_display(this, true);
      return this;
    });
    _api_register([
      _child_obj + '.hide()',
      _child_mth + '.hide()'
    ], function () {
      // it returns an object and this method is not executed)
      __details_display(this, false);
      return this;
    });
    _api_register([
      _child_obj + '.remove()',
      _child_mth + '.remove()'
    ], function () {
      // it returns an object and this method is not executed)
      __details_remove(this);
      return this;
    });
    _api_register(_child_obj + '.isShown()', function () {
      var ctx = this.context;
      if (ctx.length && this.length) {
        // _detailsShown as false or undefined will fall through to return false
        return ctx[0].aoData[this[0]]._detailsShow || false;
      }
      return false;
    });
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (>=0 count from left, <0 count from right)
	 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	 * "{string}:name"     - column name
	 * "{string}"          - jQuery selector on column header nodes
	 *
	 */
    // can be an array of these items, comma separated list, or an array of comma
    // separated lists
    var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
    // r1 and r2 are redundant - but it means that the parameters match for the
    // iterator callback in columns().data()
    var __columnData = function (settings, column, r1, r2, rows) {
      var a = [];
      for (var row = 0, ien = rows.length; row < ien; row++) {
        a.push(_fnGetCellData(settings, rows[row], column));
      }
      return a;
    };
    var __column_selector = function (settings, selector, opts) {
      var columns = settings.aoColumns, names = _pluck(columns, 'sName'), nodes = _pluck(columns, 'nTh');
      var run = function (s) {
        var selInt = _intVal(s);
        // Selector - all
        if (s === '') {
          return _range(columns.length);
        }
        // Selector - index
        if (selInt !== null) {
          return [selInt >= 0 ? selInt : columns.length + selInt];
        }
        // Selector = function
        if (typeof s === 'function') {
          var rows = _selector_row_indexes(settings, opts);
          return $.map(columns, function (col, idx) {
            return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
          });
        }
        // jQuery or string selector
        var match = typeof s === 'string' ? s.match(__re_column_selector) : '';
        if (match) {
          switch (match[2]) {
          case 'visIdx':
          case 'visible':
            var idx = parseInt(match[1], 10);
            // Visible index given, convert to column index
            if (idx < 0) {
              // Counting from the right
              var visColumns = $.map(columns, function (col, i) {
                  return col.bVisible ? i : null;
                });
              return [visColumns[visColumns.length + idx]];
            }
            // Counting from the left
            return [_fnVisibleToColumnIndex(settings, idx)];
          case 'name':
            // match by name. `names` is column index complete and in order
            return $.map(names, function (name, i) {
              return name === match[1] ? i : null;
            });
          }
        } else {
          // jQuery selector on the TH elements for the columns
          return $(nodes).filter(s).map(function () {
            return $.inArray(this, nodes);  // `nodes` is column index complete and in order
          }).toArray();
        }
      };
      return _selector_run('column', selector, run, settings, opts);
    };
    var __setColumnVis = function (settings, column, vis, recalc) {
      var cols = settings.aoColumns, col = cols[column], data = settings.aoData, row, cells, i, ien, tr;
      // Get
      if (vis === undefined) {
        return col.bVisible;
      }
      // Set
      // No change
      if (col.bVisible === vis) {
        return;
      }
      if (vis) {
        // Insert column
        // Need to decide if we should use appendChild or insertBefore
        var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);
        for (i = 0, ien = data.length; i < ien; i++) {
          tr = data[i].nTr;
          cells = data[i].anCells;
          if (tr) {
            // insertBefore can act like appendChild if 2nd arg is null
            tr.insertBefore(cells[column], cells[insertBefore] || null);
          }
        }
      } else {
        // Remove column
        $(_pluck(settings.aoData, 'anCells', column)).detach();
      }
      // Common actions
      col.bVisible = vis;
      _fnDrawHead(settings, settings.aoHeader);
      _fnDrawHead(settings, settings.aoFooter);
      if (recalc === undefined || recalc) {
        // Automatically adjust column sizing
        _fnAdjustColumnSizing(settings);
        // Realign columns for scrolling
        if (settings.oScroll.sX || settings.oScroll.sY) {
          _fnScrollDraw(settings);
        }
      }
      _fnCallbackFire(settings, null, 'column-visibility', [
        settings,
        column,
        vis
      ]);
      _fnSaveState(settings);
    };
    _api_register('columns()', function (selector, opts) {
      // argument shifting
      if (selector === undefined) {
        selector = '';
      } else if ($.isPlainObject(selector)) {
        opts = selector;
        selector = '';
      }
      opts = _selector_opts(opts);
      var inst = this.iterator('table', function (settings) {
          return __column_selector(settings, selector, opts);
        }, 1);
      // Want argument shifting here and in _row_selector?
      inst.selector.cols = selector;
      inst.selector.opts = opts;
      return inst;
    });
    _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
      return this.iterator('column', function (settings, column) {
        return settings.aoColumns[column].nTh;
      }, 1);
    });
    _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
      return this.iterator('column', function (settings, column) {
        return settings.aoColumns[column].nTf;
      }, 1);
    });
    _api_registerPlural('columns().data()', 'column().data()', function () {
      return this.iterator('column-rows', __columnData, 1);
    });
    _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
      return this.iterator('column', function (settings, column) {
        return settings.aoColumns[column].mData;
      }, 1);
    });
    _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
      return this.iterator('column-rows', function (settings, column, i, j, rows) {
        return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
      }, 1);
    });
    _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
      return this.iterator('column-rows', function (settings, column, i, j, rows) {
        return _pluck_order(settings.aoData, rows, 'anCells', column);
      }, 1);
    });
    _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
      return this.iterator('column', function (settings, column) {
        if (vis === undefined) {
          return settings.aoColumns[column].bVisible;
        }
        // else
        __setColumnVis(settings, column, vis, calc);
      });
    });
    _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
      return this.iterator('column', function (settings, column) {
        return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
      }, 1);
    });
    _api_register('columns.adjust()', function () {
      return this.iterator('table', function (settings) {
        _fnAdjustColumnSizing(settings);
      }, 1);
    });
    _api_register('column.index()', function (type, idx) {
      if (this.context.length !== 0) {
        var ctx = this.context[0];
        if (type === 'fromVisible' || type === 'toData') {
          return _fnVisibleToColumnIndex(ctx, idx);
        } else if (type === 'fromData' || type === 'toVisible') {
          return _fnColumnIndexToVisible(ctx, idx);
        }
      }
    });
    _api_register('column()', function (selector, opts) {
      return _selector_first(this.columns(selector, opts));
    });
    var __cell_selector = function (settings, selector, opts) {
      var data = settings.aoData;
      var rows = _selector_row_indexes(settings, opts);
      var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));
      var allCells = $([].concat.apply([], cells));
      var row;
      var columns = settings.aoColumns.length;
      var a, i, ien, j, o, host;
      var run = function (s) {
        var fnSelector = typeof s === 'function';
        if (s === null || s === undefined || fnSelector) {
          // All cells and function selectors
          a = [];
          for (i = 0, ien = rows.length; i < ien; i++) {
            row = rows[i];
            for (j = 0; j < columns; j++) {
              o = {
                row: row,
                column: j
              };
              if (fnSelector) {
                // Selector - function
                host = settings.aoData[row];
                if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                  a.push(o);
                }
              } else {
                // Selector - all
                a.push(o);
              }
            }
          }
          return a;
        }
        // Selector - index
        if ($.isPlainObject(s)) {
          return [s];
        }
        // Selector - jQuery filtered cells
        return allCells.filter(s).map(function (i, el) {
          row = el.parentNode._DT_RowIndex;
          return {
            row: row,
            column: $.inArray(el, data[row].anCells)
          };
        }).toArray();
      };
      return _selector_run('cell', selector, run, settings, opts);
    };
    _api_register('cells()', function (rowSelector, columnSelector, opts) {
      // Argument shifting
      if ($.isPlainObject(rowSelector)) {
        // Indexes
        if (rowSelector.row === undefined) {
          // Selector options in first parameter
          opts = rowSelector;
          rowSelector = null;
        } else {
          // Cell index objects in first parameter
          opts = columnSelector;
          columnSelector = null;
        }
      }
      if ($.isPlainObject(columnSelector)) {
        opts = columnSelector;
        columnSelector = null;
      }
      // Cell selector
      if (columnSelector === null || columnSelector === undefined) {
        return this.iterator('table', function (settings) {
          return __cell_selector(settings, rowSelector, _selector_opts(opts));
        });
      }
      // Row + column selector
      var columns = this.columns(columnSelector, opts);
      var rows = this.rows(rowSelector, opts);
      var a, i, ien, j, jen;
      var cells = this.iterator('table', function (settings, idx) {
          a = [];
          for (i = 0, ien = rows[idx].length; i < ien; i++) {
            for (j = 0, jen = columns[idx].length; j < jen; j++) {
              a.push({
                row: rows[idx][i],
                column: columns[idx][j]
              });
            }
          }
          return a;
        }, 1);
      $.extend(cells.selector, {
        cols: columnSelector,
        rows: rowSelector,
        opts: opts
      });
      return cells;
    });
    _api_registerPlural('cells().nodes()', 'cell().node()', function () {
      return this.iterator('cell', function (settings, row, column) {
        var cells = settings.aoData[row].anCells;
        return cells ? cells[column] : undefined;
      }, 1);
    });
    _api_register('cells().data()', function () {
      return this.iterator('cell', function (settings, row, column) {
        return _fnGetCellData(settings, row, column);
      }, 1);
    });
    _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
      type = type === 'search' ? '_aFilterData' : '_aSortData';
      return this.iterator('cell', function (settings, row, column) {
        return settings.aoData[row][type][column];
      }, 1);
    });
    _api_registerPlural('cells().render()', 'cell().render()', function (type) {
      return this.iterator('cell', function (settings, row, column) {
        return _fnGetCellData(settings, row, column, type);
      }, 1);
    });
    _api_registerPlural('cells().indexes()', 'cell().index()', function () {
      return this.iterator('cell', function (settings, row, column) {
        return {
          row: row,
          column: column,
          columnVisible: _fnColumnIndexToVisible(settings, column)
        };
      }, 1);
    });
    _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
      return this.iterator('cell', function (settings, row, column) {
        _fnInvalidate(settings, row, src, column);
      });
    });
    _api_register('cell()', function (rowSelector, columnSelector, opts) {
      return _selector_first(this.cells(rowSelector, columnSelector, opts));
    });
    _api_register('cell().data()', function (data) {
      var ctx = this.context;
      var cell = this[0];
      if (data === undefined) {
        // Get
        return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
      }
      // Set
      _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
      _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);
      return this;
    });
    /**
	 * Get current ordering (sorting) that has been applied to the table.
	 *
	 * @returns {array} 2D array containing the sorting information for the first
	 *   table in the current context. Each element in the parent array represents
	 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	 *   the column index that the sorting condition applies to, the second is the
	 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	 *   index of the sorting order from the `column.sorting` initialisation array.
	 */
    /**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
	 * @returns {DataTables.Api} this
	 */
    /**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 */
    /**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */
    _api_register('order()', function (order, dir) {
      var ctx = this.context;
      if (order === undefined) {
        // get
        return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
      }
      // set
      if (typeof order === 'number') {
        // Simple column / direction passed in
        order = [[
            order,
            dir
          ]];
      } else if (!$.isArray(order[0])) {
        // Arguments passed in (list of 1D arrays)
        order = Array.prototype.slice.call(arguments);
      }
      // otherwise a 2D array was passed in
      return this.iterator('table', function (settings) {
        settings.aaSorting = order.slice();
      });
    });
    /**
	 * Attach a sort listener to an element for a given column
	 *
	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	 *   listener to. This can take the form of a single DOM node, a jQuery
	 *   collection of nodes or a jQuery selector which will identify the node(s).
	 * @param {integer} column the column that a click on this node will sort on
	 * @param {function} [callback] callback function when sort is run
	 * @returns {DataTables.Api} this
	 */
    _api_register('order.listener()', function (node, column, callback) {
      return this.iterator('table', function (settings) {
        _fnSortAttachListener(settings, node, column, callback);
      });
    });
    // Order by the selected column(s)
    _api_register([
      'columns().order()',
      'column().order()'
    ], function (dir) {
      var that = this;
      return this.iterator('table', function (settings, i) {
        var sort = [];
        $.each(that[i], function (j, col) {
          sort.push([
            col,
            dir
          ]);
        });
        settings.aaSorting = sort;
      });
    });
    _api_register('search()', function (input, regex, smart, caseInsen) {
      var ctx = this.context;
      if (input === undefined) {
        // get
        return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
      }
      // set
      return this.iterator('table', function (settings) {
        if (!settings.oFeatures.bFilter) {
          return;
        }
        _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
          'sSearch': input + '',
          'bRegex': regex === null ? false : regex,
          'bSmart': smart === null ? true : smart,
          'bCaseInsensitive': caseInsen === null ? true : caseInsen
        }), 1);
      });
    });
    _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
      return this.iterator('column', function (settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === undefined) {
          // get
          return preSearch[column].sSearch;
        }
        // set
        if (!settings.oFeatures.bFilter) {
          return;
        }
        $.extend(preSearch[column], {
          'sSearch': input + '',
          'bRegex': regex === null ? false : regex,
          'bSmart': smart === null ? true : smart,
          'bCaseInsensitive': caseInsen === null ? true : caseInsen
        });
        _fnFilterComplete(settings, settings.oPreviousSearch, 1);
      });
    });
    /*
	 * State API methods
	 */
    _api_register('state()', function () {
      return this.context.length ? this.context[0].oSavedState : null;
    });
    _api_register('state.clear()', function () {
      return this.iterator('table', function (settings) {
        // Save an empty object
        settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
      });
    });
    _api_register('state.loaded()', function () {
      return this.context.length ? this.context[0].oLoadedState : null;
    });
    _api_register('state.save()', function () {
      return this.iterator('table', function (settings) {
        _fnSaveState(settings);
      });
    });
    /**
	 * Provide a common method for plug-ins to check the version of DataTables being
	 * used, in order to ensure compatibility.
	 *
	 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	 *    Note that the formats "X" and "X.Y" are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to
	 *    the required version, or false if this version of DataTales is not
	 *    suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	 */
    DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
      var aThis = DataTable.version.split('.');
      var aThat = version.split('.');
      var iThis, iThat;
      for (var i = 0, iLen = aThat.length; i < iLen; i++) {
        iThis = parseInt(aThis[i], 10) || 0;
        iThat = parseInt(aThat[i], 10) || 0;
        // Parts are the same, keep comparing
        if (iThis === iThat) {
          continue;
        }
        // Parts are different, return immediately
        return iThis > iThat;
      }
      return true;
    };
    /**
	 * Check if a `<table>` node is a DataTable table already or not.
	 *
	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	 *      selector for the table to test. Note that if more than more than one
	 *      table is passed on, only the first will be checked
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	 *      $('#example').dataTable();
	 *    }
	 */
    DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
      var t = $(table).get(0);
      var is = false;
      $.each(DataTable.settings, function (i, o) {
        var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
        var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
        if (o.nTable === t || head === t || foot === t) {
          is = true;
        }
      });
      return is;
    };
    /**
	 * Get all DataTable tables that have been initialised - optionally you can
	 * select to get only currently visible tables.
	 *
	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	 *    or visible tables only.
	 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	 *    DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    $.each( $.fn.dataTable.tables(true), function () {
	 *      $(table).DataTable().columns.adjust();
	 *    } );
	 */
    DataTable.tables = DataTable.fnTables = function (visible) {
      return $.map(DataTable.settings, function (o) {
        if (!visible || visible && $(o.nTable).is(':visible')) {
          return o.nTable;
        }
      });
    };
    /**
	 * DataTables utility methods
	 * 
	 * This namespace provides helper methods that DataTables uses internally to
	 * create a DataTable, but which are not exclusively used only for DataTables.
	 * These methods can be used by extension authors to save the duplication of
	 * code.
	 *
	 *  @namespace
	 */
    DataTable.util = {
      throttle: _fnThrottle,
      escapeRegex: _fnEscapeRegex
    };
    /**
	 * Convert from camel case parameters to Hungarian notation. This is made public
	 * for the extensions to provide the same ability as DataTables core to accept
	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	 * parameters.
	 *
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to `true`, properties which already have a
	 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	 *    won't be.
	 */
    DataTable.camelToHungarian = _fnCamelToHungarian;
    /**
	 *
	 */
    _api_register('$()', function (selector, opts) {
      var rows = this.rows(opts).nodes(),
        // Get all rows
        jqRows = $(rows);
      return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
    });
    // jQuery functions to operate on the tables
    $.each([
      'on',
      'one',
      'off'
    ], function (i, key) {
      _api_register(key + '()', function () {
        var args = Array.prototype.slice.call(arguments);
        // Add the `dt` namespace automatically if it isn't already present
        if (!args[0].match(/\.dt\b/)) {
          args[0] += '.dt';
        }
        var inst = $(this.tables().nodes());
        inst[key].apply(inst, args);
        return this;
      });
    });
    _api_register('clear()', function () {
      return this.iterator('table', function (settings) {
        _fnClearTable(settings);
      });
    });
    _api_register('settings()', function () {
      return new _Api(this.context, this.context);
    });
    _api_register('init()', function () {
      var ctx = this.context;
      return ctx.length ? ctx[0].oInit : null;
    });
    _api_register('data()', function () {
      return this.iterator('table', function (settings) {
        return _pluck(settings.aoData, '_aData');
      }).flatten();
    });
    _api_register('destroy()', function (remove) {
      remove = remove || false;
      return this.iterator('table', function (settings) {
        var orig = settings.nTableWrapper.parentNode;
        var classes = settings.oClasses;
        var table = settings.nTable;
        var tbody = settings.nTBody;
        var thead = settings.nTHead;
        var tfoot = settings.nTFoot;
        var jqTable = $(table);
        var jqTbody = $(tbody);
        var jqWrapper = $(settings.nTableWrapper);
        var rows = $.map(settings.aoData, function (r) {
            return r.nTr;
          });
        var i, ien;
        // Flag to note that the table is currently being destroyed - no action
        // should be taken
        settings.bDestroying = true;
        // Fire off the destroy callbacks for plug-ins etc
        _fnCallbackFire(settings, 'aoDestroyCallback', 'destroy', [settings]);
        // If not being removed from the document, make all columns visible
        if (!remove) {
          new _Api(settings).columns().visible(true);
        }
        // Blitz all `DT` namespaced events (these are internal events, the
        // lowercase, `dt` events are user subscribed and they are responsible
        // for removing them
        jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
        $(window).unbind('.DT-' + settings.sInstance);
        // When scrolling we had to break the table up - restore it
        if (table != thead.parentNode) {
          jqTable.children('thead').detach();
          jqTable.append(thead);
        }
        if (tfoot && table != tfoot.parentNode) {
          jqTable.children('tfoot').detach();
          jqTable.append(tfoot);
        }
        // Remove the DataTables generated nodes, events and classes
        jqTable.detach();
        jqWrapper.detach();
        settings.aaSorting = [];
        settings.aaSortingFixed = [];
        _fnSortingClasses(settings);
        $(rows).removeClass(settings.asStripeClasses.join(' '));
        $('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone);
        if (settings.bJUI) {
          $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach();
          $('th, td', thead).each(function () {
            var wrapper = $('div.' + classes.sSortJUIWrapper, this);
            $(this).append(wrapper.contents());
            wrapper.detach();
          });
        }
        if (!remove && orig) {
          // insertBefore acts like appendChild if !arg[1]
          orig.insertBefore(table, settings.nTableReinsertBefore);
        }
        // Add the TR elements back into the table in their original order
        jqTbody.children().detach();
        jqTbody.append(rows);
        // Restore the width of the original table - was read from the style property,
        // so we can restore directly to that
        jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable);
        // If the were originally stripe classes - then we add them back here.
        // Note this is not fool proof (for example if not all rows had stripe
        // classes - but it's a good effort without getting carried away
        ien = settings.asDestroyStripes.length;
        if (ien) {
          jqTbody.children().each(function (i) {
            $(this).addClass(settings.asDestroyStripes[i % ien]);
          });
        }
        /* Remove the settings object from the settings array */
        var idx = $.inArray(settings, DataTable.settings);
        if (idx !== -1) {
          DataTable.settings.splice(idx, 1);
        }
      });
    });
    // Add the `every()` method for rows, columns and cells in a compact form
    $.each([
      'column',
      'row',
      'cell'
    ], function (i, type) {
      _api_register(type + 's().every()', function (fn) {
        return this.iterator(type, function (settings, idx, idx2) {
          // idx2 is undefined for rows and columns.
          fn.call(new _Api(settings)[type](idx, idx2));
        });
      });
    });
    // i18n method for extensions to be able to use the language object from the
    // DataTable
    _api_register('i18n()', function (token, def, plural) {
      var ctx = this.context[0];
      var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
      if (resolved === undefined) {
        resolved = def;
      }
      if (plural !== undefined && $.isPlainObject(resolved)) {
        resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
      }
      return resolved.replace('%d', plural);  // nb: plural might be undefined,
    });
    /**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	 * only for non-release builds. See http://semver.org/ for more information.
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
    DataTable.version = '1.10.7';
    /**
	 * Private data store, containing all of the settings objects that are
	 * created for the tables on a given page.
	 *
	 * Note that the `DataTable.settings` object is aliased to
	 * `jQuery.fn.dataTableExt` through which it may be accessed and
	 * manipulated, or `jQuery.fn.dataTable.settings`.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
    DataTable.settings = [];
    /**
	 * Object models container, for the various models that DataTables has
	 * available to it. These models define the objects that are used to hold
	 * the active state and configuration of the table.
	 *  @namespace
	 */
    DataTable.models = {};
    /**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
    DataTable.models.oSearch = {
      'bCaseInsensitive': true,
      'sSearch': '',
      'bRegex': false,
      'bSmart': true
    };
    /**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings
	 * aoData array.
	 *  @namespace
	 */
    DataTable.models.oRow = {
      'nTr': null,
      'anCells': null,
      '_aData': [],
      '_aSortData': null,
      '_aFilterData': null,
      '_sFilterRow': null,
      '_sRowStripe': '',
      'src': null
    };
    /**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 *
	 * Note that this object is related to {@link DataTable.defaults.column}
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
    DataTable.models.oColumn = {
      'idx': null,
      'aDataSort': null,
      'asSorting': null,
      'bSearchable': null,
      'bSortable': null,
      'bVisible': null,
      '_sManualType': null,
      '_bAttrSrc': false,
      'fnCreatedCell': null,
      'fnGetData': null,
      'fnSetData': null,
      'mData': null,
      'mRender': null,
      'nTh': null,
      'nTf': null,
      'sClass': null,
      'sContentPadding': null,
      'sDefaultContent': null,
      'sName': null,
      'sSortDataType': 'std',
      'sSortingClass': null,
      'sSortingClassJUI': null,
      'sTitle': null,
      'sType': null,
      'sWidth': null,
      'sWidthOrig': null
    };
    /*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would at around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit.
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
    /**
	 * Initialisation options that can be given to DataTables at initialisation
	 * time.
	 *  @namespace
	 */
    DataTable.defaults = {
      'aaData': null,
      'aaSorting': [[
          0,
          'asc'
        ]],
      'aaSortingFixed': [],
      'ajax': null,
      'aLengthMenu': [
        10,
        25,
        50,
        100
      ],
      'aoColumns': null,
      'aoColumnDefs': null,
      'aoSearchCols': [],
      'asStripeClasses': null,
      'bAutoWidth': true,
      'bDeferRender': false,
      'bDestroy': false,
      'bFilter': true,
      'bInfo': true,
      'bJQueryUI': false,
      'bLengthChange': true,
      'bPaginate': true,
      'bProcessing': false,
      'bRetrieve': false,
      'bScrollCollapse': false,
      'bServerSide': false,
      'bSort': true,
      'bSortMulti': true,
      'bSortCellsTop': false,
      'bSortClasses': true,
      'bStateSave': false,
      'fnCreatedRow': null,
      'fnDrawCallback': null,
      'fnFooterCallback': null,
      'fnFormatNumber': function (toFormat) {
        return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
      },
      'fnHeaderCallback': null,
      'fnInfoCallback': null,
      'fnInitComplete': null,
      'fnPreDrawCallback': null,
      'fnRowCallback': null,
      'fnServerData': null,
      'fnServerParams': null,
      'fnStateLoadCallback': function (settings) {
        try {
          return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
        } catch (e) {
        }
      },
      'fnStateLoadParams': null,
      'fnStateLoaded': null,
      'fnStateSaveCallback': function (settings, data) {
        try {
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
        } catch (e) {
        }
      },
      'fnStateSaveParams': null,
      'iStateDuration': 7200,
      'iDeferLoading': null,
      'iDisplayLength': 10,
      'iDisplayStart': 0,
      'iTabIndex': 0,
      'oClasses': {},
      'oLanguage': {
        'oAria': {
          'sSortAscending': ': activate to sort column ascending',
          'sSortDescending': ': activate to sort column descending'
        },
        'oPaginate': {
          'sFirst': 'First',
          'sLast': 'Last',
          'sNext': 'Next',
          'sPrevious': 'Previous'
        },
        'sEmptyTable': 'No data available in table',
        'sInfo': 'Showing _START_ to _END_ of _TOTAL_ entries',
        'sInfoEmpty': 'Showing 0 to 0 of 0 entries',
        'sInfoFiltered': '(filtered from _MAX_ total entries)',
        'sInfoPostFix': '',
        'sDecimal': '',
        'sThousands': ',',
        'sLengthMenu': 'Show _MENU_ entries',
        'sLoadingRecords': 'Loading...',
        'sProcessing': 'Processing...',
        'sSearch': 'Search:',
        'sSearchPlaceholder': '',
        'sUrl': '',
        'sZeroRecords': 'No matching records found'
      },
      'oSearch': $.extend({}, DataTable.models.oSearch),
      'sAjaxDataProp': 'data',
      'sAjaxSource': null,
      'sDom': 'lfrtip',
      'searchDelay': null,
      'sPaginationType': 'simple_numbers',
      'sScrollX': '',
      'sScrollXInner': '',
      'sScrollY': '',
      'sServerMethod': 'GET',
      'renderer': null
    };
    _fnHungarianMap(DataTable.defaults);
    /*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
    /**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
    DataTable.defaults.column = {
      'aDataSort': null,
      'iDataSort': -1,
      'asSorting': [
        'asc',
        'desc'
      ],
      'bSearchable': true,
      'bSortable': true,
      'bVisible': true,
      'fnCreatedCell': null,
      'mData': null,
      'mRender': null,
      'sCellType': 'td',
      'sClass': '',
      'sContentPadding': '',
      'sDefaultContent': null,
      'sName': '',
      'sSortDataType': 'std',
      'sTitle': null,
      'sType': null,
      'sWidth': null
    };
    _fnHungarianMap(DataTable.defaults.column);
    /**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 *
	 * Note that this object is related to {@link DataTable.defaults} but this
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
    DataTable.models.oSettings = {
      'oFeatures': {
        'bAutoWidth': null,
        'bDeferRender': null,
        'bFilter': null,
        'bInfo': null,
        'bLengthChange': null,
        'bPaginate': null,
        'bProcessing': null,
        'bServerSide': null,
        'bSort': null,
        'bSortMulti': null,
        'bSortClasses': null,
        'bStateSave': null
      },
      'oScroll': {
        'bCollapse': null,
        'iBarWidth': 0,
        'sX': null,
        'sXInner': null,
        'sY': null
      },
      'oLanguage': { 'fnInfoCallback': null },
      'oBrowser': {
        'bScrollOversize': false,
        'bScrollbarLeft': false
      },
      'ajax': null,
      'aanFeatures': [],
      'aoData': [],
      'aiDisplay': [],
      'aiDisplayMaster': [],
      'aoColumns': [],
      'aoHeader': [],
      'aoFooter': [],
      'oPreviousSearch': {},
      'aoPreSearchCols': [],
      'aaSorting': null,
      'aaSortingFixed': [],
      'asStripeClasses': null,
      'asDestroyStripes': [],
      'sDestroyWidth': 0,
      'aoRowCallback': [],
      'aoHeaderCallback': [],
      'aoFooterCallback': [],
      'aoDrawCallback': [],
      'aoRowCreatedCallback': [],
      'aoPreDrawCallback': [],
      'aoInitComplete': [],
      'aoStateSaveParams': [],
      'aoStateLoadParams': [],
      'aoStateLoaded': [],
      'sTableId': '',
      'nTable': null,
      'nTHead': null,
      'nTFoot': null,
      'nTBody': null,
      'nTableWrapper': null,
      'bDeferLoading': false,
      'bInitialised': false,
      'aoOpenRows': [],
      'sDom': null,
      'searchDelay': null,
      'sPaginationType': 'two_button',
      'iStateDuration': 0,
      'aoStateSave': [],
      'aoStateLoad': [],
      'oSavedState': null,
      'oLoadedState': null,
      'sAjaxSource': null,
      'sAjaxDataProp': null,
      'bAjaxDataGet': true,
      'jqXHR': null,
      'json': undefined,
      'oAjaxData': undefined,
      'fnServerData': null,
      'aoServerParams': [],
      'sServerMethod': null,
      'fnFormatNumber': null,
      'aLengthMenu': null,
      'iDraw': 0,
      'bDrawing': false,
      'iDrawError': -1,
      '_iDisplayLength': 10,
      '_iDisplayStart': 0,
      '_iRecordsTotal': 0,
      '_iRecordsDisplay': 0,
      'bJUI': null,
      'oClasses': {},
      'bFiltered': false,
      'bSorted': false,
      'bSortCellsTop': null,
      'oInit': null,
      'aoDestroyCallback': [],
      'fnRecordsTotal': function () {
        return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
      },
      'fnRecordsDisplay': function () {
        return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
      },
      'fnDisplayEnd': function () {
        var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
        if (features.bServerSide) {
          return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
        } else {
          return !paginate || calc > records || len === -1 ? records : calc;
        }
      },
      'oInstance': null,
      'sInstance': null,
      'iTabIndex': 0,
      'nScrollHead': null,
      'nScrollFoot': null,
      'aLastSort': [],
      'oPlugins': {}
    };
    /**
	 * Extension object for DataTables that is used to provide all extension
	 * options.
	 *
	 * Note that the `DataTable.ext` object is available through
	 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
    /**
	 * DataTables extensions
	 * 
	 * This namespace acts as a collection area for plug-ins that can be used to
	 * extend DataTables capabilities. Indeed many of the build in methods
	 * use this method to provide their own capabilities (sorting methods for
	 * example).
	 *
	 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	 * reasons
	 *
	 *  @namespace
	 */
    DataTable.ext = _ext = {
      buttons: {},
      classes: {},
      errMode: 'alert',
      feature: [],
      search: [],
      selector: {
        cell: [],
        column: [],
        row: []
      },
      internal: {},
      legacy: { ajax: null },
      pager: {},
      renderer: {
        pageButton: {},
        header: {}
      },
      order: {},
      type: {
        detect: [],
        search: {},
        order: {}
      },
      _unique: 0,
      fnVersionCheck: DataTable.fnVersionCheck,
      iApiIndex: 0,
      oJUIClasses: {},
      sVersion: DataTable.version
    };
    //
    // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
    //
    $.extend(_ext, {
      afnFiltering: _ext.search,
      aTypes: _ext.type.detect,
      ofnSearch: _ext.type.search,
      oSort: _ext.type.order,
      afnSortData: _ext.order,
      aoFeatures: _ext.feature,
      oApi: _ext.internal,
      oStdClasses: _ext.classes,
      oPagination: _ext.pager
    });
    $.extend(DataTable.ext.classes, {
      'sTable': 'dataTable',
      'sNoFooter': 'no-footer',
      'sPageButton': 'paginate_button',
      'sPageButtonActive': 'current',
      'sPageButtonDisabled': 'disabled',
      'sStripeOdd': 'odd',
      'sStripeEven': 'even',
      'sRowEmpty': 'dataTables_empty',
      'sWrapper': 'dataTables_wrapper',
      'sFilter': 'dataTables_filter',
      'sInfo': 'dataTables_info',
      'sPaging': 'dataTables_paginate paging_',
      'sLength': 'dataTables_length',
      'sProcessing': 'dataTables_processing',
      'sSortAsc': 'sorting_asc',
      'sSortDesc': 'sorting_desc',
      'sSortable': 'sorting',
      'sSortableAsc': 'sorting_asc_disabled',
      'sSortableDesc': 'sorting_desc_disabled',
      'sSortableNone': 'sorting_disabled',
      'sSortColumn': 'sorting_',
      'sFilterInput': '',
      'sLengthSelect': '',
      'sScrollWrapper': 'dataTables_scroll',
      'sScrollHead': 'dataTables_scrollHead',
      'sScrollHeadInner': 'dataTables_scrollHeadInner',
      'sScrollBody': 'dataTables_scrollBody',
      'sScrollFoot': 'dataTables_scrollFoot',
      'sScrollFootInner': 'dataTables_scrollFootInner',
      'sHeaderTH': '',
      'sFooterTH': '',
      'sSortJUIAsc': '',
      'sSortJUIDesc': '',
      'sSortJUI': '',
      'sSortJUIAscAllowed': '',
      'sSortJUIDescAllowed': '',
      'sSortJUIWrapper': '',
      'sSortIcon': '',
      'sJUIHeader': '',
      'sJUIFooter': ''
    });
    (function () {
      // Reused strings for better compression. Closure compiler appears to have a
      // weird edge case where it is trying to expand strings rather than use the
      // variable version. This results in about 200 bytes being added, for very
      // little preference benefit since it this run on script load only.
      var _empty = '';
      _empty = '';
      var _stateDefault = _empty + 'ui-state-default';
      var _sortIcon = _empty + 'css_right ui-icon ui-icon-';
      var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';
      $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {
        'sPageButton': 'fg-button ui-button ' + _stateDefault,
        'sPageButtonActive': 'ui-state-disabled',
        'sPageButtonDisabled': 'ui-state-disabled',
        'sPaging': 'dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ' + 'ui-buttonset-multi paging_',
        'sSortAsc': _stateDefault + ' sorting_asc',
        'sSortDesc': _stateDefault + ' sorting_desc',
        'sSortable': _stateDefault + ' sorting',
        'sSortableAsc': _stateDefault + ' sorting_asc_disabled',
        'sSortableDesc': _stateDefault + ' sorting_desc_disabled',
        'sSortableNone': _stateDefault + ' sorting_disabled',
        'sSortJUIAsc': _sortIcon + 'triangle-1-n',
        'sSortJUIDesc': _sortIcon + 'triangle-1-s',
        'sSortJUI': _sortIcon + 'carat-2-n-s',
        'sSortJUIAscAllowed': _sortIcon + 'carat-1-n',
        'sSortJUIDescAllowed': _sortIcon + 'carat-1-s',
        'sSortJUIWrapper': 'DataTables_sort_wrapper',
        'sSortIcon': 'DataTables_sort_icon',
        'sScrollHead': 'dataTables_scrollHead ' + _stateDefault,
        'sScrollFoot': 'dataTables_scrollFoot ' + _stateDefault,
        'sHeaderTH': _stateDefault,
        'sFooterTH': _stateDefault,
        'sJUIHeader': _headerFooter + ' ui-corner-tl ui-corner-tr',
        'sJUIFooter': _headerFooter + ' ui-corner-bl ui-corner-br'
      });
    }());
    var extPagination = DataTable.ext.pager;
    function _numbers(page, pages) {
      var numbers = [], buttons = extPagination.numbers_length, half = Math.floor(buttons / 2), i = 1;
      if (pages <= buttons) {
        numbers = _range(0, pages);
      } else if (page <= half) {
        numbers = _range(0, buttons - 2);
        numbers.push('ellipsis');
        numbers.push(pages - 1);
      } else if (page >= pages - 1 - half) {
        numbers = _range(pages - (buttons - 2), pages);
        numbers.splice(0, 0, 'ellipsis');
        // no unshift in ie6
        numbers.splice(0, 0, 0);
      } else {
        numbers = _range(page - half + 2, page + half - 1);
        numbers.push('ellipsis');
        numbers.push(pages - 1);
        numbers.splice(0, 0, 'ellipsis');
        numbers.splice(0, 0, 0);
      }
      numbers.DT_el = 'span';
      return numbers;
    }
    $.extend(extPagination, {
      simple: function (page, pages) {
        return [
          'previous',
          'next'
        ];
      },
      full: function (page, pages) {
        return [
          'first',
          'previous',
          'next',
          'last'
        ];
      },
      simple_numbers: function (page, pages) {
        return [
          'previous',
          _numbers(page, pages),
          'next'
        ];
      },
      full_numbers: function (page, pages) {
        return [
          'first',
          'previous',
          _numbers(page, pages),
          'next',
          'last'
        ];
      },
      _numbers: _numbers,
      numbers_length: 7
    });
    $.extend(true, DataTable.ext.renderer, {
      pageButton: {
        _: function (settings, host, idx, buttons, page, pages) {
          var classes = settings.oClasses;
          var lang = settings.oLanguage.oPaginate;
          var btnDisplay, btnClass, counter = 0;
          var attach = function (container, buttons) {
            var i, ien, node, button;
            var clickHandler = function (e) {
              _fnPageChange(settings, e.data.action, true);
            };
            for (i = 0, ien = buttons.length; i < ien; i++) {
              button = buttons[i];
              if ($.isArray(button)) {
                var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
                attach(inner, button);
              } else {
                btnDisplay = '';
                btnClass = '';
                switch (button) {
                case 'ellipsis':
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;
                case 'first':
                  btnDisplay = lang.sFirst;
                  btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;
                case 'previous':
                  btnDisplay = lang.sPrevious;
                  btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;
                case 'next':
                  btnDisplay = lang.sNext;
                  btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;
                case 'last':
                  btnDisplay = lang.sLast;
                  btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;
                default:
                  btnDisplay = button + 1;
                  btnClass = page === button ? classes.sPageButtonActive : '';
                  break;
                }
                if (btnDisplay) {
                  node = $('<a>', {
                    'class': classes.sPageButton + ' ' + btnClass,
                    'aria-controls': settings.sTableId,
                    'data-dt-idx': counter,
                    'tabindex': settings.iTabIndex,
                    'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                  }).html(btnDisplay).appendTo(container);
                  _fnBindAction(node, { action: button }, clickHandler);
                  counter++;
                }
              }
            }
          };
          // IE9 throws an 'unknown error' if document.activeElement is used
          // inside an iframe or frame. Try / catch the error. Not good for
          // accessibility, but neither are frames.
          var activeEl;
          try {
            // Because this approach is destroying and recreating the paging
            // elements, focus is lost on the select button which is bad for
            // accessibility. So we want to restore focus once the draw has
            // completed
            activeEl = $(document.activeElement).data('dt-idx');
          } catch (e) {
          }
          attach($(host).empty(), buttons);
          if (activeEl) {
            $(host).find('[data-dt-idx=' + activeEl + ']').focus();
          }
        }
      }
    });
    // Built in type detection. See model.ext.aTypes for information about
    // what is required from this methods.
    $.extend(DataTable.ext.type.detect, [
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal) ? 'num' + decimal : null;
      },
      function (d, settings) {
        // V8 will remove any unknown characters at the start and end of the
        // expression, leading to false matches such as `$245.12` or `10%` being
        // a valid date. See forum thread 18941 for detail.
        if (d && !(d instanceof Date) && (!_re_date_start.test(d) || !_re_date_end.test(d))) {
          return null;
        }
        var parsed = Date.parse(d);
        return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
      },
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
      },
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
      },
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
      },
      function (d, settings) {
        return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
      }
    ]);
    // Filter formatting functions. See model.ext.ofnSearch for information about
    // what is required from these methods.
    // 
    // Note that additional search methods are added for the html numbers and
    // html formatted numbers by `_addNumericSort()` when we know what the decimal
    // place is
    $.extend(DataTable.ext.type.search, {
      html: function (data) {
        return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, ' ').replace(_re_html, '') : '';
      },
      string: function (data) {
        return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, ' ') : data;
      }
    });
    var __numericReplace = function (d, decimalPlace, re1, re2) {
      if (d !== 0 && (!d || d === '-')) {
        return -Infinity;
      }
      // If a decimal place other than `.` is used, it needs to be given to the
      // function so we can detect it and replace with a `.` which is the only
      // decimal place Javascript recognises - it is not locale aware.
      if (decimalPlace) {
        d = _numToDecimal(d, decimalPlace);
      }
      if (d.replace) {
        if (re1) {
          d = d.replace(re1, '');
        }
        if (re2) {
          d = d.replace(re2, '');
        }
      }
      return d * 1;
    };
    // Add the numeric 'deformatting' functions for sorting and search. This is done
    // in a function to provide an easy ability for the language options to add
    // additional methods if a non-period decimal place is used.
    function _addNumericSort(decimalPlace) {
      $.each({
        'num': function (d) {
          return __numericReplace(d, decimalPlace);
        },
        'num-fmt': function (d) {
          return __numericReplace(d, decimalPlace, _re_formatted_numeric);
        },
        'html-num': function (d) {
          return __numericReplace(d, decimalPlace, _re_html);
        },
        'html-num-fmt': function (d) {
          return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
        }
      }, function (key, fn) {
        // Add the ordering method
        _ext.type.order[key + decimalPlace + '-pre'] = fn;
        // For HTML types add a search formatter that will strip the HTML
        if (key.match(/^html\-/)) {
          _ext.type.search[key + decimalPlace] = _ext.type.search.html;
        }
      });
    }
    // Default sort methods
    $.extend(_ext.type.order, {
      'date-pre': function (d) {
        return Date.parse(d) || 0;
      },
      'html-pre': function (a) {
        return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, '').toLowerCase() : a + '';
      },
      'string-pre': function (a) {
        // This is a little complex, but faster than always calling toString,
        // http://jsperf.com/tostring-v-check
        return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
      },
      'string-asc': function (x, y) {
        return x < y ? -1 : x > y ? 1 : 0;
      },
      'string-desc': function (x, y) {
        return x < y ? 1 : x > y ? -1 : 0;
      }
    });
    // Numeric sorting types - order doesn't matter here
    _addNumericSort('');
    $.extend(true, DataTable.ext.renderer, {
      header: {
        _: function (settings, cell, column, classes) {
          // No additional mark-up required
          // Attach a sort listener to update on sort - note that using the
          // `DT` namespace will allow the event to be removed automatically
          // on destroy, while the `dt` namespaced event is the one we are
          // listening for
          $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
            if (settings !== ctx) {
              // need to check this this is the host
              return;  // table, not a nested one
            }
            var colIdx = column.idx;
            cell.removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
          });
        },
        jqueryui: function (settings, cell, column, classes) {
          $('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell);
          // Attach a sort listener to update on sort
          $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
            if (settings !== ctx) {
              return;
            }
            var colIdx = column.idx;
            cell.removeClass(classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
            cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + ' ' + classes.sSortJUIDesc + ' ' + classes.sSortJUI + ' ' + classes.sSortJUIAscAllowed + ' ' + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
          });
        }
      }
    });
    /*
	 * Public helper functions. These aren't used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
    /**
	 * Helpers for `columns.render`.
	 *
	 * The options defined here can be used with the `columns.render` initialisation
	 * option to provide a display renderer. The following functions are defined:
	 *
	 * * `number` - Will format numeric data (defined by `columns.data`) for
	 *   display, retaining the original unformatted data for sorting and filtering.
	 *   It takes 4 parameters:
	 *   * `string` - Thousands grouping separator
	 *   * `string` - Decimal point indicator
	 *   * `integer` - Number of decimal points to show
	 *   * `string` (optional) - Prefix.
	 *
	 * @example
	 *   // Column definition using the number renderer
	 *   {
	 *     data: "salary",
	 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	 *   }
	 *
	 * @namespace
	 */
    DataTable.render = {
      number: function (thousands, decimal, precision, prefix) {
        return {
          display: function (d) {
            if (typeof d !== 'number' && typeof d !== 'string') {
              return d;
            }
            var negative = d < 0 ? '-' : '';
            d = Math.abs(parseFloat(d));
            var intPart = parseInt(d, 10);
            var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';
            return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart;
          }
        };
      }
    };
    /*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
    /**
	 * Create a wrapper function for exporting an internal functions to an external API.
	 *  @param {string} fn API function name
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#internal
	 */
    function _fnExternApiFunc(fn) {
      return function () {
        var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
        return DataTable.ext.internal[fn].apply(this, args);
      };
    }
    /**
	 * Reference to internal functions for use by plug-in developers. Note that
	 * these methods are references to internal functions and are considered to be
	 * private. If you use these methods, be aware that they are liable to change
	 * between versions.
	 *  @namespace
	 */
    $.extend(DataTable.ext.internal, {
      _fnExternApiFunc: _fnExternApiFunc,
      _fnBuildAjax: _fnBuildAjax,
      _fnAjaxUpdate: _fnAjaxUpdate,
      _fnAjaxParameters: _fnAjaxParameters,
      _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
      _fnAjaxDataSrc: _fnAjaxDataSrc,
      _fnAddColumn: _fnAddColumn,
      _fnColumnOptions: _fnColumnOptions,
      _fnAdjustColumnSizing: _fnAdjustColumnSizing,
      _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
      _fnColumnIndexToVisible: _fnColumnIndexToVisible,
      _fnVisbleColumns: _fnVisbleColumns,
      _fnGetColumns: _fnGetColumns,
      _fnColumnTypes: _fnColumnTypes,
      _fnApplyColumnDefs: _fnApplyColumnDefs,
      _fnHungarianMap: _fnHungarianMap,
      _fnCamelToHungarian: _fnCamelToHungarian,
      _fnLanguageCompat: _fnLanguageCompat,
      _fnBrowserDetect: _fnBrowserDetect,
      _fnAddData: _fnAddData,
      _fnAddTr: _fnAddTr,
      _fnNodeToDataIndex: _fnNodeToDataIndex,
      _fnNodeToColumnIndex: _fnNodeToColumnIndex,
      _fnGetCellData: _fnGetCellData,
      _fnSetCellData: _fnSetCellData,
      _fnSplitObjNotation: _fnSplitObjNotation,
      _fnGetObjectDataFn: _fnGetObjectDataFn,
      _fnSetObjectDataFn: _fnSetObjectDataFn,
      _fnGetDataMaster: _fnGetDataMaster,
      _fnClearTable: _fnClearTable,
      _fnDeleteIndex: _fnDeleteIndex,
      _fnInvalidate: _fnInvalidate,
      _fnGetRowElements: _fnGetRowElements,
      _fnCreateTr: _fnCreateTr,
      _fnBuildHead: _fnBuildHead,
      _fnDrawHead: _fnDrawHead,
      _fnDraw: _fnDraw,
      _fnReDraw: _fnReDraw,
      _fnAddOptionsHtml: _fnAddOptionsHtml,
      _fnDetectHeader: _fnDetectHeader,
      _fnGetUniqueThs: _fnGetUniqueThs,
      _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
      _fnFilterComplete: _fnFilterComplete,
      _fnFilterCustom: _fnFilterCustom,
      _fnFilterColumn: _fnFilterColumn,
      _fnFilter: _fnFilter,
      _fnFilterCreateSearch: _fnFilterCreateSearch,
      _fnEscapeRegex: _fnEscapeRegex,
      _fnFilterData: _fnFilterData,
      _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
      _fnUpdateInfo: _fnUpdateInfo,
      _fnInfoMacros: _fnInfoMacros,
      _fnInitialise: _fnInitialise,
      _fnInitComplete: _fnInitComplete,
      _fnLengthChange: _fnLengthChange,
      _fnFeatureHtmlLength: _fnFeatureHtmlLength,
      _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
      _fnPageChange: _fnPageChange,
      _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
      _fnProcessingDisplay: _fnProcessingDisplay,
      _fnFeatureHtmlTable: _fnFeatureHtmlTable,
      _fnScrollDraw: _fnScrollDraw,
      _fnApplyToChildren: _fnApplyToChildren,
      _fnCalculateColumnWidths: _fnCalculateColumnWidths,
      _fnThrottle: _fnThrottle,
      _fnConvertToWidth: _fnConvertToWidth,
      _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
      _fnGetWidestNode: _fnGetWidestNode,
      _fnGetMaxLenString: _fnGetMaxLenString,
      _fnStringToCss: _fnStringToCss,
      _fnScrollBarWidth: _fnScrollBarWidth,
      _fnSortFlatten: _fnSortFlatten,
      _fnSort: _fnSort,
      _fnSortAria: _fnSortAria,
      _fnSortListener: _fnSortListener,
      _fnSortAttachListener: _fnSortAttachListener,
      _fnSortingClasses: _fnSortingClasses,
      _fnSortData: _fnSortData,
      _fnSaveState: _fnSaveState,
      _fnLoadState: _fnLoadState,
      _fnSettingsFromNode: _fnSettingsFromNode,
      _fnLog: _fnLog,
      _fnMap: _fnMap,
      _fnBindAction: _fnBindAction,
      _fnCallbackReg: _fnCallbackReg,
      _fnCallbackFire: _fnCallbackFire,
      _fnLengthOverflow: _fnLengthOverflow,
      _fnRenderer: _fnRenderer,
      _fnDataSource: _fnDataSource,
      _fnRowAttributes: _fnRowAttributes,
      _fnCalculateEnd: function () {
      }  // Used by a lot of plug-ins, but redundant
         // in 1.10, so this dead-end function is
         // added to prevent errors
    });
    // jQuery access
    $.fn.dataTable = DataTable;
    // Legacy aliases
    $.fn.dataTableSettings = DataTable.settings;
    $.fn.dataTableExt = DataTable.ext;
    // With a capital `D` we return a DataTables API instance rather than a
    // jQuery object
    $.fn.DataTable = function (opts) {
      return $(this).dataTable(opts).api();
    };
    // All properties that are available to $.fn.dataTable should also be
    // available on $.fn.DataTable
    $.each(DataTable, function (prop, val) {
      $.fn.DataTable[prop] = val;
    });
    // Information about events fired by DataTables - for documentation.
    /**
	 * Draw event, fired whenever the table is redrawn on the page, at the same
	 * point as fnDrawCallback. This may be useful for binding events or
	 * performing calculations when the table is altered at all.
	 *  @name DataTable#draw.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
    /**
	 * Search event, fired when the searching applied to the table (using the
	 * built-in global search, or column filters) is altered.
	 *  @name DataTable#search.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
    /**
	 * Page change event, fired when the paging of the table is altered.
	 *  @name DataTable#page.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
    /**
	 * Order event, fired when the ordering applied to the table is altered.
	 *  @name DataTable#order.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
    /**
	 * DataTables initialisation complete event, fired when the table is fully
	 * drawn, including Ajax data loaded, if Ajax data is required.
	 *  @name DataTable#init.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The JSON object request from the server - only
	 *    present if client-side Ajax sourced data is used</li></ol>
	 */
    /**
	 * State save event, fired when the table has changed state a new state save
	 * is required. This event allows modification of the state saving object
	 * prior to actually doing the save, including addition or other state
	 * properties (for plug-ins) or modification of a DataTables core property.
	 *  @name DataTable#stateSaveParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The state information to be saved
	 */
    /**
	 * State load event, fired when the table is loading state from the stored
	 * data, but prior to the settings object being modified by the saved state
	 * - allowing modification of the saved state is required or loading of
	 * state for a plug-in.
	 *  @name DataTable#stateLoadParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */
    /**
	 * State loaded event, fired when state has been loaded from stored data and
	 * the settings object has been modified by the loaded data.
	 *  @name DataTable#stateLoaded.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */
    /**
	 * Processing event, fired when DataTables is doing some kind of processing
	 * (be it, order, searcg or anything else). It can be used to indicate to
	 * the end user that there is something happening, or that something has
	 * finished.
	 *  @name DataTable#processing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	 */
    /**
	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
	 * request to made to the server for new data. This event is called before
	 * DataTables processed the returned data, so it can also be used to pre-
	 * process the data returned from the server, if needed.
	 *
	 * Note that this trigger is called in `fnServerData`, if you override
	 * `fnServerData` and which to use this event, you need to trigger it in you
	 * success function.
	 *  @name DataTable#xhr.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {object} json JSON returned from the server
	 *
	 *  @example
	 *     // Use a custom property returned from the server in another DOM element
	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	 *       $('#status').html( json.status );
	 *     } );
	 *
	 *  @example
	 *     // Pre-process the data returned from the server
	 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
	 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
	 *       }
	 *       // Note no return - manipulate the data directly in the JSON object.
	 *     } );
	 */
    /**
	 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
	 * or passing the bDestroy:true parameter in the initialisation object. This
	 * can be used to remove bound events, added DOM nodes, etc.
	 *  @name DataTable#destroy.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
    /**
	 * Page length change event, fired when number of records to show on each
	 * page (the length) is changed.
	 *  @name DataTable#length.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {integer} len New length
	 */
    /**
	 * Column sizing has changed.
	 *  @name DataTable#column-sizing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
    /**
	 * Column visibility has changed.
	 *  @name DataTable#column-visibility.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {int} column Column index
	 *  @param {bool} vis `false` if column now hidden, or `true` if visible
	 */
    return $.fn.dataTable;
  }));
}(window, document));/*! DataTables Bootstrap 3 integration
 * ©2011-2014 SpryMedia Ltd - datatables.net/license
 */
/**
 * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and
 * DataTables 1.10 or newer.
 *
 * This file sets the defaults and adds options to DataTables to style its
 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
 * for further information.
 */
(function (window, document, undefined) {
  var factory = function ($, DataTable) {
    'use strict';
    /* Set the defaults for DataTables initialisation */
    $.extend(true, DataTable.defaults, {
      dom: '<\'row\'<\'col-sm-6\'l><\'col-sm-6\'f>>' + '<\'row\'<\'col-sm-12\'tr>>' + '<\'row\'<\'col-sm-6\'i><\'col-sm-6\'p>>',
      renderer: 'bootstrap'
    });
    /* Default class modification */
    $.extend(DataTable.ext.classes, {
      sWrapper: 'dataTables_wrapper form-inline dt-bootstrap',
      sFilterInput: 'form-control input-sm',
      sLengthSelect: 'form-control input-sm'
    });
    /* Bootstrap paging button renderer */
    DataTable.ext.renderer.pageButton.bootstrap = function (settings, host, idx, buttons, page, pages) {
      var api = new DataTable.Api(settings);
      var classes = settings.oClasses;
      var lang = settings.oLanguage.oPaginate;
      var btnDisplay, btnClass;
      var attach = function (container, buttons) {
        var i, ien, node, button;
        var clickHandler = function (e) {
          e.preventDefault();
          if (!$(e.currentTarget).hasClass('disabled')) {
            api.page(e.data.action).draw(false);
          }
        };
        for (i = 0, ien = buttons.length; i < ien; i++) {
          button = buttons[i];
          if ($.isArray(button)) {
            attach(container, button);
          } else {
            btnDisplay = '';
            btnClass = '';
            switch (button) {
            case 'ellipsis':
              btnDisplay = '&hellip;';
              btnClass = 'disabled';
              break;
            case 'first':
              btnDisplay = lang.sFirst;
              btnClass = button + (page > 0 ? '' : ' disabled');
              break;
            case 'previous':
              btnDisplay = lang.sPrevious;
              btnClass = button + (page > 0 ? '' : ' disabled');
              break;
            case 'next':
              btnDisplay = lang.sNext;
              btnClass = button + (page < pages - 1 ? '' : ' disabled');
              break;
            case 'last':
              btnDisplay = lang.sLast;
              btnClass = button + (page < pages - 1 ? '' : ' disabled');
              break;
            default:
              btnDisplay = button + 1;
              btnClass = page === button ? 'active' : '';
              break;
            }
            if (btnDisplay) {
              node = $('<li>', {
                'class': classes.sPageButton + ' ' + btnClass,
                'aria-controls': settings.sTableId,
                'tabindex': settings.iTabIndex,
                'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
              }).append($('<a>', { 'href': '#' }).html(btnDisplay)).appendTo(container);
              settings.oApi._fnBindAction(node, { action: button }, clickHandler);
            }
          }
        }
      };
      attach($(host).empty().html('<ul class="pagination"/>').children('ul'), buttons);
    };
    /*
         * TableTools Bootstrap compatibility
         * Required TableTools 2.1+
         */
    if (DataTable.TableTools) {
      // Set the classes that TableTools uses to something suitable for Bootstrap
      $.extend(true, DataTable.TableTools.classes, {
        'container': 'DTTT btn-group',
        'buttons': {
          'normal': 'btn btn-default',
          'disabled': 'disabled'
        },
        'collection': {
          'container': 'DTTT_dropdown dropdown-menu',
          'buttons': {
            'normal': '',
            'disabled': 'disabled'
          }
        },
        'print': { 'info': 'DTTT_print_info' },
        'select': { 'row': 'active' }
      });
      // Have the collection use a bootstrap compatible drop down
      $.extend(true, DataTable.TableTools.DEFAULTS.oTags, {
        'collection': {
          'container': 'ul',
          'button': 'li',
          'liner': 'a'
        }
      });
    }
  };
  // /factory
  // Define as an AMD module if possible
  if (typeof define === 'function' && define.amd) {
    define([
      'jquery',
      'datatables'
    ], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS
    factory(require('jquery'), require('datatables'));
  } else if (jQuery) {
    // Otherwise simply initialise as normal, stopping multiple evaluation
    factory(jQuery, jQuery.fn.dataTable);
  }
}(window, document));//! moment.js
//! version : 2.10.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
}(this, function () {
  'use strict';
  var hookCallback;
  function utils_hooks__hooks() {
    return hookCallback.apply(null, arguments);
  }
  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return Object.prototype.toString.call(input) === '[object Array]';
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }
  function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function create_utc__createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  function valid__isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
      if (m._strict) {
        m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }
    }
    return m._isValid;
  }
  function valid__createInvalid(flags) {
    var m = create_utc__createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }
  var momentProperties = utils_hooks__hooks.momentProperties = [];
  function copyConfig(to, from) {
    var i, prop, val;
    if (typeof from._isAMomentObject !== 'undefined') {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (typeof from._i !== 'undefined') {
      to._i = from._i;
    }
    if (typeof from._f !== 'undefined') {
      to._f = from._f;
    }
    if (typeof from._l !== 'undefined') {
      to._l = from._l;
    }
    if (typeof from._strict !== 'undefined') {
      to._strict = from._strict;
    }
    if (typeof from._tzm !== 'undefined') {
      to._tzm = from._tzm;
    }
    if (typeof from._isUTC !== 'undefined') {
      to._isUTC = from._isUTC;
    }
    if (typeof from._offset !== 'undefined') {
      to._offset = from._offset;
    }
    if (typeof from._pf !== 'undefined') {
      to._pf = getParsingFlags(from);
    }
    if (typeof from._locale !== 'undefined') {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i in momentProperties) {
        prop = momentProperties[i];
        val = from[prop];
        if (typeof val !== 'undefined') {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  var updateInProgress = false;
  // Moment prototype object
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(+config._d);
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
      updateInProgress = true;
      utils_hooks__hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion, value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      if (coercedNumber >= 0) {
        value = Math.floor(coercedNumber);
      } else {
        value = Math.ceil(coercedNumber);
      }
    }
    return value;
  }
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function Locale() {
  }
  var locales = {};
  var globalLocale;
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }
  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function chooseLocale(names) {
    var i = 0, j, next, locale, split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
          //the next array item is better than a shallower substring of this one
          break;
        }
        j--;
      }
      i++;
    }
    return null;
  }
  function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        require('./locale/' + name);
        // because defineLocale currently also sets the global locale, we
        // want to undo that for lazy loaded locales
        locale_locales__getSetGlobalLocale(oldLocale);
      } catch (e) {
      }
    }
    return locales[name];
  }
  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function locale_locales__getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (typeof values === 'undefined') {
        data = locale_locales__getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, values) {
    if (values !== null) {
      values.abbr = name;
      if (!locales[name]) {
        locales[name] = new Locale();
      }
      locales[name].set(values);
      // backwards compat for now: also set the locale
      locale_locales__getSetGlobalLocale(name);
      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }
  // returns locale data
  function locale_locales__getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {}, normalizedProp, prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        get_set__set(this, unit, value);
        utils_hooks__hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get_set__get(this, unit);
      }
    };
  }
  function get_set__get(mom, unit) {
    return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
  }
  function get_set__set(mom, unit, value) {
    return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
  }
  // MOMENTS
  function getSet(units, value) {
    var unit;
    if (typeof units === 'object') {
      for (unit in units) {
        this.set(unit, units[unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (typeof this[units] === 'function') {
        return this[units](value);
      }
    }
    return this;
  }
  function zeroFill(number, targetLength, forceSign) {
    var output = '' + Math.abs(number), sign = number >= 0;
    while (output.length < targetLength) {
      output = '0' + output;
    }
    return (sign ? forceSign ? '+' : '' : '-') + output;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};
  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
      func = function () {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function (mom) {
      var output = '';
      for (i = 0; i < length; i++) {
        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }
  // format date using native date object
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    if (!formatFunctions[format]) {
      formatFunctions[format] = makeFormatFunction(format);
    }
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var match1 = /\d/;
  //       0 - 9
  var match2 = /\d\d/;
  //      00 - 99
  var match3 = /\d{3}/;
  //     000 - 999
  var match4 = /\d{4}/;
  //    0000 - 9999
  var match6 = /[+-]?\d{6}/;
  // -999999 - 999999
  var match1to2 = /\d\d?/;
  //       0 - 99
  var match1to3 = /\d{1,3}/;
  //       0 - 999
  var match1to4 = /\d{1,4}/;
  //       0 - 9999
  var match1to6 = /[+-]?\d{1,6}/;
  // -999999 - 999999
  var matchUnsigned = /\d+/;
  //       0 - inf
  var matchSigned = /[+-]?\d+/;
  //    -inf - inf
  var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
  // +00:00 -00:00 +0000 -0000 or Z
  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
  // 123456789 123456789.123
  // any word (or two) characters or numbers including two/three word month in arabic.
  var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = typeof regex === 'function' ? regex : function (isStrict) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }
  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function unescapeFormat(s) {
    return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
      token = [token];
    }
    if (typeof callback === 'number') {
      func = function (input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
  }
  // FORMATTING
  addFormatToken('M', [
    'MM',
    2
  ], 'Mo', function () {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
  });
  // ALIASES
  addUnitAlias('month', 'M');
  // PARSING
  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', matchWord);
  addRegexToken('MMMM', matchWord);
  addParseToken([
    'M',
    'MM'
  ], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken([
    'MMM',
    'MMMM'
  ], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });
  // LOCALES
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
  function localeMonths(m) {
    return this._months[m.month()];
  }
  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
  function localeMonthsShort(m) {
    return this._monthsShort[m.month()];
  }
  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = create_utc__createUTC([
        2000,
        i
      ]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }
      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      // test the regex
      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }
  // MOMENTS
  function setMonth(mom, value) {
    var dayOfMonth;
    // TODO: Move this out of here!
    if (typeof value === 'string') {
      value = mom.localeData().monthsParse(value);
      // TODO: Another silent failure?
      if (typeof value !== 'number') {
        return mom;
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      utils_hooks__hooks.updateOffset(this, true);
      return this;
    } else {
      return get_set__get(this, 'Month');
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }
  function warn(msg) {
    if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true, msgWithStack = msg + '\n' + new Error().stack;
    return extend(function () {
      if (firstTime) {
        warn(msgWithStack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  utils_hooks__hooks.suppressDeprecationWarnings = false;
  var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var isoDates = [
      [
        'YYYYYY-MM-DD',
        /[+-]\d{6}-\d{2}-\d{2}/
      ],
      [
        'YYYY-MM-DD',
        /\d{4}-\d{2}-\d{2}/
      ],
      [
        'GGGG-[W]WW-E',
        /\d{4}-W\d{2}-\d/
      ],
      [
        'GGGG-[W]WW',
        /\d{4}-W\d{2}/
      ],
      [
        'YYYY-DDD',
        /\d{4}-\d{3}/
      ]
    ];
  // iso time formats and regexes
  var isoTimes = [
      [
        'HH:mm:ss.SSSS',
        /(T| )\d\d:\d\d:\d\d\.\d+/
      ],
      [
        'HH:mm:ss',
        /(T| )\d\d:\d\d:\d\d/
      ],
      [
        'HH:mm',
        /(T| )\d\d:\d\d/
      ],
      [
        'HH',
        /(T| )\d\d/
      ]
    ];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
  // date from iso format
  function configFromISO(config) {
    var i, l, string = config._i, match = from_string__isoRegex.exec(string);
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(string)) {
          // match[5] should be 'T' or undefined
          config._f = isoDates[i][0] + (match[6] || ' ');
          break;
        }
      }
      for (i = 0, l = isoTimes.length; i < l; i++) {
        if (isoTimes[i][1].exec(string)) {
          config._f += isoTimes[i][0];
          break;
        }
      }
      if (string.match(matchOffset)) {
        config._f += 'Z';
      }
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }
  // date from iso format or fallback
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  });
  function createDate(y, m, d, h, M, s, ms) {
    //can't just apply() to create a date:
    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
    var date = new Date(y, m, d, h, M, s, ms);
    //the date constructor doesn't accept years < 1970
    if (y < 1970) {
      date.setFullYear(y);
    }
    return date;
  }
  function createUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));
    if (y < 1970) {
      date.setUTCFullYear(y);
    }
    return date;
  }
  addFormatToken(0, [
    'YY',
    2
  ], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, [
    'YYYY',
    4
  ], 0, 'year');
  addFormatToken(0, [
    'YYYYY',
    5
  ], 0, 'year');
  addFormatToken(0, [
    'YYYYYY',
    6,
    true
  ], 0, 'year');
  // ALIASES
  addUnitAlias('year', 'y');
  // PARSING
  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken([
    'YYYY',
    'YYYYY',
    'YYYYYY'
  ], YEAR);
  addParseToken('YY', function (input, array) {
    array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  // HELPERS
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }
  // HOOKS
  utils_hooks__hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };
  // MOMENTS
  var getSetYear = makeGetSet('FullYear', false);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  addFormatToken('w', [
    'ww',
    2
  ], 'wo', 'week');
  addFormatToken('W', [
    'WW',
    2
  ], 'Wo', 'isoWeek');
  // ALIASES
  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');
  // PARSING
  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken([
    'w',
    'ww',
    'W',
    'WW'
  ], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });
  // HELPERS
  // firstDayOfWeek       0 = sun, 6 = sat
  //                      the day of the week that starts the week
  //                      (usually sunday or monday)
  // firstDayOfWeekOfYear 0 = sun, 6 = sat
  //                      the first week is the week that contains the first
  //                      of this day of the week
  //                      (eg. ISO weeks use thursday (4))
  function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
    var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
    if (daysToDayOfWeek > end) {
      daysToDayOfWeek -= 7;
    }
    if (daysToDayOfWeek < end - 7) {
      daysToDayOfWeek += 7;
    }
    adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
    return {
      week: Math.ceil(adjustedMoment.dayOfYear() / 7),
      year: adjustedMoment.year()
    };
  }
  // LOCALES
  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }
  // MOMENTS
  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  addFormatToken('DDD', [
    'DDDD',
    3
  ], 'DDDo', 'dayOfYear');
  // ALIASES
  addUnitAlias('dayOfYear', 'DDD');
  // PARSING
  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken([
    'DDD',
    'DDDD'
  ], function (input, array, config) {
    config._dayOfYear = toInt(input);
  });
  // HELPERS
  //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
    var d = createUTCDate(year, 0, 1).getUTCDay();
    var daysToAdd;
    var dayOfYear;
    d = d === 0 ? 7 : d;
    weekday = weekday != null ? weekday : firstDayOfWeek;
    daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
    dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
    return {
      year: dayOfYear > 0 ? year : year - 1,
      dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
    };
  }
  // MOMENTS
  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 86400000) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  }
  // Pick the first defined of two or three arguments.
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    var now = new Date();
    if (config._useUTC) {
      return [
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate()
      ];
    }
    return [
      now.getFullYear(),
      now.getMonth(),
      now.getDate()
    ];
  }
  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function configFromArray(config) {
    var i, date, input = [], currentDate, yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    //if the day of the year is set, figure out what it is
    if (config._dayOfYear) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse)) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    }
    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
      week = defaults(w.w, 1);
      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;
        if (weekday < dow) {
          ++week;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from begining of week
        weekday = w.e + dow;
      } else {
        // default to begining of week
        weekday = dow;
      }
    }
    temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
  utils_hooks__hooks.ISO_8601 = function () {
  };
  // date from string and format string
  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === utils_hooks__hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;
    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      // don't parse if it's not a known token
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }
    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }
    // clear _12h flag if hour is <= 12
    if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      // nothing to do
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  }
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (!valid__isValid(tempConfig)) {
        continue;
      }
      // if there is any input that was not parsed add a penalty for that format
      currentScore += getParsingFlags(tempConfig).charsLeftOver;
      //or tokens
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i);
    config._a = [
      i.year,
      i.month,
      i.day || i.date,
      i.hour,
      i.minute,
      i.second,
      i.millisecond
    ];
    configFromArray(config);
  }
  function createFromConfig(config) {
    var input = config._i, format = config._f, res;
    config._locale = config._locale || locale_locales__getLocale(config._l);
    if (input === null || format === undefined && input === '') {
      return valid__createInvalid({ nullInput: true });
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else if (isDate(input)) {
      config._d = input;
    } else {
      configFromInput(config);
    }
    res = new Moment(checkOverflow(config));
    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, 'd');
      res._nextDay = undefined;
    }
    return res;
  }
  function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
      config._d = new Date();
    } else if (isDate(input)) {
      config._d = new Date(+input);
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (typeof input === 'object') {
      configFromObject(config);
    } else if (typeof input === 'number') {
      // from milliseconds
      config._d = new Date(input);
    } else {
      utils_hooks__hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (typeof locale === 'boolean') {
      strict = locale;
      locale = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function local__createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate('moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function () {
      var other = local__createLocal.apply(null, arguments);
      return other < this ? this : other;
    });
  var prototypeMax = deprecate('moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function () {
      var other = local__createLocal.apply(null, arguments);
      return other > this ? this : other;
    });
  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return local__createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  // TODO: Use [].sort instead?
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
    // representation for dateAddRemove
    this._milliseconds = +milliseconds + seconds * 1000 + minutes * 60000 + hours * 3600000;
    // 1000 * 60 * 60
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days + weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = locale_locales__getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset();
      var sign = '+';
      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }
  offset('Z', ':');
  offset('ZZ', '');
  // PARSING
  addRegexToken('Z', matchOffset);
  addRegexToken('ZZ', matchOffset);
  addParseToken([
    'Z',
    'ZZ'
  ], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(input);
  });
  // HELPERS
  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(string) {
    var matches = (string || '').match(matchOffset) || [];
    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || [
        '-',
        0,
        0
      ];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return parts[0] === '+' ? minutes : -minutes;
  }
  // Return a moment from input, that is local/utc/zone equivalent to model.
  function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - +res;
      // Use low-level api, because this fn is low-level api.
      res._d.setTime(+res._d + diff);
      utils_hooks__hooks.updateOffset(res, false);
      return res;
    } else {
      return local__createLocal(input).local();
    }
    return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
  }
  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }
  // HOOKS
  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  utils_hooks__hooks.updateOffset = function () {
  };
  // MOMENTS
  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function getSetOffset(input, keepLocalTime) {
    var offset = this._offset || 0, localAdjust;
    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(input);
      }
      if (Math.abs(input) < 16) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          utils_hooks__hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm) {
      this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
      this.utcOffset(offsetFromString(this._i));
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!input) {
      input = 0;
    } else {
      input = local__createLocal(input).utcOffset();
    }
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (this._a) {
      var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
      return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
    }
    return false;
  }
  function isLocal() {
    return !this._isUTC;
  }
  function isUtcOffset() {
    return this._isUTC;
  }
  function isUtc() {
    return this._isUTC && this._offset === 0;
  }
  var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
  // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
  function create__createDuration(input, key) {
    var duration = input,
      // matching against regexp is expensive, do it on demand
      match = null, sign, ret, diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (typeof input === 'number') {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(match[MILLISECOND]) * sign
      };
    } else if (!!(match = create__isoRegex.exec(input))) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        d: parseIso(match[4], sign),
        h: parseIso(match[5], sign),
        m: parseIso(match[6], sign),
        s: parseIso(match[7], sign),
        w: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    return ret;
  }
  create__createDuration.fn = Duration.prototype;
  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {
        milliseconds: 0,
        months: 0
      };
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, 'M');
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }
  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp;
      //invert the arguments, but complain about it
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === 'string' ? +val : val;
      dur = create__createDuration(val, period);
      add_subtract__addSubtract(this, dur, direction);
      return this;
    };
  }
  function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
    updateOffset = updateOffset == null ? true : updateOffset;
    if (milliseconds) {
      mom._d.setTime(+mom._d + milliseconds * isAdding);
    }
    if (days) {
      get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
    }
    if (months) {
      setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
      utils_hooks__hooks.updateOffset(mom, days || months);
    }
  }
  var add_subtract__add = createAdder(1, 'add');
  var add_subtract__subtract = createAdder(-1, 'subtract');
  function moment_calendar__calendar(time) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || local__createLocal(), sod = cloneWithOffset(now, this).startOf('day'), diff = this.diff(sod, 'days', true), format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var inputMs;
    units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
    if (units === 'millisecond') {
      input = isMoment(input) ? input : local__createLocal(input);
      return +this > +input;
    } else {
      inputMs = isMoment(input) ? +input : +local__createLocal(input);
      return inputMs < +this.clone().startOf(units);
    }
  }
  function isBefore(input, units) {
    var inputMs;
    units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
    if (units === 'millisecond') {
      input = isMoment(input) ? input : local__createLocal(input);
      return +this < +input;
    } else {
      inputMs = isMoment(input) ? +input : +local__createLocal(input);
      return +this.clone().endOf(units) < inputMs;
    }
  }
  function isBetween(from, to, units) {
    return this.isAfter(from, units) && this.isBefore(to, units);
  }
  function isSame(input, units) {
    var inputMs;
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
      input = isMoment(input) ? input : local__createLocal(input);
      return +this === +input;
    } else {
      inputMs = +local__createLocal(input);
      return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
    }
  }
  function absFloor(number) {
    if (number < 0) {
      return Math.ceil(number);
    } else {
      return Math.floor(number);
    }
  }
  function diff(input, units, asFloat) {
    var that = cloneWithOffset(input, this), zoneDelta = (that.utcOffset() - this.utcOffset()) * 60000, delta, output;
    units = normalizeUnits(units);
    if (units === 'year' || units === 'month' || units === 'quarter') {
      output = monthDiff(this, that);
      if (units === 'quarter') {
        output = output / 3;
      } else if (units === 'year') {
        output = output / 12;
      }
    } else {
      delta = this - that;
      output = units === 'second' ? delta / 1000 : units === 'minute' ? delta / 60000 : units === 'hour' ? delta / 3600000 : units === 'day' ? (delta - zoneDelta) / 86400000 : units === 'week' ? (delta - zoneDelta) / 604800000 : delta;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    // difference in months
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
      // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
      // linear across the month
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
      // linear across the month
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust);
  }
  utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }
  function moment_format__toISOString() {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
      if ('function' === typeof Date.prototype.toISOString) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
      } else {
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    } else {
      return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
  }
  function format(inputString) {
    var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    return create__createDuration({
      to: this,
      from: time
    }).locale(this.locale()).humanize(!withoutSuffix);
  }
  function fromNow(withoutSuffix) {
    return this.from(local__createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    return create__createDuration({
      from: this,
      to: time
    }).locale(this.locale()).humanize(!withoutSuffix);
  }
  function toNow(withoutSuffix) {
    return this.to(local__createLocal(), withoutSuffix);
  }
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = locale_locales__getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });
  function localeData() {
    return this._locale;
  }
  function startOf(units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
    case 'year':
      this.month(0);
    /* falls through */
    case 'quarter':
    case 'month':
      this.date(1);
    /* falls through */
    case 'week':
    case 'isoWeek':
    case 'day':
      this.hours(0);
    /* falls through */
    case 'hour':
      this.minutes(0);
    /* falls through */
    case 'minute':
      this.seconds(0);
    /* falls through */
    case 'second':
      this.milliseconds(0);
    }
    // weeks are a special case
    if (units === 'week') {
      this.weekday(0);
    }
    if (units === 'isoWeek') {
      this.isoWeekday(1);
    }
    // quarters are also special
    if (units === 'quarter') {
      this.month(Math.floor(this.month() / 3) * 3);
    }
    return this;
  }
  function endOf(units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
      return this;
    }
    return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
  }
  function to_type__valueOf() {
    return +this._d - (this._offset || 0) * 60000;
  }
  function unix() {
    return Math.floor(+this / 1000);
  }
  function toDate() {
    return this._offset ? new Date(+this) : this._d;
  }
  function toArray() {
    var m = this;
    return [
      m.year(),
      m.month(),
      m.date(),
      m.hour(),
      m.minute(),
      m.second(),
      m.millisecond()
    ];
  }
  function moment_valid__isValid() {
    return valid__isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  addFormatToken(0, [
    'gg',
    2
  ], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, [
    'GG',
    2
  ], 0, function () {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [
      token,
      token.length
    ], 0, getter);
  }
  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');
  // ALIASES
  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');
  // PARSING
  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken([
    'gggg',
    'ggggg',
    'GGGG',
    'GGGGG'
  ], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken([
    'gg',
    'GG'
  ], function (input, week, config, token) {
    week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
  });
  // HELPERS
  function weeksInYear(year, dow, doy) {
    return weekOfYear(local__createLocal([
      year,
      11,
      31 + dow - doy
    ]), dow, doy).week;
  }
  // MOMENTS
  function getSetWeekYear(input) {
    var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
    return input == null ? year : this.add(input - year, 'y');
  }
  function getSetISOWeekYear(input) {
    var year = weekOfYear(this, 1, 4).year;
    return input == null ? year : this.add(input - year, 'y');
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  addFormatToken('Q', 0, 0, 'quarter');
  // ALIASES
  addUnitAlias('quarter', 'Q');
  // PARSING
  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });
  // MOMENTS
  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }
  addFormatToken('D', [
    'DD',
    2
  ], 'Do', 'date');
  // ALIASES
  addUnitAlias('date', 'D');
  // PARSING
  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
  });
  addParseToken([
    'D',
    'DD'
  ], DATE);
  addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
  });
  // MOMENTS
  var getSetDayOfMonth = makeGetSet('Date', true);
  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');
  // ALIASES
  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');
  // PARSING
  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', matchWord);
  addRegexToken('ddd', matchWord);
  addRegexToken('dddd', matchWord);
  addWeekParseToken([
    'dd',
    'ddd',
    'dddd'
  ], function (input, week, config) {
    var weekday = config._locale.weekdaysParse(input);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken([
    'd',
    'e',
    'E'
  ], function (input, week, config, token) {
    week[token] = toInt(input);
  });
  // HELPERS
  function parseWeekday(input, locale) {
    if (typeof input === 'string') {
      if (!isNaN(input)) {
        input = parseInt(input, 10);
      } else {
        input = locale.weekdaysParse(input);
        if (typeof input !== 'number') {
          return null;
        }
      }
    }
    return input;
  }
  // LOCALES
  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
  function localeWeekdays(m) {
    return this._weekdays[m.day()];
  }
  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
  function localeWeekdaysShort(m) {
    return this._weekdaysShort[m.day()];
  }
  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
  function localeWeekdaysMin(m) {
    return this._weekdaysMin[m.day()];
  }
  function localeWeekdaysParse(weekdayName) {
    var i, mom, regex;
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      if (!this._weekdaysParse[i]) {
        mom = local__createLocal([
          2000,
          1
        ]).day(i);
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      // test the regex
      if (this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }
  // MOMENTS
  function getSetDayOfWeek(input) {
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }
  function getSetISODayOfWeek(input) {
    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.
    return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
  }
  addFormatToken('H', [
    'HH',
    2
  ], 0, 'hour');
  addFormatToken('h', [
    'hh',
    2
  ], 0, function () {
    return this.hours() % 12 || 12;
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem('a', true);
  meridiem('A', false);
  // ALIASES
  addUnitAlias('hour', 'h');
  // PARSING
  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addParseToken([
    'H',
    'HH'
  ], HOUR);
  addParseToken([
    'a',
    'A'
  ], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken([
    'h',
    'hh'
  ], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  // LOCALES
  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }
  // MOMENTS
  // Setting the hour should keep the time, because the user explicitly
  // specified which hour he wants. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.
  var getSetHour = makeGetSet('Hours', true);
  addFormatToken('m', [
    'mm',
    2
  ], 0, 'minute');
  // ALIASES
  addUnitAlias('minute', 'm');
  // PARSING
  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken([
    'm',
    'mm'
  ], MINUTE);
  // MOMENTS
  var getSetMinute = makeGetSet('Minutes', false);
  addFormatToken('s', [
    'ss',
    2
  ], 0, 'second');
  // ALIASES
  addUnitAlias('second', 's');
  // PARSING
  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken([
    's',
    'ss'
  ], SECOND);
  // MOMENTS
  var getSetSecond = makeGetSet('Seconds', false);
  addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, [
    'SS',
    2
  ], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  function millisecond__milliseconds(token) {
    addFormatToken(0, [
      token,
      3
    ], 0, 'millisecond');
  }
  millisecond__milliseconds('SSS');
  millisecond__milliseconds('SSSS');
  // ALIASES
  addUnitAlias('millisecond', 'ms');
  // PARSING
  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  addRegexToken('SSSS', matchUnsigned);
  addParseToken([
    'S',
    'SS',
    'SSS',
    'SSSS'
  ], function (input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  });
  // MOMENTS
  var getSetMillisecond = makeGetSet('Milliseconds', false);
  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');
  // MOMENTS
  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }
  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }
  var momentPrototype__proto = Moment.prototype;
  momentPrototype__proto.add = add_subtract__add;
  momentPrototype__proto.calendar = moment_calendar__calendar;
  momentPrototype__proto.clone = clone;
  momentPrototype__proto.diff = diff;
  momentPrototype__proto.endOf = endOf;
  momentPrototype__proto.format = format;
  momentPrototype__proto.from = from;
  momentPrototype__proto.fromNow = fromNow;
  momentPrototype__proto.to = to;
  momentPrototype__proto.toNow = toNow;
  momentPrototype__proto.get = getSet;
  momentPrototype__proto.invalidAt = invalidAt;
  momentPrototype__proto.isAfter = isAfter;
  momentPrototype__proto.isBefore = isBefore;
  momentPrototype__proto.isBetween = isBetween;
  momentPrototype__proto.isSame = isSame;
  momentPrototype__proto.isValid = moment_valid__isValid;
  momentPrototype__proto.lang = lang;
  momentPrototype__proto.locale = locale;
  momentPrototype__proto.localeData = localeData;
  momentPrototype__proto.max = prototypeMax;
  momentPrototype__proto.min = prototypeMin;
  momentPrototype__proto.parsingFlags = parsingFlags;
  momentPrototype__proto.set = getSet;
  momentPrototype__proto.startOf = startOf;
  momentPrototype__proto.subtract = add_subtract__subtract;
  momentPrototype__proto.toArray = toArray;
  momentPrototype__proto.toDate = toDate;
  momentPrototype__proto.toISOString = moment_format__toISOString;
  momentPrototype__proto.toJSON = moment_format__toISOString;
  momentPrototype__proto.toString = toString;
  momentPrototype__proto.unix = unix;
  momentPrototype__proto.valueOf = to_type__valueOf;
  // Year
  momentPrototype__proto.year = getSetYear;
  momentPrototype__proto.isLeapYear = getIsLeapYear;
  // Week Year
  momentPrototype__proto.weekYear = getSetWeekYear;
  momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
  // Quarter
  momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
  // Month
  momentPrototype__proto.month = getSetMonth;
  momentPrototype__proto.daysInMonth = getDaysInMonth;
  // Week
  momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
  momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
  momentPrototype__proto.weeksInYear = getWeeksInYear;
  momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
  // Day
  momentPrototype__proto.date = getSetDayOfMonth;
  momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
  momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
  momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
  momentPrototype__proto.dayOfYear = getSetDayOfYear;
  // Hour
  momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
  // Minute
  momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
  // Second
  momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
  // Millisecond
  momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
  // Offset
  momentPrototype__proto.utcOffset = getSetOffset;
  momentPrototype__proto.utc = setOffsetToUTC;
  momentPrototype__proto.local = setOffsetToLocal;
  momentPrototype__proto.parseZone = setOffsetToParsedOffset;
  momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
  momentPrototype__proto.isDST = isDaylightSavingTime;
  momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
  momentPrototype__proto.isLocal = isLocal;
  momentPrototype__proto.isUtcOffset = isUtcOffset;
  momentPrototype__proto.isUtc = isUtc;
  momentPrototype__proto.isUTC = isUtc;
  // Timezone
  momentPrototype__proto.zoneAbbr = getZoneAbbr;
  momentPrototype__proto.zoneName = getZoneName;
  // Deprecations
  momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
  var momentPrototype = momentPrototype__proto;
  function moment__createUnix(input) {
    return local__createLocal(input * 1000);
  }
  function moment__createInZone() {
    return local__createLocal.apply(null, arguments).parseZone();
  }
  var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };
  function locale_calendar__calendar(key, mom, now) {
    var output = this._calendar[key];
    return typeof output === 'function' ? output.call(mom, now) : output;
  }
  var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY LT',
      LLLL: 'dddd, MMMM D, YYYY LT'
    };
  function longDateFormat(key) {
    var output = this._longDateFormat[key];
    if (!output && this._longDateFormat[key.toUpperCase()]) {
      output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      this._longDateFormat[key] = output;
    }
    return output;
  }
  var defaultInvalidDate = 'Invalid date';
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = '%d';
  var defaultOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }
  function preParsePostFormat(string) {
    return string;
  }
  var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };
  function relative__relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return typeof output === 'function' ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
  }
  function locale_set__set(config) {
    var prop, i;
    for (i in config) {
      prop = config[i];
      if (typeof prop === 'function') {
        this[i] = prop;
      } else {
        this['_' + i] = prop;
      }
    }
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _ordinalParseLenient.
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
  }
  var prototype__proto = Locale.prototype;
  prototype__proto._calendar = defaultCalendar;
  prototype__proto.calendar = locale_calendar__calendar;
  prototype__proto._longDateFormat = defaultLongDateFormat;
  prototype__proto.longDateFormat = longDateFormat;
  prototype__proto._invalidDate = defaultInvalidDate;
  prototype__proto.invalidDate = invalidDate;
  prototype__proto._ordinal = defaultOrdinal;
  prototype__proto.ordinal = ordinal;
  prototype__proto._ordinalParse = defaultOrdinalParse;
  prototype__proto.preparse = preParsePostFormat;
  prototype__proto.postformat = preParsePostFormat;
  prototype__proto._relativeTime = defaultRelativeTime;
  prototype__proto.relativeTime = relative__relativeTime;
  prototype__proto.pastFuture = pastFuture;
  prototype__proto.set = locale_set__set;
  // Month
  prototype__proto.months = localeMonths;
  prototype__proto._months = defaultLocaleMonths;
  prototype__proto.monthsShort = localeMonthsShort;
  prototype__proto._monthsShort = defaultLocaleMonthsShort;
  prototype__proto.monthsParse = localeMonthsParse;
  // Week
  prototype__proto.week = localeWeek;
  prototype__proto._week = defaultLocaleWeek;
  prototype__proto.firstDayOfYear = localeFirstDayOfYear;
  prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
  // Day of Week
  prototype__proto.weekdays = localeWeekdays;
  prototype__proto._weekdays = defaultLocaleWeekdays;
  prototype__proto.weekdaysMin = localeWeekdaysMin;
  prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
  prototype__proto.weekdaysShort = localeWeekdaysShort;
  prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
  prototype__proto.weekdaysParse = localeWeekdaysParse;
  // Hours
  prototype__proto.isPM = localeIsPM;
  prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
  prototype__proto.meridiem = localeMeridiem;
  function lists__get(format, index, field, setter) {
    var locale = locale_locales__getLocale();
    var utc = create_utc__createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function list(format, index, field, count, setter) {
    if (typeof format === 'number') {
      index = format;
      format = undefined;
    }
    format = format || '';
    if (index != null) {
      return lists__get(format, index, field, setter);
    }
    var i;
    var out = [];
    for (i = 0; i < count; i++) {
      out[i] = lists__get(format, i, field, setter);
    }
    return out;
  }
  function lists__listMonths(format, index) {
    return list(format, index, 'months', 12, 'month');
  }
  function lists__listMonthsShort(format, index) {
    return list(format, index, 'monthsShort', 12, 'month');
  }
  function lists__listWeekdays(format, index) {
    return list(format, index, 'weekdays', 7, 'day');
  }
  function lists__listWeekdaysShort(format, index) {
    return list(format, index, 'weekdaysShort', 7, 'day');
  }
  function lists__listWeekdaysMin(format, index) {
    return list(format, index, 'weekdaysMin', 7, 'day');
  }
  locale_locales__getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10, output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  // Side effect imports
  utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
  utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
  var mathAbs = Math.abs;
  function duration_abs__abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function duration_add_subtract__addSubtract(duration, input, value, direction) {
    var other = create__createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }
  // supports only 2.0-style add(1, 's') or add(duration)
  function duration_add_subtract__add(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, 1);
  }
  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function duration_add_subtract__subtract(input, value) {
    return duration_add_subtract__addSubtract(this, input, value, -1);
  }
  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds, minutes, hours, years = 0;
    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);
    // Accurately convert days to years, assume start from year 0.
    years = absFloor(daysToYears(days));
    days -= absFloor(yearsToDays(years));
    // 30 days to a month
    // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
    months += absFloor(days / 30);
    days %= 30;
    // 12 months -> 1 year
    years += absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToYears(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    return days * 400 / 146097;
  }
  function yearsToDays(years) {
    // years * 365 + absFloor(years / 4) -
    //     absFloor(years / 100) + absFloor(years / 400);
    return years * 146097 / 400;
  }
  function as(units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === 'month' || units === 'year') {
      days = this._days + milliseconds / 86400000;
      months = this._months + daysToYears(days) * 12;
      return units === 'month' ? months : months / 12;
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(yearsToDays(this._months / 12));
      switch (units) {
      case 'week':
        return days / 7 + milliseconds / 604800000;
      case 'day':
        return days + milliseconds / 86400000;
      case 'hour':
        return days * 24 + milliseconds / 3600000;
      case 'minute':
        return days * 1440 + milliseconds / 60000;
      case 'second':
        return days * 86400 + milliseconds / 1000;
      // Math.floor prevents floating point math errors here
      case 'millisecond':
        return Math.floor(days * 86400000) + milliseconds;
      default:
        throw new Error('Unknown unit ' + units);
      }
    }
  }
  // TODO: Use this.as('ms')?
  function duration_as__valueOf() {
    return this._milliseconds + this._days * 86400000 + this._months % 12 * 2592000000 + toInt(this._months / 12) * 31536000000;
  }
  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs('ms');
  var asSeconds = makeAs('s');
  var asMinutes = makeAs('m');
  var asHours = makeAs('h');
  var asDays = makeAs('d');
  var asWeeks = makeAs('w');
  var asMonths = makeAs('M');
  var asYears = makeAs('y');
  function duration_get__get(units) {
    units = normalizeUnits(units);
    return this[units + 's']();
  }
  function makeGetter(name) {
    return function () {
      return this._data[name];
    };
  }
  var duration_get__milliseconds = makeGetter('milliseconds');
  var seconds = makeGetter('seconds');
  var minutes = makeGetter('minutes');
  var hours = makeGetter('hours');
  var days = makeGetter('days');
  var months = makeGetter('months');
  var years = makeGetter('years');
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = {
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    };
  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
    var duration = create__createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));
    var a = seconds < thresholds.s && [
        's',
        seconds
      ] || minutes === 1 && ['m'] || minutes < thresholds.m && [
        'mm',
        minutes
      ] || hours === 1 && ['h'] || hours < thresholds.h && [
        'hh',
        hours
      ] || days === 1 && ['d'] || days < thresholds.d && [
        'dd',
        days
      ] || months === 1 && ['M'] || months < thresholds.M && [
        'MM',
        months
      ] || years === 1 && ['y'] || [
        'yy',
        years
      ];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }
  // This function allows you to set a threshold for relative time strings
  function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
  }
  function humanize(withSuffix) {
    var locale = this.localeData();
    var output = duration_humanize__relativeTime(this, !withSuffix, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var iso_string__abs = Math.abs;
  function iso_string__toISOString() {
    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = iso_string__abs(this.years());
    var M = iso_string__abs(this.months());
    var D = iso_string__abs(this.days());
    var h = iso_string__abs(this.hours());
    var m = iso_string__abs(this.minutes());
    var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
    var total = this.asSeconds();
    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return 'P0D';
    }
    return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
  }
  var duration_prototype__proto = Duration.prototype;
  duration_prototype__proto.abs = duration_abs__abs;
  duration_prototype__proto.add = duration_add_subtract__add;
  duration_prototype__proto.subtract = duration_add_subtract__subtract;
  duration_prototype__proto.as = as;
  duration_prototype__proto.asMilliseconds = asMilliseconds;
  duration_prototype__proto.asSeconds = asSeconds;
  duration_prototype__proto.asMinutes = asMinutes;
  duration_prototype__proto.asHours = asHours;
  duration_prototype__proto.asDays = asDays;
  duration_prototype__proto.asWeeks = asWeeks;
  duration_prototype__proto.asMonths = asMonths;
  duration_prototype__proto.asYears = asYears;
  duration_prototype__proto.valueOf = duration_as__valueOf;
  duration_prototype__proto._bubble = bubble;
  duration_prototype__proto.get = duration_get__get;
  duration_prototype__proto.milliseconds = duration_get__milliseconds;
  duration_prototype__proto.seconds = seconds;
  duration_prototype__proto.minutes = minutes;
  duration_prototype__proto.hours = hours;
  duration_prototype__proto.days = days;
  duration_prototype__proto.weeks = weeks;
  duration_prototype__proto.months = months;
  duration_prototype__proto.years = years;
  duration_prototype__proto.humanize = humanize;
  duration_prototype__proto.toISOString = iso_string__toISOString;
  duration_prototype__proto.toString = iso_string__toISOString;
  duration_prototype__proto.toJSON = iso_string__toISOString;
  duration_prototype__proto.locale = locale;
  duration_prototype__proto.localeData = localeData;
  // Deprecations
  duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
  duration_prototype__proto.lang = lang;
  // Side effect imports
  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');
  // PARSING
  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
  });
  // Side effect imports
  utils_hooks__hooks.version = '2.10.3';
  setHookCallback(local__createLocal);
  utils_hooks__hooks.fn = momentPrototype;
  utils_hooks__hooks.min = min;
  utils_hooks__hooks.max = max;
  utils_hooks__hooks.utc = create_utc__createUTC;
  utils_hooks__hooks.unix = moment__createUnix;
  utils_hooks__hooks.months = lists__listMonths;
  utils_hooks__hooks.isDate = isDate;
  utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
  utils_hooks__hooks.invalid = valid__createInvalid;
  utils_hooks__hooks.duration = create__createDuration;
  utils_hooks__hooks.isMoment = isMoment;
  utils_hooks__hooks.weekdays = lists__listWeekdays;
  utils_hooks__hooks.parseZone = moment__createInZone;
  utils_hooks__hooks.localeData = locale_locales__getLocale;
  utils_hooks__hooks.isDuration = isDuration;
  utils_hooks__hooks.monthsShort = lists__listMonthsShort;
  utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
  utils_hooks__hooks.defineLocale = defineLocale;
  utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
  utils_hooks__hooks.normalizeUnits = normalizeUnits;
  utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
  var _moment = utils_hooks__hooks;
  return _moment;
}));// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                          │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\
(function (glob) {
  var version = '0.4.2', has = 'hasOwnProperty', separator = /[\.\/]/, wildcard = '*', fun = function () {
    }, numsort = function (a, b) {
      return a - b;
    }, current_event, stop, events = { n: {} },
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/
    eve = function (name, scope) {
      name = String(name);
      var e = events, oldstop = stop, args = Array.prototype.slice.call(arguments, 2), listeners = eve.listeners(name), z = 0, f = false, l, indexed = [], queue = {}, out = [], ce = current_event, errors = [];
      current_event = name;
      stop = 0;
      for (var i = 0, ii = listeners.length; i < ii; i++)
        if ('zIndex' in listeners[i]) {
          indexed.push(listeners[i].zIndex);
          if (listeners[i].zIndex < 0) {
            queue[listeners[i].zIndex] = listeners[i];
          }
        }
      indexed.sort(numsort);
      while (indexed[z] < 0) {
        l = queue[indexed[z++]];
        out.push(l.apply(scope, args));
        if (stop) {
          stop = oldstop;
          return out;
        }
      }
      for (i = 0; i < ii; i++) {
        l = listeners[i];
        if ('zIndex' in l) {
          if (l.zIndex == indexed[z]) {
            out.push(l.apply(scope, args));
            if (stop) {
              break;
            }
            do {
              z++;
              l = queue[indexed[z]];
              l && out.push(l.apply(scope, args));
              if (stop) {
                break;
              }
            } while (l);
          } else {
            queue[l.zIndex] = l;
          }
        } else {
          out.push(l.apply(scope, args));
          if (stop) {
            break;
          }
        }
      }
      stop = oldstop;
      current_event = ce;
      return out.length ? out : null;
    };
  // Undocumented. Debug only.
  eve._events = events;
  /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
  eve.listeners = function (name) {
    var names = name.split(separator), e = events, item, items, k, i, ii, j, jj, nes, es = [e], out = [];
    for (i = 0, ii = names.length; i < ii; i++) {
      nes = [];
      for (j = 0, jj = es.length; j < jj; j++) {
        e = es[j].n;
        items = [
          e[names[i]],
          e[wildcard]
        ];
        k = 2;
        while (k--) {
          item = items[k];
          if (item) {
            nes.push(item);
            out = out.concat(item.f || []);
          }
        }
      }
      es = nes;
    }
    return out;
  };
  /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
  eve.on = function (name, f) {
    name = String(name);
    if (typeof f != 'function') {
      return function () {
      };
    }
    var names = name.split(separator), e = events;
    for (var i = 0, ii = names.length; i < ii; i++) {
      e = e.n;
      e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = { n: {} });
    }
    e.f = e.f || [];
    for (i = 0, ii = e.f.length; i < ii; i++)
      if (e.f[i] == f) {
        return fun;
      }
    e.f.push(f);
    return function (zIndex) {
      if (+zIndex == +zIndex) {
        f.zIndex = +zIndex;
      }
    };
  };
  /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
 	 | el.onclick = eve.f("click", 1, 2);
 	 | eve.on("click", function (a, b, c) {
 	 |     console.log(a, b, c); // 1, 2, [event object]
 	 | });
     > Arguments
	 - event (string) event name
	 - varargs (…) and any other arguments
	 = (function) possible event handler function
    \*/
  eve.f = function (event) {
    var attrs = [].slice.call(arguments, 1);
    return function () {
      eve.apply(null, [
        event,
        null
      ].concat(attrs).concat([].slice.call(arguments, 0)));
    };
  };
  /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
  eve.stop = function () {
    stop = 1;
  };
  /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
  eve.nt = function (subname) {
    if (subname) {
      return new RegExp('(?:\\.|\\/|^)' + subname + '(?:\\.|\\/|$)').test(current_event);
    }
    return current_event;
  };
  /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
  eve.nts = function () {
    return current_event.split(separator);
  };
  /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
  /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
  eve.off = eve.unbind = function (name, f) {
    if (!name) {
      eve._events = events = { n: {} };
      return;
    }
    var names = name.split(separator), e, key, splice, i, ii, j, jj, cur = [events];
    for (i = 0, ii = names.length; i < ii; i++) {
      for (j = 0; j < cur.length; j += splice.length - 2) {
        splice = [
          j,
          1
        ];
        e = cur[j].n;
        if (names[i] != wildcard) {
          if (e[names[i]]) {
            splice.push(e[names[i]]);
          }
        } else {
          for (key in e)
            if (e[has](key)) {
              splice.push(e[key]);
            }
        }
        cur.splice.apply(cur, splice);
      }
    }
    for (i = 0, ii = cur.length; i < ii; i++) {
      e = cur[i];
      while (e.n) {
        if (f) {
          if (e.f) {
            for (j = 0, jj = e.f.length; j < jj; j++)
              if (e.f[j] == f) {
                e.f.splice(j, 1);
                break;
              }
            !e.f.length && delete e.f;
          }
          for (key in e.n)
            if (e.n[has](key) && e.n[key].f) {
              var funcs = e.n[key].f;
              for (j = 0, jj = funcs.length; j < jj; j++)
                if (funcs[j] == f) {
                  funcs.splice(j, 1);
                  break;
                }
              !funcs.length && delete e.n[key].f;
            }
        } else {
          delete e.f;
          for (key in e.n)
            if (e.n[has](key) && e.n[key].f) {
              delete e.n[key].f;
            }
        }
        e = e.n;
      }
    }
  };
  /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
  eve.once = function (name, f) {
    var f2 = function () {
      eve.unbind(name, f2);
      return f.apply(this, arguments);
    };
    return eve.on(name, f2);
  };
  /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
  eve.version = version;
  eve.toString = function () {
    return 'You are running Eve ' + version;
  };
  typeof module != 'undefined' && module.exports ? module.exports = eve : typeof define != 'undefined' ? define('eve', [], function () {
    return eve;
  }) : glob.eve = eve;
}(window || this));
// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ "Raphaël 2.1.2" - JavaScript Vector Library                         │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
(function (glob, factory) {
  // AMD support
  if (typeof define === 'function' && define.amd) {
    // Define as an anonymous module
    define(['eve'], function (eve) {
      return factory(glob, eve);
    });
  } else {
    // Browser globals (glob is window)
    // Raphael adds itself to window
    factory(glob, glob.eve || typeof require == 'function' && require('eve'));
  }
}(this, function (window, eve) {
  /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport’s 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/
  function R(first) {
    if (R.is(first, 'function')) {
      return loaded ? first() : eve.on('raphael.DOMload', first);
    } else if (R.is(first, array)) {
      return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
    } else {
      var args = Array.prototype.slice.call(arguments, 0);
      if (R.is(args[args.length - 1], 'function')) {
        var f = args.pop();
        return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on('raphael.DOMload', function () {
          f.call(R._engine.create[apply](R, args));
        });
      } else {
        return R._engine.create[apply](R, arguments);
      }
    }
  }
  R.version = '2.1.2';
  R.eve = eve;
  var loaded, separator = /[, ]+/, elements = {
      circle: 1,
      rect: 1,
      path: 1,
      ellipse: 1,
      text: 1,
      image: 1
    }, formatrg = /\{(\d+)\}/g, proto = 'prototype', has = 'hasOwnProperty', g = {
      doc: document,
      win: window
    }, oldRaphael = {
      was: Object.prototype[has].call(g.win, 'Raphael'),
      is: g.win.Raphael
    }, Paper = function () {
      /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/
      /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute “hue” will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
      this.ca = this.customAttributes = {};
    }, paperproto, appendChild = 'appendChild', apply = 'apply', concat = 'concat', supportsTouch = 'ontouchstart' in g.win || g.win.DocumentTouch && g.doc instanceof DocumentTouch,
    //taken from Modernizr touch test
    E = '', S = ' ', Str = String, split = 'split', events = 'click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel'[split](S), touchMap = {
      mousedown: 'touchstart',
      mousemove: 'touchmove',
      mouseup: 'touchend'
    }, lowerCase = Str.prototype.toLowerCase, math = Math, mmax = math.max, mmin = math.min, abs = math.abs, pow = math.pow, PI = math.PI, nu = 'number', string = 'string', array = 'array', toString = 'toString', fillString = 'fill', objectToString = Object.prototype.toString, paper = {}, push = 'push', ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i, colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i, isnan = {
      'NaN': 1,
      'Infinity': 1,
      '-Infinity': 1
    }, bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, round = math.round, setAttribute = 'setAttribute', toFloat = parseFloat, toInt = parseInt, upperCase = Str.prototype.toUpperCase, availableAttrs = R._availableAttrs = {
      'arrow-end': 'none',
      'arrow-start': 'none',
      blur: 0,
      'clip-rect': '0 0 1e9 1e9',
      cursor: 'default',
      cx: 0,
      cy: 0,
      fill: '#fff',
      'fill-opacity': 1,
      font: '10px "Arial"',
      'font-family': '"Arial"',
      'font-size': '10',
      'font-style': 'normal',
      'font-weight': 400,
      gradient: 0,
      height: 0,
      href: 'http://raphaeljs.com/',
      'letter-spacing': 0,
      opacity: 1,
      path: 'M0,0',
      r: 0,
      rx: 0,
      ry: 0,
      src: '',
      stroke: '#000',
      'stroke-dasharray': '',
      'stroke-linecap': 'butt',
      'stroke-linejoin': 'butt',
      'stroke-miterlimit': 0,
      'stroke-opacity': 1,
      'stroke-width': 1,
      target: '_blank',
      'text-anchor': 'middle',
      title: 'Raphael',
      transform: '',
      width: 0,
      x: 0,
      y: 0
    }, availableAnimAttrs = R._availableAnimAttrs = {
      blur: nu,
      'clip-rect': 'csv',
      cx: nu,
      cy: nu,
      fill: 'colour',
      'fill-opacity': nu,
      'font-size': nu,
      height: nu,
      opacity: nu,
      path: 'path',
      r: nu,
      rx: nu,
      ry: nu,
      stroke: 'colour',
      'stroke-opacity': nu,
      'stroke-width': nu,
      transform: 'transform',
      width: nu,
      x: nu,
      y: nu
    }, whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g, commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/, hsrg = {
      hs: 1,
      rg: 1
    }, p2s = /,?([achlmqrstvxz]),?/gi, pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi, tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi, pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi, radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/, eldata = {}, sortByKey = function (a, b) {
      return a.key - b.key;
    }, sortByNumber = function (a, b) {
      return toFloat(a) - toFloat(b);
    }, fun = function () {
    }, pipe = function (x) {
      return x;
    }, rectPath = R._rectPath = function (x, y, w, h, r) {
      if (r) {
        return [
          [
            'M',
            x + r,
            y
          ],
          [
            'l',
            w - r * 2,
            0
          ],
          [
            'a',
            r,
            r,
            0,
            0,
            1,
            r,
            r
          ],
          [
            'l',
            0,
            h - r * 2
          ],
          [
            'a',
            r,
            r,
            0,
            0,
            1,
            -r,
            r
          ],
          [
            'l',
            r * 2 - w,
            0
          ],
          [
            'a',
            r,
            r,
            0,
            0,
            1,
            -r,
            -r
          ],
          [
            'l',
            0,
            r * 2 - h
          ],
          [
            'a',
            r,
            r,
            0,
            0,
            1,
            r,
            -r
          ],
          ['z']
        ];
      }
      return [
        [
          'M',
          x,
          y
        ],
        [
          'l',
          w,
          0
        ],
        [
          'l',
          0,
          h
        ],
        [
          'l',
          -w,
          0
        ],
        ['z']
      ];
    }, ellipsePath = function (x, y, rx, ry) {
      if (ry == null) {
        ry = rx;
      }
      return [
        [
          'M',
          x,
          y
        ],
        [
          'm',
          0,
          -ry
        ],
        [
          'a',
          rx,
          ry,
          0,
          1,
          1,
          0,
          2 * ry
        ],
        [
          'a',
          rx,
          ry,
          0,
          1,
          1,
          0,
          -2 * ry
        ],
        ['z']
      ];
    }, getPath = R._getPath = {
      path: function (el) {
        return el.attr('path');
      },
      circle: function (el) {
        var a = el.attrs;
        return ellipsePath(a.cx, a.cy, a.r);
      },
      ellipse: function (el) {
        var a = el.attrs;
        return ellipsePath(a.cx, a.cy, a.rx, a.ry);
      },
      rect: function (el) {
        var a = el.attrs;
        return rectPath(a.x, a.y, a.width, a.height, a.r);
      },
      image: function (el) {
        var a = el.attrs;
        return rectPath(a.x, a.y, a.width, a.height);
      },
      text: function (el) {
        var bbox = el._getBBox();
        return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
      },
      set: function (el) {
        var bbox = el._getBBox();
        return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
      }
    },
    /*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         > Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
    mapPath = R.mapPath = function (path, matrix) {
      if (!matrix) {
        return path;
      }
      var x, y, i, j, ii, jj, pathi;
      path = path2curve(path);
      for (i = 0, ii = path.length; i < ii; i++) {
        pathi = path[i];
        for (j = 1, jj = pathi.length; j < jj; j += 2) {
          x = matrix.x(pathi[j], pathi[j + 1]);
          y = matrix.y(pathi[j], pathi[j + 1]);
          pathi[j] = x;
          pathi[j + 1] = y;
        }
      }
      return path;
    };
  R._g = g;
  /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be “SVG”, “VML” or empty, depending on browser support.
    \*/
  R.type = g.win.SVGAngle || g.doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1') ? 'SVG' : 'VML';
  if (R.type == 'VML') {
    var d = g.doc.createElement('div'), b;
    d.innerHTML = '<v:shape adj="1"/>';
    b = d.firstChild;
    b.style.behavior = 'url(#default#VML)';
    if (!(b && typeof b.adj == 'object')) {
      return R.type = E;
    }
    d = null;
  }
  /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/
  /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/
  R.svg = !(R.vml = R.type == 'VML');
  R._Paper = Paper;
  /*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphaël instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     > Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {…},
     |     star: function () {…},
     |     // etc…
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
    \*/
  R.fn = paperproto = Paper.prototype = R.prototype;
  R._id = 0;
  R._oid = 0;
  /*\
     * Raphael.is
     [ method ]
     **
     * Handful of replacements for `typeof` operator.
     > Parameters
     - o (…) any object or primitive
     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
     = (boolean) is given value is of given type
    \*/
  R.is = function (o, type) {
    type = lowerCase.call(type);
    if (type == 'finite') {
      return !isnan[has](+o);
    }
    if (type == 'array') {
      return o instanceof Array;
    }
    return type == 'null' && o === null || type == typeof o && o !== null || type == 'object' && o === Object(o) || type == 'array' && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
  };
  function clone(obj) {
    if (typeof obj == 'function' || Object(obj) !== obj) {
      return obj;
    }
    var res = new obj.constructor();
    for (var key in obj)
      if (obj[has](key)) {
        res[key] = clone(obj[key]);
      }
    return res;
  }
  /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/
  R.angle = function (x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
      var x = x1 - x2, y = y1 - y2;
      if (!x && !y) {
        return 0;
      }
      return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
    } else {
      return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    }
  };
  /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/
  R.rad = function (deg) {
    return deg % 360 * PI / 180;
  };
  /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - rad (number) angle in radians
     = (number) angle in degrees.
    \*/
  R.deg = function (rad) {
    return Math.round(rad * 180 / PI % 360 * 1000) / 1000;
  };
  /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/
  R.snapTo = function (values, value, tolerance) {
    tolerance = R.is(tolerance, 'finite') ? tolerance : 10;
    if (R.is(values, array)) {
      var i = values.length;
      while (i--)
        if (abs(values[i] - value) <= tolerance) {
          return values[i];
        }
    } else {
      values = +values;
      var rem = value % values;
      if (rem < tolerance) {
        return value - rem;
      }
      if (rem > values - tolerance) {
        return value - rem + values;
      }
    }
    return value;
  };
  /*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
    \*/
  var createUUID = R.createUUID = function (uuidRegEx, uuidReplacer) {
      return function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(uuidRegEx, uuidReplacer).toUpperCase();
      };
    }(/[xy]/g, function (c) {
      var r = math.random() * 16 | 0, v = c == 'x' ? r : r & 3 | 8;
      return v.toString(16);
    });
  /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
    \*/
  R.setWindow = function (newwin) {
    eve('raphael.setWindow', R, g.win, newwin);
    g.win = newwin;
    g.doc = g.win.document;
    if (R._engine.initWin) {
      R._engine.initWin(g.win);
    }
  };
  var toHex = function (color) {
      if (R.vml) {
        // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
        var trim = /^\s+|\s+$/g;
        var bod;
        try {
          var docum = new ActiveXObject('htmlfile');
          docum.write('<body>');
          docum.close();
          bod = docum.body;
        } catch (e) {
          bod = createPopup().document.body;
        }
        var range = bod.createTextRange();
        toHex = cacher(function (color) {
          try {
            bod.style.color = Str(color).replace(trim, E);
            var value = range.queryCommandValue('ForeColor');
            value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16;
            return '#' + ('000000' + value.toString(16)).slice(-6);
          } catch (e) {
            return 'none';
          }
        });
      } else {
        var i = g.doc.createElement('i');
        i.title = 'Rapha\xebl Colour Picker';
        i.style.display = 'none';
        g.doc.body.appendChild(i);
        toHex = cacher(function (color) {
          i.style.color = color;
          return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue('color');
        });
      }
      return toHex(color);
    }, hsbtoString = function () {
      return 'hsb(' + [
        this.h,
        this.s,
        this.b
      ] + ')';
    }, hsltoString = function () {
      return 'hsl(' + [
        this.h,
        this.s,
        this.l
      ] + ')';
    }, rgbtoString = function () {
      return this.hex;
    }, prepareRGB = function (r, g, b) {
      if (g == null && R.is(r, 'object') && 'r' in r && 'g' in r && 'b' in r) {
        b = r.b;
        g = r.g;
        r = r.r;
      }
      if (g == null && R.is(r, string)) {
        var clr = R.getRGB(r);
        r = clr.r;
        g = clr.g;
        b = clr.b;
      }
      if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
      }
      return [
        r,
        g,
        b
      ];
    }, packageRGB = function (r, g, b, o) {
      r *= 255;
      g *= 255;
      b *= 255;
      var rgb = {
          r: r,
          g: g,
          b: b,
          hex: R.rgb(r, g, b),
          toString: rgbtoString
        };
      R.is(o, 'finite') && (rgb.opacity = o);
      return rgb;
    };
  /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) `true` if string can’t be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
  R.color = function (clr) {
    var rgb;
    if (R.is(clr, 'object') && 'h' in clr && 's' in clr && 'b' in clr) {
      rgb = R.hsb2rgb(clr);
      clr.r = rgb.r;
      clr.g = rgb.g;
      clr.b = rgb.b;
      clr.hex = rgb.hex;
    } else if (R.is(clr, 'object') && 'h' in clr && 's' in clr && 'l' in clr) {
      rgb = R.hsl2rgb(clr);
      clr.r = rgb.r;
      clr.g = rgb.g;
      clr.b = rgb.b;
      clr.hex = rgb.hex;
    } else {
      if (R.is(clr, 'string')) {
        clr = R.getRGB(clr);
      }
      if (R.is(clr, 'object') && 'r' in clr && 'g' in clr && 'b' in clr) {
        rgb = R.rgb2hsl(clr);
        clr.h = rgb.h;
        clr.s = rgb.s;
        clr.l = rgb.l;
        rgb = R.rgb2hsb(clr);
        clr.v = rgb.b;
      } else {
        clr = { hex: 'none' };
        clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
      }
    }
    clr.toString = rgbtoString;
    return clr;
  };
  /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
    \*/
  R.hsb2rgb = function (h, s, v, o) {
    if (this.is(h, 'object') && 'h' in h && 's' in h && 'b' in h) {
      v = h.b;
      s = h.s;
      o = h.o;
      h = h.h;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = v * s;
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = v - C;
    h = ~~h;
    R += [
      C,
      X,
      0,
      0,
      X,
      C
    ][h];
    G += [
      X,
      C,
      C,
      X,
      0,
      0
    ][h];
    B += [
      0,
      0,
      X,
      C,
      C,
      X
    ][h];
    return packageRGB(R, G, B, o);
  };
  /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
    \*/
  R.hsl2rgb = function (h, s, l, o) {
    if (this.is(h, 'object') && 'h' in h && 's' in h && 'l' in h) {
      l = h.l;
      s = h.s;
      h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
      h /= 360;
      s /= 100;
      l /= 100;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = 2 * s * (l < 0.5 ? l : 1 - l);
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = l - C / 2;
    h = ~~h;
    R += [
      C,
      X,
      0,
      0,
      X,
      C
    ][h];
    G += [
      X,
      C,
      C,
      X,
      0,
      0
    ][h];
    B += [
      0,
      0,
      X,
      C,
      C,
      X
    ][h];
    return packageRGB(R, G, B, o);
  };
  /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
  R.rgb2hsb = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];
    var H, S, V, C;
    V = mmax(r, g, b);
    C = V - mmin(r, g, b);
    H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    S = C == 0 ? 0 : C / V;
    return {
      h: H,
      s: S,
      b: V,
      toString: hsbtoString
    };
  };
  /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
  R.rgb2hsl = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];
    var H, S, L, M, m, C;
    M = mmax(r, g, b);
    m = mmin(r, g, b);
    C = M - m;
    H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    L = (M + m) / 2;
    S = C == 0 ? 0 : L < 0.5 ? C / (2 * L) : C / (2 - 2 * L);
    return {
      h: H,
      s: S,
      l: L,
      toString: hsltoString
    };
  };
  R._path2string = function () {
    return this.join(',').replace(p2s, '$1');
  };
  function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++)
      if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
      }
  }
  function cacher(f, scope, postprocessor) {
    function newf() {
      var arg = Array.prototype.slice.call(arguments, 0), args = arg.join('\u2400'), cache = newf.cache = newf.cache || {}, count = newf.count = newf.count || [];
      if (cache[has](args)) {
        repush(count, args);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
      }
      count.length >= 1000 && delete cache[count.shift()];
      count.push(args);
      cache[args] = f[apply](scope, arg);
      return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
  }
  var preload = R._preload = function (src, f) {
      var img = g.doc.createElement('img');
      img.style.cssText = 'position:absolute;left:-9999em;top:-9999em';
      img.onload = function () {
        f.call(this);
        this.onload = null;
        g.doc.body.removeChild(this);
      };
      img.onerror = function () {
        g.doc.body.removeChild(this);
      };
      g.doc.body.appendChild(img);
      img.src = src;
    };
  function clrToString() {
    return this.hex;
  }
  /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsl(•••, •••, •••) — same as hsb</li>
     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) true if string can’t be parsed
     o }
    \*/
  R.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf('-') + 1)) {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: 'none',
        error: 1,
        toString: clrToString
      };
    }
    if (colour == 'none') {
      return {
        r: -1,
        g: -1,
        b: -1,
        hex: 'none',
        toString: clrToString
      };
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == '#') && (colour = toHex(colour));
    var res, red, green, blue, opacity, t, values, rgb = colour.match(colourRegExp);
    if (rgb) {
      if (rgb[2]) {
        blue = toInt(rgb[2].substring(5), 16);
        green = toInt(rgb[2].substring(3, 5), 16);
        red = toInt(rgb[2].substring(1, 3), 16);
      }
      if (rgb[3]) {
        blue = toInt((t = rgb[3].charAt(3)) + t, 16);
        green = toInt((t = rgb[3].charAt(2)) + t, 16);
        red = toInt((t = rgb[3].charAt(1)) + t, 16);
      }
      if (rgb[4]) {
        values = rgb[4][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == '%' && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == '%' && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == '%' && (blue *= 2.55);
        rgb[1].toLowerCase().slice(0, 4) == 'rgba' && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
      }
      if (rgb[5]) {
        values = rgb[5][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == '%' && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == '%' && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == '%' && (blue *= 2.55);
        (values[0].slice(-3) == 'deg' || values[0].slice(-1) == '\xb0') && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == 'hsba' && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
        return R.hsb2rgb(red, green, blue, opacity);
      }
      if (rgb[6]) {
        values = rgb[6][split](commaSpaces);
        red = toFloat(values[0]);
        values[0].slice(-1) == '%' && (red *= 2.55);
        green = toFloat(values[1]);
        values[1].slice(-1) == '%' && (green *= 2.55);
        blue = toFloat(values[2]);
        values[2].slice(-1) == '%' && (blue *= 2.55);
        (values[0].slice(-3) == 'deg' || values[0].slice(-1) == '\xb0') && (red /= 360);
        rgb[1].toLowerCase().slice(0, 4) == 'hsla' && (opacity = toFloat(values[3]));
        values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
        return R.hsl2rgb(red, green, blue, opacity);
      }
      rgb = {
        r: red,
        g: green,
        b: blue,
        toString: clrToString
      };
      rgb.hex = '#' + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
      R.is(opacity, 'finite') && (rgb.opacity = opacity);
      return rgb;
    }
    return {
      r: -1,
      g: -1,
      b: -1,
      hex: 'none',
      error: 1,
      toString: clrToString
    };
  }, R);
  /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
  R.hsb = cacher(function (h, s, b) {
    return R.hsb2rgb(h, s, b).hex;
  });
  /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
  R.hsl = cacher(function (h, s, l) {
    return R.hsl2rgb(h, s, l).hex;
  });
  /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
  R.rgb = cacher(function (r, g, b) {
    return '#' + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
  });
  /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
  R.getColor = function (value) {
    var start = this.getColor.start = this.getColor.start || {
        h: 0,
        s: 1,
        b: value || 0.75
      }, rgb = this.hsb2rgb(start.h, start.s, start.b);
    start.h += 0.075;
    if (start.h > 1) {
      start.h = 0;
      start.s -= 0.2;
      start.s <= 0 && (this.getColor.start = {
        h: 0,
        s: 1,
        b: start.b
      });
    }
    return rgb.hex;
  };
  /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
    \*/
  R.getColor.reset = function () {
    delete this.start;
  };
  // http://schepers.cc/getting-to-the-point
  function catmullRom2bezier(crp, z) {
    var d = [];
    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
      var p = [
          {
            x: +crp[i - 2],
            y: +crp[i - 1]
          },
          {
            x: +crp[i],
            y: +crp[i + 1]
          },
          {
            x: +crp[i + 2],
            y: +crp[i + 3]
          },
          {
            x: +crp[i + 4],
            y: +crp[i + 5]
          }
        ];
      if (z) {
        if (!i) {
          p[0] = {
            x: +crp[iLen - 2],
            y: +crp[iLen - 1]
          };
        } else if (iLen - 4 == i) {
          p[3] = {
            x: +crp[0],
            y: +crp[1]
          };
        } else if (iLen - 2 == i) {
          p[2] = {
            x: +crp[0],
            y: +crp[1]
          };
          p[3] = {
            x: +crp[2],
            y: +crp[3]
          };
        }
      } else {
        if (iLen - 4 == i) {
          p[3] = p[2];
        } else if (!i) {
          p[0] = {
            x: +crp[i],
            y: +crp[i + 1]
          };
        }
      }
      d.push([
        'C',
        (-p[0].x + 6 * p[1].x + p[2].x) / 6,
        (-p[0].y + 6 * p[1].y + p[2].y) / 6,
        (p[1].x + 6 * p[2].x - p[3].x) / 6,
        (p[1].y + 6 * p[2].y - p[3].y) / 6,
        p[2].x,
        p[2].y
      ]);
    }
    return d;
  }
  /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/
  R.parsePathString = function (pathString) {
    if (!pathString) {
      return null;
    }
    var pth = paths(pathString);
    if (pth.arr) {
      return pathClone(pth.arr);
    }
    var paramCounts = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
      }, data = [];
    if (R.is(pathString, array) && R.is(pathString[0], array)) {
      // rough assumption
      data = pathClone(pathString);
    }
    if (!data.length) {
      Str(pathString).replace(pathCommand, function (a, b, c) {
        var params = [], name = b.toLowerCase();
        c.replace(pathValues, function (a, b) {
          b && params.push(+b);
        });
        if (name == 'm' && params.length > 2) {
          data.push([b][concat](params.splice(0, 2)));
          name = 'l';
          b = b == 'm' ? 'l' : 'L';
        }
        if (name == 'r') {
          data.push([b][concat](params));
        } else
          while (params.length >= paramCounts[name]) {
            data.push([b][concat](params.splice(0, paramCounts[name])));
            if (!paramCounts[name]) {
              break;
            }
          }
      });
    }
    data.toString = R._path2string;
    pth.arr = pathClone(data);
    return data;
  };
  /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/
  R.parseTransformString = cacher(function (TString) {
    if (!TString) {
      return null;
    }
    var paramCounts = {
        r: 3,
        s: 4,
        t: 2,
        m: 6
      }, data = [];
    if (R.is(TString, array) && R.is(TString[0], array)) {
      // rough assumption
      data = pathClone(TString);
    }
    if (!data.length) {
      Str(TString).replace(tCommand, function (a, b, c) {
        var params = [], name = lowerCase.call(b);
        c.replace(pathValues, function (a, b) {
          b && params.push(+b);
        });
        data.push([b][concat](params));
      });
    }
    data.toString = R._path2string;
    return data;
  });
  // PATHS
  var paths = function (ps) {
    var p = paths.ps = paths.ps || {};
    if (p[ps]) {
      p[ps].sleep = 100;
    } else {
      p[ps] = { sleep: 100 };
    }
    setTimeout(function () {
      for (var key in p)
        if (p[has](key) && key != ps) {
          p[key].sleep--;
          !p[key].sleep && delete p[key];
        }
    });
    return p[ps];
  };
  /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
  R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t, t13 = pow(t1, 3), t12 = pow(t1, 2), t2 = t * t, t3 = t2 * t, x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x, y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y, mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x), my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y), nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x), ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y), ax = t1 * p1x + t * c1x, ay = t1 * p1y + t * c1y, cx = t1 * c2x + t * p2x, cy = t1 * c2y + t * p2y, alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
    (mx > nx || my < ny) && (alpha += 180);
    return {
      x: x,
      y: y,
      m: {
        x: mx,
        y: my
      },
      n: {
        x: nx,
        y: ny
      },
      start: {
        x: ax,
        y: ay
      },
      end: {
        x: cx,
        y: cy
      },
      alpha: alpha
    };
  };
  /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/
  R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!R.is(p1x, 'array')) {
      p1x = [
        p1x,
        p1y,
        c1x,
        c1y,
        c2x,
        c2y,
        p2x,
        p2y
      ];
    }
    var bbox = curveDim.apply(null, p1x);
    return {
      x: bbox.min.x,
      y: bbox.min.y,
      x2: bbox.max.x,
      y2: bbox.max.y,
      width: bbox.max.x - bbox.min.x,
      height: bbox.max.y - bbox.min.y
    };
  };
  /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/
  R.isPointInsideBBox = function (bbox, x, y) {
    return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
  };
  /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/
  R.isBBoxIntersect = function (bbox1, bbox2) {
    var i = R.isPointInsideBBox;
    return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
  };
  function base3(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4, t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
  }
  function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z == null) {
      z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2, n = 12, Tvalues = [
        -0.1252,
        0.1252,
        -0.3678,
        0.3678,
        -0.5873,
        0.5873,
        -0.7699,
        0.7699,
        -0.9041,
        0.9041,
        -0.9816,
        0.9816
      ], Cvalues = [
        0.2491,
        0.2491,
        0.2335,
        0.2335,
        0.2032,
        0.2032,
        0.1601,
        0.1601,
        0.1069,
        0.1069,
        0.0472,
        0.0472
      ], sum = 0;
    for (var i = 0; i < n; i++) {
      var ct = z2 * Tvalues[i] + z2, xbase = base3(ct, x1, x2, x3, x4), ybase = base3(ct, y1, y2, y3, y4), comb = xbase * xbase + ybase * ybase;
      sum += Cvalues[i] * math.sqrt(comb);
    }
    return z2 * sum;
  }
  function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
    if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
      return;
    }
    var t = 1, step = t / 2, t2 = t - step, l, e = 0.01;
    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    while (abs(l - ll) > e) {
      step /= 2;
      t2 += (l < ll ? 1 : -1) * step;
      l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    }
    return t2;
  }
  function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
    if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
      return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
      return;
    }
    var px = nx / denominator, py = ny / denominator, px2 = +px.toFixed(2), py2 = +py.toFixed(2);
    if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
      return;
    }
    return {
      x: px,
      y: py
    };
  }
  function inter(bez1, bez2) {
    return interHelper(bez1, bez2);
  }
  function interCount(bez1, bez2) {
    return interHelper(bez1, bez2, 1);
  }
  function interHelper(bez1, bez2, justCount) {
    var bbox1 = R.bezierBBox(bez1), bbox2 = R.bezierBBox(bez2);
    if (!R.isBBoxIntersect(bbox1, bbox2)) {
      return justCount ? 0 : [];
    }
    var l1 = bezlen.apply(0, bez1), l2 = bezlen.apply(0, bez2), n1 = mmax(~~(l1 / 5), 1), n2 = mmax(~~(l2 / 5), 1), dots1 = [], dots2 = [], xy = {}, res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
      var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
      dots1.push({
        x: p.x,
        y: p.y,
        t: i / n1
      });
    }
    for (i = 0; i < n2 + 1; i++) {
      p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
      dots2.push({
        x: p.x,
        y: p.y,
        t: i / n2
      });
    }
    for (i = 0; i < n1; i++) {
      for (var j = 0; j < n2; j++) {
        var di = dots1[i], di1 = dots1[i + 1], dj = dots2[j], dj1 = dots2[j + 1], ci = abs(di1.x - di.x) < 0.001 ? 'y' : 'x', cj = abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x', is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
        if (is) {
          if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
            continue;
          }
          xy[is.x.toFixed(4)] = is.y.toFixed(4);
          var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
          if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
            if (justCount) {
              res++;
            } else {
              res.push({
                x: is.x,
                y: is.y,
                t1: mmin(t1, 1),
                t2: mmin(t2, 1)
              });
            }
          }
        }
      }
    }
    return res;
  }
  /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/
  R.pathIntersection = function (path1, path2) {
    return interPathHelper(path1, path2);
  };
  R.pathIntersectionNumber = function (path1, path2) {
    return interPathHelper(path1, path2, 1);
  };
  function interPathHelper(path1, path2, justCount) {
    path1 = R._path2curve(path1);
    path2 = R._path2curve(path2);
    var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2, res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
      var pi = path1[i];
      if (pi[0] == 'M') {
        x1 = x1m = pi[1];
        y1 = y1m = pi[2];
      } else {
        if (pi[0] == 'C') {
          bez1 = [
            x1,
            y1
          ].concat(pi.slice(1));
          x1 = bez1[6];
          y1 = bez1[7];
        } else {
          bez1 = [
            x1,
            y1,
            x1,
            y1,
            x1m,
            y1m,
            x1m,
            y1m
          ];
          x1 = x1m;
          y1 = y1m;
        }
        for (var j = 0, jj = path2.length; j < jj; j++) {
          var pj = path2[j];
          if (pj[0] == 'M') {
            x2 = x2m = pj[1];
            y2 = y2m = pj[2];
          } else {
            if (pj[0] == 'C') {
              bez2 = [
                x2,
                y2
              ].concat(pj.slice(1));
              x2 = bez2[6];
              y2 = bez2[7];
            } else {
              bez2 = [
                x2,
                y2,
                x2,
                y2,
                x2m,
                y2m,
                x2m,
                y2m
              ];
              x2 = x2m;
              y2 = y2m;
            }
            var intr = interHelper(bez1, bez2, justCount);
            if (justCount) {
              res += intr;
            } else {
              for (var k = 0, kk = intr.length; k < kk; k++) {
                intr[k].segment1 = i;
                intr[k].segment2 = j;
                intr[k].bez1 = bez1;
                intr[k].bez2 = bez2;
              }
              res = res.concat(intr);
            }
          }
        }
      }
    }
    return res;
  }
  /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/
  R.isPointInsidePath = function (path, x, y) {
    var bbox = R.pathBBox(path);
    return R.isPointInsideBBox(bbox, x, y) && interPathHelper(path, [
      [
        'M',
        x,
        y
      ],
      [
        'H',
        bbox.x2 + 10
      ]
    ], 1) % 2 == 1;
  };
  R._removedFactory = function (methodname) {
    return function () {
      eve('raphael.log', null, 'Rapha\xebl: you are calling to method \u201c' + methodname + '\u201d of removed object', methodname);
    };
  };
  /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/
  var pathDimensions = R.pathBBox = function (path) {
      var pth = paths(path);
      if (pth.bbox) {
        return clone(pth.bbox);
      }
      if (!path) {
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          x2: 0,
          y2: 0
        };
      }
      path = path2curve(path);
      var x = 0, y = 0, X = [], Y = [], p;
      for (var i = 0, ii = path.length; i < ii; i++) {
        p = path[i];
        if (p[0] == 'M') {
          x = p[1];
          y = p[2];
          X.push(x);
          Y.push(y);
        } else {
          var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
          X = X[concat](dim.min.x, dim.max.x);
          Y = Y[concat](dim.min.y, dim.max.y);
          x = p[5];
          y = p[6];
        }
      }
      var xmin = mmin[apply](0, X), ymin = mmin[apply](0, Y), xmax = mmax[apply](0, X), ymax = mmax[apply](0, Y), width = xmax - xmin, height = ymax - ymin, bb = {
          x: xmin,
          y: ymin,
          x2: xmax,
          y2: ymax,
          width: width,
          height: height,
          cx: xmin + width / 2,
          cy: ymin + height / 2
        };
      pth.bbox = clone(bb);
      return bb;
    }, pathClone = function (pathArray) {
      var res = clone(pathArray);
      res.toString = R._path2string;
      return res;
    }, pathToRelative = R._pathToRelative = function (pathArray) {
      var pth = paths(pathArray);
      if (pth.rel) {
        return pathClone(pth.rel);
      }
      if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
      }
      var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0;
      if (pathArray[0][0] == 'M') {
        x = pathArray[0][1];
        y = pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res.push([
          'M',
          x,
          y
        ]);
      }
      for (var i = start, ii = pathArray.length; i < ii; i++) {
        var r = res[i] = [], pa = pathArray[i];
        if (pa[0] != lowerCase.call(pa[0])) {
          r[0] = lowerCase.call(pa[0]);
          switch (r[0]) {
          case 'a':
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] - x).toFixed(3);
            r[7] = +(pa[7] - y).toFixed(3);
            break;
          case 'v':
            r[1] = +(pa[1] - y).toFixed(3);
            break;
          case 'm':
            mx = pa[1];
            my = pa[2];
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
            }
          }
        } else {
          r = res[i] = [];
          if (pa[0] == 'm') {
            mx = pa[1] + x;
            my = pa[2] + y;
          }
          for (var k = 0, kk = pa.length; k < kk; k++) {
            res[i][k] = pa[k];
          }
        }
        var len = res[i].length;
        switch (res[i][0]) {
        case 'z':
          x = mx;
          y = my;
          break;
        case 'h':
          x += +res[i][len - 1];
          break;
        case 'v':
          y += +res[i][len - 1];
          break;
        default:
          x += +res[i][len - 2];
          y += +res[i][len - 1];
        }
      }
      res.toString = R._path2string;
      pth.rel = pathClone(res);
      return res;
    }, pathToAbsolute = R._pathToAbsolute = function (pathArray) {
      var pth = paths(pathArray);
      if (pth.abs) {
        return pathClone(pth.abs);
      }
      if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) {
        // rough assumption
        pathArray = R.parsePathString(pathArray);
      }
      if (!pathArray || !pathArray.length) {
        return [[
            'M',
            0,
            0
          ]];
      }
      var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0;
      if (pathArray[0][0] == 'M') {
        x = +pathArray[0][1];
        y = +pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res[0] = [
          'M',
          x,
          y
        ];
      }
      var crz = pathArray.length == 3 && pathArray[0][0] == 'M' && pathArray[1][0].toUpperCase() == 'R' && pathArray[2][0].toUpperCase() == 'Z';
      for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
        res.push(r = []);
        pa = pathArray[i];
        if (pa[0] != upperCase.call(pa[0])) {
          r[0] = upperCase.call(pa[0]);
          switch (r[0]) {
          case 'A':
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] + x);
            r[7] = +(pa[7] + y);
            break;
          case 'V':
            r[1] = +pa[1] + y;
            break;
          case 'H':
            r[1] = +pa[1] + x;
            break;
          case 'R':
            var dots = [
                x,
                y
              ][concat](pa.slice(1));
            for (var j = 2, jj = dots.length; j < jj; j++) {
              dots[j] = +dots[j] + x;
              dots[++j] = +dots[j] + y;
            }
            res.pop();
            res = res[concat](catmullRom2bezier(dots, crz));
            break;
          case 'M':
            mx = +pa[1] + x;
            my = +pa[2] + y;
          default:
            for (j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
          }
        } else if (pa[0] == 'R') {
          dots = [
            x,
            y
          ][concat](pa.slice(1));
          res.pop();
          res = res[concat](catmullRom2bezier(dots, crz));
          r = ['R'][concat](pa.slice(-2));
        } else {
          for (var k = 0, kk = pa.length; k < kk; k++) {
            r[k] = pa[k];
          }
        }
        switch (r[0]) {
        case 'Z':
          x = mx;
          y = my;
          break;
        case 'H':
          x = r[1];
          break;
        case 'V':
          y = r[1];
          break;
        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
        }
      }
      res.toString = R._path2string;
      pth.abs = pathClone(res);
      return res;
    }, l2c = function (x1, y1, x2, y2) {
      return [
        x1,
        y1,
        x2,
        y2,
        x2,
        y2
      ];
    }, q2c = function (x1, y1, ax, ay, x2, y2) {
      var _13 = 1 / 3, _23 = 2 / 3;
      return [
        _13 * x1 + _23 * ax,
        _13 * y1 + _23 * ay,
        _13 * x2 + _23 * ax,
        _13 * y2 + _23 * ay,
        x2,
        y2
      ];
    }, a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
      // for more information of where this math came from visit:
      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
      var _120 = PI * 120 / 180, rad = PI / 180 * (+angle || 0), res = [], xy, rotate = cacher(function (x, y, rad) {
          var X = x * math.cos(rad) - y * math.sin(rad), Y = x * math.sin(rad) + y * math.cos(rad);
          return {
            x: X,
            y: Y
          };
        });
      if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x;
        y1 = xy.y;
        xy = rotate(x2, y2, -rad);
        x2 = xy.x;
        y2 = xy.y;
        var cos = math.cos(PI / 180 * angle), sin = math.sin(PI / 180 * angle), x = (x1 - x2) / 2, y = (y1 - y2) / 2;
        var h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
          h = math.sqrt(h);
          rx = h * rx;
          ry = h * ry;
        }
        var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / 2, cy = k * -ry * x / rx + (y1 + y2) / 2, f1 = math.asin(((y1 - cy) / ry).toFixed(9)), f2 = math.asin(((y2 - cy) / ry).toFixed(9));
        f1 = x1 < cx ? PI - f1 : f1;
        f2 = x2 < cx ? PI - f2 : f2;
        f1 < 0 && (f1 = PI * 2 + f1);
        f2 < 0 && (f2 = PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
          f1 = f1 - PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
          f2 = f2 - PI * 2;
        }
      } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f2 - f1;
      if (abs(df) > _120) {
        var f2old = f2, x2old = x2, y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * math.cos(f2);
        y2 = cy + ry * math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
          f2,
          f2old,
          cx,
          cy
        ]);
      }
      df = f2 - f1;
      var c1 = math.cos(f1), s1 = math.sin(f1), c2 = math.cos(f2), s2 = math.sin(f2), t = math.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m1 = [
          x1,
          y1
        ], m2 = [
          x1 + hx * s1,
          y1 - hy * c1
        ], m3 = [
          x2 + hx * s2,
          y2 - hy * c2
        ], m4 = [
          x2,
          y2
        ];
      m2[0] = 2 * m1[0] - m2[0];
      m2[1] = 2 * m1[1] - m2[1];
      if (recursive) {
        return [
          m2,
          m3,
          m4
        ][concat](res);
      } else {
        res = [
          m2,
          m3,
          m4
        ][concat](res).join()[split](',');
        var newres = [];
        for (var i = 0, ii = res.length; i < ii; i++) {
          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        }
        return newres;
      }
    }, findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
      var t1 = 1 - t;
      return {
        x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
        y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
      };
    }, curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
      var a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x), b = 2 * (c1x - p1x) - 2 * (c2x - c1x), c = p1x - c1x, t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a, t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a, y = [
          p1y,
          p2y
        ], x = [
          p1x,
          p2x
        ], dot;
      abs(t1) > '1e12' && (t1 = 0.5);
      abs(t2) > '1e12' && (t2 = 0.5);
      if (t1 > 0 && t1 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
        x.push(dot.x);
        y.push(dot.y);
      }
      if (t2 > 0 && t2 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
        x.push(dot.x);
        y.push(dot.y);
      }
      a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
      b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
      c = p1y - c1y;
      t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
      t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
      abs(t1) > '1e12' && (t1 = 0.5);
      abs(t2) > '1e12' && (t2 = 0.5);
      if (t1 > 0 && t1 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
        x.push(dot.x);
        y.push(dot.y);
      }
      if (t2 > 0 && t2 < 1) {
        dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
        x.push(dot.x);
        y.push(dot.y);
      }
      return {
        min: {
          x: mmin[apply](0, x),
          y: mmin[apply](0, y)
        },
        max: {
          x: mmax[apply](0, x),
          y: mmax[apply](0, y)
        }
      };
    }), path2curve = R._path2curve = cacher(function (path, path2) {
      var pth = !path2 && paths(path);
      if (!path2 && pth.curve) {
        return pathClone(pth.curve);
      }
      var p = pathToAbsolute(path), p2 = path2 && pathToAbsolute(path2), attrs = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        }, attrs2 = {
          x: 0,
          y: 0,
          bx: 0,
          by: 0,
          X: 0,
          Y: 0,
          qx: null,
          qy: null
        }, processPath = function (path, d, pcom) {
          var nx, ny, tq = {
              T: 1,
              Q: 1
            };
          if (!path) {
            return [
              'C',
              d.x,
              d.y,
              d.x,
              d.y,
              d.x,
              d.y
            ];
          }
          !(path[0] in tq) && (d.qx = d.qy = null);
          switch (path[0]) {
          case 'M':
            d.X = path[1];
            d.Y = path[2];
            break;
          case 'A':
            path = ['C'][concat](a2c[apply](0, [
              d.x,
              d.y
            ][concat](path.slice(1))));
            break;
          case 'S':
            if (pcom == 'C' || pcom == 'S') {
              // In "S" case we have to take into account, if the previous command is C/S.
              nx = d.x * 2 - d.bx;
              // And reflect the previous
              ny = d.y * 2 - d.by;  // command's control point relative to the current point.
            } else {
              // or some else or nothing
              nx = d.x;
              ny = d.y;
            }
            path = [
              'C',
              nx,
              ny
            ][concat](path.slice(1));
            break;
          case 'T':
            if (pcom == 'Q' || pcom == 'T') {
              // In "T" case we have to take into account, if the previous command is Q/T.
              d.qx = d.x * 2 - d.qx;
              // And make a reflection similar
              d.qy = d.y * 2 - d.qy;  // to case "S".
            } else {
              // or something else or nothing
              d.qx = d.x;
              d.qy = d.y;
            }
            path = ['C'][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
            break;
          case 'Q':
            d.qx = path[1];
            d.qy = path[2];
            path = ['C'][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
            break;
          case 'L':
            path = ['C'][concat](l2c(d.x, d.y, path[1], path[2]));
            break;
          case 'H':
            path = ['C'][concat](l2c(d.x, d.y, path[1], d.y));
            break;
          case 'V':
            path = ['C'][concat](l2c(d.x, d.y, d.x, path[1]));
            break;
          case 'Z':
            path = ['C'][concat](l2c(d.x, d.y, d.X, d.Y));
            break;
          }
          return path;
        }, fixArc = function (pp, i) {
          if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];
            while (pi.length) {
              pcoms1[i] = 'A';
              // if created multiple C:s, their original seg is saved
              p2 && (pcoms2[i] = 'A');
              // the same as above
              pp.splice(i++, 0, ['C'][concat](pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = mmax(p.length, p2 && p2.length || 0);
          }
        }, fixM = function (path1, path2, a1, a2, i) {
          if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
            path2.splice(i, 0, [
              'M',
              a2.x,
              a2.y
            ]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = mmax(p.length, p2 && p2.length || 0);
          }
        }, pcoms1 = [],
        // path commands of original path p
        pcoms2 = [],
        // path commands of original path p2
        pfirst = '',
        // temporary holder for original path command
        pcom = '';
      // holder for previous path command of original path
      for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
        p[i] && (pfirst = p[i][0]);
        // save current path command
        if (pfirst != 'C')
          // C is not saved yet, because it may be result of conversion
          {
            pcoms1[i] = pfirst;
            // Save current path command
            i && (pcom = pcoms1[i - 1]);  // Get previous path command pcom
          }
        p[i] = processPath(p[i], attrs, pcom);
        // Previous path command is inputted to processPath
        if (pcoms1[i] != 'A' && pfirst == 'C')
          pcoms1[i] = 'C';
        // A is the only command
        // which may produce multiple C:s
        // so we have to make sure that C is also C in original path
        fixArc(p, i);
        // fixArc adds also the right amount of A:s to pcoms1
        if (p2) {
          // the same procedures is done to p2
          p2[i] && (pfirst = p2[i][0]);
          if (pfirst != 'C') {
            pcoms2[i] = pfirst;
            i && (pcom = pcoms2[i - 1]);
          }
          p2[i] = processPath(p2[i], attrs2, pcom);
          if (pcoms2[i] != 'A' && pfirst == 'C')
            pcoms2[i] = 'C';
          fixArc(p2, i);
        }
        fixM(p, p2, attrs, attrs2, i);
        fixM(p2, p, attrs2, attrs, i);
        var seg = p[i], seg2 = p2 && p2[i], seglen = seg.length, seg2len = p2 && seg2.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
        attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
        attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
        attrs2.x = p2 && seg2[seg2len - 2];
        attrs2.y = p2 && seg2[seg2len - 1];
      }
      if (!p2) {
        pth.curve = pathClone(p);
      }
      return p2 ? [
        p,
        p2
      ] : p;
    }, null, pathClone), parseDots = R._parseDots = cacher(function (gradient) {
      var dots = [];
      for (var i = 0, ii = gradient.length; i < ii; i++) {
        var dot = {}, par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
        dot.color = R.getRGB(par[1]);
        if (dot.color.error) {
          return null;
        }
        dot.color = dot.color.hex;
        par[2] && (dot.offset = par[2] + '%');
        dots.push(dot);
      }
      for (i = 1, ii = dots.length - 1; i < ii; i++) {
        if (!dots[i].offset) {
          var start = toFloat(dots[i - 1].offset || 0), end = 0;
          for (var j = i + 1; j < ii; j++) {
            if (dots[j].offset) {
              end = dots[j].offset;
              break;
            }
          }
          if (!end) {
            end = 100;
            j = ii;
          }
          end = toFloat(end);
          var d = (end - start) / (j - i + 1);
          for (; i < j; i++) {
            start += d;
            dots[i].offset = start + '%';
          }
        }
      }
      return dots;
    }), tear = R._tear = function (el, paper) {
      el == paper.top && (paper.top = el.prev);
      el == paper.bottom && (paper.bottom = el.next);
      el.next && (el.next.prev = el.prev);
      el.prev && (el.prev.next = el.next);
    }, tofront = R._tofront = function (el, paper) {
      if (paper.top === el) {
        return;
      }
      tear(el, paper);
      el.next = null;
      el.prev = paper.top;
      paper.top.next = el;
      paper.top = el;
    }, toback = R._toback = function (el, paper) {
      if (paper.bottom === el) {
        return;
      }
      tear(el, paper);
      el.next = paper.bottom;
      el.prev = null;
      paper.bottom.prev = el;
      paper.bottom = el;
    }, insertafter = R._insertafter = function (el, el2, paper) {
      tear(el, paper);
      el2 == paper.top && (paper.top = el);
      el2.next && (el2.next.prev = el);
      el.next = el2.next;
      el.prev = el2;
      el2.next = el;
    }, insertbefore = R._insertbefore = function (el, el2, paper) {
      tear(el, paper);
      el2 == paper.bottom && (paper.bottom = el);
      el2.prev && (el2.prev.next = el);
      el.prev = el2.prev;
      el2.prev = el;
      el.next = el2;
    },
    /*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/
    toMatrix = R.toMatrix = function (path, transform) {
      var bb = pathDimensions(path), el = {
          _: { transform: E },
          getBBox: function () {
            return bb;
          }
        };
      extractTransform(el, transform);
      return el.matrix;
    },
    /*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/
    transformPath = R.transformPath = function (path, transform) {
      return mapPath(path, toMatrix(path, transform));
    }, extractTransform = R._extractTransform = function (el, tstr) {
      if (tstr == null) {
        return el._.transform;
      }
      tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
      var tdata = R.parseTransformString(tstr), deg = 0, dx = 0, dy = 0, sx = 1, sy = 1, _ = el._, m = new Matrix();
      _.transform = tdata || [];
      if (tdata) {
        for (var i = 0, ii = tdata.length; i < ii; i++) {
          var t = tdata[i], tlen = t.length, command = Str(t[0]).toLowerCase(), absolute = t[0] != command, inver = absolute ? m.invert() : 0, x1, y1, x2, y2, bb;
          if (command == 't' && tlen == 3) {
            if (absolute) {
              x1 = inver.x(0, 0);
              y1 = inver.y(0, 0);
              x2 = inver.x(t[1], t[2]);
              y2 = inver.y(t[1], t[2]);
              m.translate(x2 - x1, y2 - y1);
            } else {
              m.translate(t[1], t[2]);
            }
          } else if (command == 'r') {
            if (tlen == 2) {
              bb = bb || el.getBBox(1);
              m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
              deg += t[1];
            } else if (tlen == 4) {
              if (absolute) {
                x2 = inver.x(t[2], t[3]);
                y2 = inver.y(t[2], t[3]);
                m.rotate(t[1], x2, y2);
              } else {
                m.rotate(t[1], t[2], t[3]);
              }
              deg += t[1];
            }
          } else if (command == 's') {
            if (tlen == 2 || tlen == 3) {
              bb = bb || el.getBBox(1);
              m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
              sx *= t[1];
              sy *= t[tlen - 1];
            } else if (tlen == 5) {
              if (absolute) {
                x2 = inver.x(t[3], t[4]);
                y2 = inver.y(t[3], t[4]);
                m.scale(t[1], t[2], x2, y2);
              } else {
                m.scale(t[1], t[2], t[3], t[4]);
              }
              sx *= t[1];
              sy *= t[2];
            }
          } else if (command == 'm' && tlen == 7) {
            m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
          }
          _.dirtyT = 1;
          el.matrix = m;
        }
      }
      /*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
            \*/
      el.matrix = m;
      _.sx = sx;
      _.sy = sy;
      _.deg = deg;
      _.dx = dx = m.e;
      _.dy = dy = m.f;
      if (sx == 1 && sy == 1 && !deg && _.bbox) {
        _.bbox.x += +dx;
        _.bbox.y += +dy;
      } else {
        _.dirtyT = 1;
      }
    }, getEmpty = function (item) {
      var l = item[0];
      switch (l.toLowerCase()) {
      case 't':
        return [
          l,
          0,
          0
        ];
      case 'm':
        return [
          l,
          1,
          0,
          0,
          1,
          0,
          0
        ];
      case 'r':
        if (item.length == 4) {
          return [
            l,
            0,
            item[2],
            item[3]
          ];
        } else {
          return [
            l,
            0
          ];
        }
      case 's':
        if (item.length == 5) {
          return [
            l,
            1,
            1,
            item[3],
            item[4]
          ];
        } else if (item.length == 3) {
          return [
            l,
            1,
            1
          ];
        } else {
          return [
            l,
            1
          ];
        }
      }
    }, equaliseTransform = R._equaliseTransform = function (t1, t2) {
      t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
      t1 = R.parseTransformString(t1) || [];
      t2 = R.parseTransformString(t2) || [];
      var maxlength = mmax(t1.length, t2.length), from = [], to = [], i = 0, j, jj, tt1, tt2;
      for (; i < maxlength; i++) {
        tt1 = t1[i] || getEmpty(t2[i]);
        tt2 = t2[i] || getEmpty(tt1);
        if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == 'r' && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == 's' && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {
          return;
        }
        from[i] = [];
        to[i] = [];
        for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
          j in tt1 && (from[i][j] = tt1[j]);
          j in tt2 && (to[i][j] = tt2[j]);
        }
      }
      return {
        from: from,
        to: to
      };
    };
  R._getContainer = function (x, y, w, h) {
    var container;
    container = h == null && !R.is(x, 'object') ? g.doc.getElementById(x) : x;
    if (container == null) {
      return;
    }
    if (container.tagName) {
      if (y == null) {
        return {
          container: container,
          width: container.style.pixelWidth || container.offsetWidth,
          height: container.style.pixelHeight || container.offsetHeight
        };
      } else {
        return {
          container: container,
          width: y,
          height: w
        };
      }
    }
    return {
      container: 1,
      x: x,
      y: y,
      width: w,
      height: h
    };
  };
  /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
  R.pathToRelative = pathToRelative;
  R._engine = {};
  /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
  R.path2curve = path2curve;
  /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/
  R.matrix = function (a, b, c, d, e, f) {
    return new Matrix(a, b, c, d, e, f);
  };
  function Matrix(a, b, c, d, e, f) {
    if (a != null) {
      this.a = +a;
      this.b = +b;
      this.c = +c;
      this.d = +d;
      this.e = +e;
      this.f = +f;
    } else {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.e = 0;
      this.f = 0;
    }
  }
  (function (matrixproto) {
    /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/
    matrixproto.add = function (a, b, c, d, e, f) {
      var out = [
          [],
          [],
          []
        ], m = [
          [
            this.a,
            this.c,
            this.e
          ],
          [
            this.b,
            this.d,
            this.f
          ],
          [
            0,
            0,
            1
          ]
        ], matrix = [
          [
            a,
            c,
            e
          ],
          [
            b,
            d,
            f
          ],
          [
            0,
            0,
            1
          ]
        ], x, y, z, res;
      if (a && a instanceof Matrix) {
        matrix = [
          [
            a.a,
            a.c,
            a.e
          ],
          [
            a.b,
            a.d,
            a.f
          ],
          [
            0,
            0,
            1
          ]
        ];
      }
      for (x = 0; x < 3; x++) {
        for (y = 0; y < 3; y++) {
          res = 0;
          for (z = 0; z < 3; z++) {
            res += m[x][z] * matrix[z][y];
          }
          out[x][y] = res;
        }
      }
      this.a = out[0][0];
      this.b = out[1][0];
      this.c = out[0][1];
      this.d = out[1][1];
      this.e = out[0][2];
      this.f = out[1][2];
    };
    /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/
    matrixproto.invert = function () {
      var me = this, x = me.a * me.d - me.b * me.c;
      return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
    };
    /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/
    matrixproto.clone = function () {
      return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
    };
    /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
        \*/
    matrixproto.translate = function (x, y) {
      this.add(1, 0, 0, 1, x, y);
    };
    /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/
    matrixproto.scale = function (x, y, cx, cy) {
      y == null && (y = x);
      (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
      this.add(x, 0, 0, y, 0, 0);
      (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
    };
    /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/
    matrixproto.rotate = function (a, x, y) {
      a = R.rad(a);
      x = x || 0;
      y = y || 0;
      var cos = +math.cos(a).toFixed(9), sin = +math.sin(a).toFixed(9);
      this.add(cos, sin, -sin, cos, x, y);
      this.add(1, 0, 0, 1, -x, -y);
    };
    /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/
    matrixproto.x = function (x, y) {
      return x * this.a + y * this.c + this.e;
    };
    /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/
    matrixproto.y = function (x, y) {
      return x * this.b + y * this.d + this.f;
    };
    matrixproto.get = function (i) {
      return +this[Str.fromCharCode(97 + i)].toFixed(4);
    };
    matrixproto.toString = function () {
      return R.svg ? 'matrix(' + [
        this.get(0),
        this.get(1),
        this.get(2),
        this.get(3),
        this.get(4),
        this.get(5)
      ].join() + ')' : [
        this.get(0),
        this.get(2),
        this.get(1),
        this.get(3),
        0,
        0
      ].join();
    };
    matrixproto.toFilter = function () {
      return 'progid:DXImageTransform.Microsoft.Matrix(M11=' + this.get(0) + ', M12=' + this.get(2) + ', M21=' + this.get(1) + ', M22=' + this.get(3) + ', Dx=' + this.get(4) + ', Dy=' + this.get(5) + ', sizingmethod=\'auto expand\')';
    };
    matrixproto.offset = function () {
      return [
        this.e.toFixed(4),
        this.f.toFixed(4)
      ];
    };
    function norm(a) {
      return a[0] * a[0] + a[1] * a[1];
    }
    function normalize(a) {
      var mag = math.sqrt(norm(a));
      a[0] && (a[0] /= mag);
      a[1] && (a[1] /= mag);
    }
    /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
    matrixproto.split = function () {
      var out = {};
      // translation
      out.dx = this.e;
      out.dy = this.f;
      // scale and shear
      var row = [
          [
            this.a,
            this.c
          ],
          [
            this.b,
            this.d
          ]
        ];
      out.scalex = math.sqrt(norm(row[0]));
      normalize(row[0]);
      out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
      row[1] = [
        row[1][0] - row[0][0] * out.shear,
        row[1][1] - row[0][1] * out.shear
      ];
      out.scaley = math.sqrt(norm(row[1]));
      normalize(row[1]);
      out.shear /= out.scaley;
      // rotation
      var sin = -row[0][1], cos = row[1][1];
      if (cos < 0) {
        out.rotate = R.deg(math.acos(cos));
        if (sin < 0) {
          out.rotate = 360 - out.rotate;
        }
      } else {
        out.rotate = R.deg(math.asin(sin));
      }
      out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
      out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
      out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
      return out;
    };
    /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/
    matrixproto.toTransformString = function (shorter) {
      var s = shorter || this[split]();
      if (s.isSimple) {
        s.scalex = +s.scalex.toFixed(4);
        s.scaley = +s.scaley.toFixed(4);
        s.rotate = +s.rotate.toFixed(4);
        return (s.dx || s.dy ? 't' + [
          s.dx,
          s.dy
        ] : E) + (s.scalex != 1 || s.scaley != 1 ? 's' + [
          s.scalex,
          s.scaley,
          0,
          0
        ] : E) + (s.rotate ? 'r' + [
          s.rotate,
          0,
          0
        ] : E);
      } else {
        return 'm' + [
          this.get(0),
          this.get(1),
          this.get(2),
          this.get(3),
          this.get(4),
          this.get(5)
        ];
      }
    };
  }(Matrix.prototype));
  // WebKit rendering bug workaround method
  var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
  if (navigator.vendor == 'Apple Computer, Inc.' && (version && version[1] < 4 || navigator.platform.slice(0, 2) == 'iP') || navigator.vendor == 'Google Inc.' && version && version[1] < 8) {
    /*\
         * Paper.safari
         [ method ]
         **
         * There is an inconvenient rendering bug in Safari (WebKit):
         * sometimes the rendering should be forced.
         * This method should help with dealing with this bug.
        \*/
    paperproto.safari = function () {
      var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({ stroke: 'none' });
      setTimeout(function () {
        rect.remove();
      });
    };
  } else {
    paperproto.safari = fun;
  }
  var preventDefault = function () {
      this.returnValue = false;
    }, preventTouch = function () {
      return this.originalEvent.preventDefault();
    }, stopPropagation = function () {
      this.cancelBubble = true;
    }, stopTouch = function () {
      return this.originalEvent.stopPropagation();
    }, getEventPosition = function (e) {
      var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop, scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
      return {
        x: e.clientX + scrollX,
        y: e.clientY + scrollY
      };
    }, addEvent = function () {
      if (g.doc.addEventListener) {
        return function (obj, type, fn, element) {
          var f = function (e) {
            var pos = getEventPosition(e);
            return fn.call(element, e, pos.x, pos.y);
          };
          obj.addEventListener(type, f, false);
          if (supportsTouch && touchMap[type]) {
            var _f = function (e) {
              var pos = getEventPosition(e), olde = e;
              for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                if (e.targetTouches[i].target == obj) {
                  e = e.targetTouches[i];
                  e.originalEvent = olde;
                  e.preventDefault = preventTouch;
                  e.stopPropagation = stopTouch;
                  break;
                }
              }
              return fn.call(element, e, pos.x, pos.y);
            };
            obj.addEventListener(touchMap[type], _f, false);
          }
          return function () {
            obj.removeEventListener(type, f, false);
            if (supportsTouch && touchMap[type])
              obj.removeEventListener(touchMap[type], _f, false);
            return true;
          };
        };
      } else if (g.doc.attachEvent) {
        return function (obj, type, fn, element) {
          var f = function (e) {
            e = e || g.win.event;
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop, scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft, x = e.clientX + scrollX, y = e.clientY + scrollY;
            e.preventDefault = e.preventDefault || preventDefault;
            e.stopPropagation = e.stopPropagation || stopPropagation;
            return fn.call(element, e, x, y);
          };
          obj.attachEvent('on' + type, f);
          var detacher = function () {
            obj.detachEvent('on' + type, f);
            return true;
          };
          return detacher;
        };
      }
    }(), drag = [], dragMove = function (e) {
      var x = e.clientX, y = e.clientY, scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop, scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft, dragi, j = drag.length;
      while (j--) {
        dragi = drag[j];
        if (supportsTouch && e.touches) {
          var i = e.touches.length, touch;
          while (i--) {
            touch = e.touches[i];
            if (touch.identifier == dragi.el._drag.id) {
              x = touch.clientX;
              y = touch.clientY;
              (e.originalEvent ? e.originalEvent : e).preventDefault();
              break;
            }
          }
        } else {
          e.preventDefault();
        }
        var node = dragi.el.node, o, next = node.nextSibling, parent = node.parentNode, display = node.style.display;
        g.win.opera && parent.removeChild(node);
        node.style.display = 'none';
        o = dragi.el.paper.getElementByPoint(x, y);
        node.style.display = display;
        g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
        o && eve('raphael.drag.over.' + dragi.el.id, dragi.el, o);
        x += scrollX;
        y += scrollY;
        eve('raphael.drag.move.' + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
      }
    }, dragUp = function (e) {
      R.unmousemove(dragMove).unmouseup(dragUp);
      var i = drag.length, dragi;
      while (i--) {
        dragi = drag[i];
        dragi.el._drag = {};
        eve('raphael.drag.end.' + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
      }
      drag = [];
    },
    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn’t affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \*/
    elproto = R.el = {};
  /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
  /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
  for (var i = events.length; i--;) {
    (function (eventName) {
      R[eventName] = elproto[eventName] = function (fn, scope) {
        if (R.is(fn, 'function')) {
          this.events = this.events || [];
          this.events.push({
            name: eventName,
            f: fn,
            unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
          });
        }
        return this;
      };
      R['un' + eventName] = elproto['un' + eventName] = function (fn) {
        var events = this.events || [], l = events.length;
        while (l--) {
          if (events[l].name == eventName && (R.is(fn, 'undefined') || events[l].f == fn)) {
            events[l].unbind();
            events.splice(l, 1);
            !events.length && delete this.events;
          }
        }
        return this;
      };
    }(events[i]));
  }
  /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
  elproto.data = function (key, value) {
    var data = eldata[this.id] = eldata[this.id] || {};
    if (arguments.length == 0) {
      return data;
    }
    if (arguments.length == 1) {
      if (R.is(key, 'object')) {
        for (var i in key)
          if (key[has](i)) {
            this.data(i, key[i]);
          }
        return this;
      }
      eve('raphael.data.get.' + this.id, this, data[key], key);
      return data[key];
    }
    data[key] = value;
    eve('raphael.data.set.' + this.id, this, value, key);
    return this;
  };
  /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
    \*/
  elproto.removeData = function (key) {
    if (key == null) {
      eldata[this.id] = {};
    } else {
      eldata[this.id] && delete eldata[this.id][key];
    }
    return this;
  };
  /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
    \*/
  elproto.getData = function () {
    return clone(eldata[this.id] || {});
  };
  /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
  elproto.hover = function (f_in, f_out, scope_in, scope_out) {
    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
  };
  /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
  elproto.unhover = function (f_in, f_out) {
    return this.unmouseover(f_in).unmouseout(f_out);
  };
  var draggable = [];
  /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
  elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
    function start(e) {
      (e.originalEvent || e).preventDefault();
      var x = e.clientX, y = e.clientY, scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop, scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
      this._drag.id = e.identifier;
      if (supportsTouch && e.touches) {
        var i = e.touches.length, touch;
        while (i--) {
          touch = e.touches[i];
          this._drag.id = touch.identifier;
          if (touch.identifier == this._drag.id) {
            x = touch.clientX;
            y = touch.clientY;
            break;
          }
        }
      }
      this._drag.x = x + scrollX;
      this._drag.y = y + scrollY;
      !drag.length && R.mousemove(dragMove).mouseup(dragUp);
      drag.push({
        el: this,
        move_scope: move_scope,
        start_scope: start_scope,
        end_scope: end_scope
      });
      onstart && eve.on('raphael.drag.start.' + this.id, onstart);
      onmove && eve.on('raphael.drag.move.' + this.id, onmove);
      onend && eve.on('raphael.drag.end.' + this.id, onend);
      eve('raphael.drag.start.' + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
    }
    this._drag = {};
    draggable.push({
      el: this,
      start: start
    });
    this.mousedown(start);
    return this;
  };
  /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
  elproto.onDragOver = function (f) {
    f ? eve.on('raphael.drag.over.' + this.id, f) : eve.unbind('raphael.drag.over.' + this.id);
  };
  /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/
  elproto.undrag = function () {
    var i = draggable.length;
    while (i--)
      if (draggable[i].el == this) {
        this.unmousedown(draggable[i].start);
        draggable.splice(i, 1);
        eve.unbind('raphael.drag.*.' + this.id);
      }
    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
    drag = [];
  };
  /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphaël element object with type “circle”
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
  paperproto.circle = function (x, y, r) {
    var out = R._engine.circle(this, x || 0, y || 0, r || 0);
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphaël element object with type “rect”
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
  paperproto.rect = function (x, y, w, h, r) {
    var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphaël element object with type “ellipse”
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
  paperproto.ellipse = function (x, y, rx, ry) {
    var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/
  paperproto.path = function (pathString) {
    pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
    var out = R._engine.path(R.format[apply](R, arguments), this);
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphaël element object with type “image”
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
  paperproto.image = function (src, x, y, w, h) {
    var out = R._engine.image(this, src || 'about:blank', x || 0, y || 0, w || 0, h || 0);
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put “\n” in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphaël element object with type “text”
     **
     > Usage
     | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
    \*/
  paperproto.text = function (x, y, text) {
    var out = R._engine.text(this, x || 0, y || 0, Str(text));
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements — all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
  paperproto.set = function (itemsArray) {
    !R.is(itemsArray, 'array') && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
    var out = new Set(itemsArray);
    this.__set__ && this.__set__.push(out);
    out['paper'] = this;
    out['type'] = 'set';
    return out;
  };
  /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
  paperproto.setStart = function (set) {
    this.__set__ = set || this.set();
  };
  /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/
  paperproto.setFinish = function (set) {
    var out = this.__set__;
    delete this.__set__;
    return out;
  };
  /*\
     * Paper.getSize
     [ method ]
     **
     * Obtains current paper actual size.
     **
     = (object)
     \*/
  paperproto.getSize = function () {
    var container = this.canvas.parentNode;
    return {
      width: container.offsetWidth,
      height: container.offsetHeight
    };
  };
  /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/
  paperproto.setSize = function (width, height) {
    return R._engine.setSize.call(this, width, height);
  };
  /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/
  paperproto.setViewBox = function (x, y, w, h, fit) {
    return R._engine.setViewBox.call(this, x, y, w, h, fit);
  };
  /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/
  /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/
  paperproto.top = paperproto.bottom = null;
  /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/
  paperproto.raphael = R;
  var getOffset = function (elem) {
    var box = elem.getBoundingClientRect(), doc = elem.ownerDocument, body = doc.body, docElem = doc.documentElement, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop, left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
    return {
      y: top,
      x: left
    };
  };
  /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphaël element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
  paperproto.getElementByPoint = function (x, y) {
    var paper = this, svg = paper.canvas, target = g.doc.elementFromPoint(x, y);
    if (g.win.opera && target.tagName == 'svg') {
      var so = getOffset(svg), sr = svg.createSVGRect();
      sr.x = x - so.x;
      sr.y = y - so.y;
      sr.width = sr.height = 1;
      var hits = svg.getIntersectionList(sr, null);
      if (hits.length) {
        target = hits[hits.length - 1];
      }
    }
    if (!target) {
      return null;
    }
    while (target.parentNode && target != svg.parentNode && !target.raphael) {
      target = target.parentNode;
    }
    target == paper.canvas.parentNode && (target = svg);
    target = target && target.raphael ? paper.getById(target.raphaelid) : null;
    return target;
  };
  /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
  paperproto.getElementsByBBox = function (bbox) {
    var set = this.set();
    this.forEach(function (el) {
      if (R.isBBoxIntersect(el.getBBox(), bbox)) {
        set.push(el);
      }
    });
    return set;
  };
  /*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     > Parameters
     **
     - id (number) id
     = (object) Raphaël element object
    \*/
  paperproto.getById = function (id) {
    var bot = this.bottom;
    while (bot) {
      if (bot.id == id) {
        return bot;
      }
      bot = bot.next;
    }
    return null;
  };
  /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/
  paperproto.forEach = function (callback, thisArg) {
    var bot = this.bottom;
    while (bot) {
      if (callback.call(thisArg, bot) === false) {
        return this;
      }
      bot = bot.next;
    }
    return this;
  };
  /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/
  paperproto.getElementsByPoint = function (x, y) {
    var set = this.set();
    this.forEach(function (el) {
      if (el.isPointInside(x, y)) {
        set.push(el);
      }
    });
    return set;
  };
  function x_y() {
    return this.x + S + this.y;
  }
  function x_y_w_h() {
    return this.x + S + this.y + S + this.width + ' \xd7 ' + this.height;
  }
  /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element’s shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/
  elproto.isPointInside = function (x, y) {
    var rp = this.realPath = getPath[this.type](this);
    if (this.attr('transform') && this.attr('transform').length) {
      rp = R.transformPath(rp, this.attr('transform'));
    }
    return R.isPointInsidePath(rp, x, y);
  };
  /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/
  elproto.getBBox = function (isWithoutTransform) {
    if (this.removed) {
      return {};
    }
    var _ = this._;
    if (isWithoutTransform) {
      if (_.dirty || !_.bboxwt) {
        this.realPath = getPath[this.type](this);
        _.bboxwt = pathDimensions(this.realPath);
        _.bboxwt.toString = x_y_w_h;
        _.dirty = 0;
      }
      return _.bboxwt;
    }
    if (_.dirty || _.dirtyT || !_.bbox) {
      if (_.dirty || !this.realPath) {
        _.bboxwt = 0;
        this.realPath = getPath[this.type](this);
      }
      _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
      _.bbox.toString = x_y_w_h;
      _.dirty = _.dirtyT = 0;
    }
    return _.bbox;
  };
  /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/
  elproto.clone = function () {
    if (this.removed) {
      return null;
    }
    var out = this.paper[this.type]().attr(this.attr());
    this.__set__ && this.__set__.push(out);
    return out;
  };
  /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/
  elproto.glow = function (glow) {
    if (this.type == 'text') {
      return null;
    }
    glow = glow || {};
    var s = {
        width: (glow.width || 10) + (+this.attr('stroke-width') || 1),
        fill: glow.fill || false,
        opacity: glow.opacity || 0.5,
        offsetx: glow.offsetx || 0,
        offsety: glow.offsety || 0,
        color: glow.color || '#000'
      }, c = s.width / 2, r = this.paper, out = r.set(), path = this.realPath || getPath[this.type](this);
    path = this.matrix ? mapPath(path, this.matrix) : path;
    for (var i = 1; i < c + 1; i++) {
      out.push(r.path(path).attr({
        stroke: s.color,
        fill: s.fill ? s.color : 'none',
        'stroke-linejoin': 'round',
        'stroke-linecap': 'round',
        'stroke-width': +(s.width / c * i).toFixed(3),
        opacity: +(s.opacity / c).toFixed(3)
      }));
    }
    return out.insertBefore(this).translate(s.offsetx, s.offsety);
  };
  var curveslengths = {}, getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
      if (length == null) {
        return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
      } else {
        return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
      }
    }, getLengthFactory = function (istotal, subpath) {
      return function (path, length, onlystart) {
        path = path2curve(path);
        var x, y, p, l, sp = '', subpaths = {}, point, len = 0;
        for (var i = 0, ii = path.length; i < ii; i++) {
          p = path[i];
          if (p[0] == 'M') {
            x = +p[1];
            y = +p[2];
          } else {
            l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
            if (len + l > length) {
              if (subpath && !subpaths.start) {
                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                sp += [
                  'C' + point.start.x,
                  point.start.y,
                  point.m.x,
                  point.m.y,
                  point.x,
                  point.y
                ];
                if (onlystart) {
                  return sp;
                }
                subpaths.start = sp;
                sp = [
                  'M' + point.x,
                  point.y + 'C' + point.n.x,
                  point.n.y,
                  point.end.x,
                  point.end.y,
                  p[5],
                  p[6]
                ].join();
                len += l;
                x = +p[5];
                y = +p[6];
                continue;
              }
              if (!istotal && !subpath) {
                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                return {
                  x: point.x,
                  y: point.y,
                  alpha: point.alpha
                };
              }
            }
            len += l;
            x = +p[5];
            y = +p[6];
          }
          sp += p.shift() + p;
        }
        subpaths.end = sp;
        point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
        point.alpha && (point = {
          x: point.x,
          y: point.y,
          alpha: point.alpha
        });
        return point;
      };
    };
  var getTotalLength = getLengthFactory(1), getPointAtLength = getLengthFactory(), getSubpathsAtLength = getLengthFactory(0, 1);
  /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/
  R.getTotalLength = getTotalLength;
  /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
  R.getPointAtLength = getPointAtLength;
  /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
  R.getSubpath = function (path, from, to) {
    if (this.getTotalLength(path) - to < 0.000001) {
      return getSubpathsAtLength(path, from).end;
    }
    var a = getSubpathsAtLength(path, to, 1);
    return from ? getSubpathsAtLength(a, from).end : a;
  };
  /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of “path” type.
     = (number) length.
    \*/
  elproto.getTotalLength = function () {
    var path = this.getPath();
    if (!path) {
      return;
    }
    if (this.node.getTotalLength) {
      return this.node.getTotalLength();
    }
    return getTotalLength(path);
  };
  /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
     **
     > Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
  elproto.getPointAtLength = function (length) {
    var path = this.getPath();
    if (!path) {
      return;
    }
    return getPointAtLength(path, length);
  };
  /*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
     = (object) path
     **
    \*/
  elproto.getPath = function () {
    var path, getPath = R._getPath[this.type];
    if (this.type == 'text' || this.type == 'set') {
      return;
    }
    if (getPath) {
      path = getPath(this);
    }
    return path;
  };
  /*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of “path” type.
     **
     > Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
  elproto.getSubpath = function (from, to) {
    var path = this.getPath();
    if (!path) {
      return;
    }
    return R.getSubpath(path, from, to);
  };
  /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>“linear”</li>
     #     <li>“&lt;” or “easeIn” or “ease-in”</li>
     #     <li>“>” or “easeOut” or “ease-out”</li>
     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
     #     <li>“backIn” or “back-in”</li>
     #     <li>“backOut” or “back-out”</li>
     #     <li>“elastic”</li>
     #     <li>“bounce”</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
    \*/
  var ef = R.easing_formulas = {
      linear: function (n) {
        return n;
      },
      '<': function (n) {
        return pow(n, 1.7);
      },
      '>': function (n) {
        return pow(n, 0.48);
      },
      '<>': function (n) {
        var q = 0.48 - n / 1.04, Q = math.sqrt(0.1734 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.5;
        return (1 - t) * 3 * t * t + t * t * t;
      },
      backIn: function (n) {
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
      },
      backOut: function (n) {
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
      },
      elastic: function (n) {
        if (n == !!n) {
          return n;
        }
        return pow(2, -10 * n) * math.sin((n - 0.075) * (2 * PI) / 0.3) + 1;
      },
      bounce: function (n) {
        var s = 7.5625, p = 2.75, l;
        if (n < 1 / p) {
          l = s * n * n;
        } else {
          if (n < 2 / p) {
            n -= 1.5 / p;
            l = s * n * n + 0.75;
          } else {
            if (n < 2.5 / p) {
              n -= 2.25 / p;
              l = s * n * n + 0.9375;
            } else {
              n -= 2.625 / p;
              l = s * n * n + 0.984375;
            }
          }
        }
        return l;
      }
    };
  ef.easeIn = ef['ease-in'] = ef['<'];
  ef.easeOut = ef['ease-out'] = ef['>'];
  ef.easeInOut = ef['ease-in-out'] = ef['<>'];
  ef['back-in'] = ef.backIn;
  ef['back-out'] = ef.backOut;
  var animationElements = [], requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
      setTimeout(callback, 16);
    }, animation = function () {
      var Now = +new Date(), l = 0;
      for (; l < animationElements.length; l++) {
        var e = animationElements[l];
        if (e.el.removed || e.paused) {
          continue;
        }
        var time = Now - e.start, ms = e.ms, easing = e.easing, from = e.from, diff = e.diff, to = e.to, t = e.t, that = e.el, set = {}, now, init = {}, key;
        if (e.initstatus) {
          time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
          e.status = e.initstatus;
          delete e.initstatus;
          e.stop && animationElements.splice(l--, 1);
        } else {
          e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
        }
        if (time < 0) {
          continue;
        }
        if (time < ms) {
          var pos = easing(time / ms);
          for (var attr in from)
            if (from[has](attr)) {
              switch (availableAnimAttrs[attr]) {
              case nu:
                now = +from[attr] + pos * ms * diff[attr];
                break;
              case 'colour':
                now = 'rgb(' + [
                  upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                  upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                  upto255(round(from[attr].b + pos * ms * diff[attr].b))
                ].join(',') + ')';
                break;
              case 'path':
                now = [];
                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                  now[i] = [from[attr][i][0]];
                  for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                    now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                  }
                  now[i] = now[i].join(S);
                }
                now = now.join(S);
                break;
              case 'transform':
                if (diff[attr].real) {
                  now = [];
                  for (i = 0, ii = from[attr].length; i < ii; i++) {
                    now[i] = [from[attr][i][0]];
                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                      now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                    }
                  }
                } else {
                  var get = function (i) {
                    return +from[attr][i] + pos * ms * diff[attr][i];
                  };
                  // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                  now = [[
                      'm',
                      get(0),
                      get(1),
                      get(2),
                      get(3),
                      get(4),
                      get(5)
                    ]];
                }
                break;
              case 'csv':
                if (attr == 'clip-rect') {
                  now = [];
                  i = 4;
                  while (i--) {
                    now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                  }
                }
                break;
              default:
                var from2 = [][concat](from[attr]);
                now = [];
                i = that.paper.customAttributes[attr].length;
                while (i--) {
                  now[i] = +from2[i] + pos * ms * diff[attr][i];
                }
                break;
              }
              set[attr] = now;
            }
          that.attr(set);
          (function (id, that, anim) {
            setTimeout(function () {
              eve('raphael.anim.frame.' + id, that, anim);
            });
          }(that.id, that, e.anim));
        } else {
          (function (f, el, a) {
            setTimeout(function () {
              eve('raphael.anim.frame.' + el.id, el, a);
              eve('raphael.anim.finish.' + el.id, el, a);
              R.is(f, 'function') && f.call(el);
            });
          }(e.callback, that, e.anim));
          that.attr(to);
          animationElements.splice(l--, 1);
          if (e.repeat > 1 && !e.next) {
            for (key in to)
              if (to[has](key)) {
                init[key] = e.totalOrigin[key];
              }
            e.el.attr(init);
            runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
          }
          if (e.next && !e.stop) {
            runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
          }
        }
      }
      R.svg && that && that.paper && that.paper.safari();
      animationElements.length && requestAnimFrame(animation);
    }, upto255 = function (color) {
      return color > 255 ? 255 : color < 0 ? 0 : color;
    };
  /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
  elproto.animateWith = function (el, anim, params, ms, easing, callback) {
    var element = this;
    if (element.removed) {
      callback && callback.call(element);
      return element;
    }
    var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback), x, y;
    runAnimation(a, element, a.percents[0], null, element.attr());
    for (var i = 0, ii = animationElements.length; i < ii; i++) {
      if (animationElements[i].anim == anim && animationElements[i].el == el) {
        animationElements[ii - 1].start = animationElements[i].start;
        break;
      }
    }
    return element;  //
                     //
                     // var a = params ? R.animation(params, ms, easing, callback) : anim,
                     //     status = element.status(anim);
                     // return this.animate(a).status(a, status * anim.ms / a.ms);
  };
  function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
    var cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx, cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
    function sampleCurveX(t) {
      return ((ax * t + bx) * t + cx) * t;
    }
    function solve(x, epsilon) {
      var t = solveCurveX(x, epsilon);
      return ((ay * t + by) * t + cy) * t;
    }
    function solveCurveX(x, epsilon) {
      var t0, t1, t2, x2, d2, i;
      for (t2 = x, i = 0; i < 8; i++) {
        x2 = sampleCurveX(t2) - x;
        if (abs(x2) < epsilon) {
          return t2;
        }
        d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
        if (abs(d2) < 0.000001) {
          break;
        }
        t2 = t2 - x2 / d2;
      }
      t0 = 0;
      t1 = 1;
      t2 = x;
      if (t2 < t0) {
        return t0;
      }
      if (t2 > t1) {
        return t1;
      }
      while (t0 < t1) {
        x2 = sampleCurveX(t2);
        if (abs(x2 - x) < epsilon) {
          return t2;
        }
        if (x > x2) {
          t0 = t2;
        } else {
          t1 = t2;
        }
        t2 = (t1 - t0) / 2 + t0;
      }
      return t2;
    }
    return solve(t, 1 / (200 * duration));
  }
  elproto.onAnimation = function (f) {
    f ? eve.on('raphael.anim.frame.' + this.id, f) : eve.unbind('raphael.anim.frame.' + this.id);
    return this;
  };
  function Animation(anim, ms) {
    var percents = [], newAnim = {};
    this.ms = ms;
    this.times = 1;
    if (anim) {
      for (var attr in anim)
        if (anim[has](attr)) {
          newAnim[toFloat(attr)] = anim[attr];
          percents.push(toFloat(attr));
        }
      percents.sort(sortByNumber);
    }
    this.anim = newAnim;
    this.top = percents[percents.length - 1];
    this.percents = percents;
  }
  /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/
  Animation.prototype.delay = function (delay) {
    var a = new Animation(this.anim, this.ms);
    a.times = this.times;
    a.del = +delay || 0;
    return a;
  };
  /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/
  Animation.prototype.repeat = function (times) {
    var a = new Animation(this.anim, this.ms);
    a.del = this.del;
    a.times = math.floor(mmax(times, 0)) || 1;
    return a;
  };
  function runAnimation(anim, element, percent, status, totalOrigin, times) {
    percent = toFloat(percent);
    var params, isInAnim, isInAnimSet, percents = [], next, prev, timestamp, ms = anim.ms, from = {}, to = {}, diff = {};
    if (status) {
      for (i = 0, ii = animationElements.length; i < ii; i++) {
        var e = animationElements[i];
        if (e.el.id == element.id && e.anim == anim) {
          if (e.percent != percent) {
            animationElements.splice(i, 1);
            isInAnimSet = 1;
          } else {
            isInAnim = e;
          }
          element.attr(e.totalOrigin);
          break;
        }
      }
    } else {
      status = +to;  // NaN
    }
    for (var i = 0, ii = anim.percents.length; i < ii; i++) {
      if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
        percent = anim.percents[i];
        prev = anim.percents[i - 1] || 0;
        ms = ms / anim.top * (percent - prev);
        next = anim.percents[i + 1];
        params = anim.anim[percent];
        break;
      } else if (status) {
        element.attr(anim.anim[anim.percents[i]]);
      }
    }
    if (!params) {
      return;
    }
    if (!isInAnim) {
      for (var attr in params)
        if (params[has](attr)) {
          if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
            from[attr] = element.attr(attr);
            from[attr] == null && (from[attr] = availableAttrs[attr]);
            to[attr] = params[attr];
            switch (availableAnimAttrs[attr]) {
            case nu:
              diff[attr] = (to[attr] - from[attr]) / ms;
              break;
            case 'colour':
              from[attr] = R.getRGB(from[attr]);
              var toColour = R.getRGB(to[attr]);
              diff[attr] = {
                r: (toColour.r - from[attr].r) / ms,
                g: (toColour.g - from[attr].g) / ms,
                b: (toColour.b - from[attr].b) / ms
              };
              break;
            case 'path':
              var pathes = path2curve(from[attr], to[attr]), toPath = pathes[1];
              from[attr] = pathes[0];
              diff[attr] = [];
              for (i = 0, ii = from[attr].length; i < ii; i++) {
                diff[attr][i] = [0];
                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                  diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                }
              }
              break;
            case 'transform':
              var _ = element._, eq = equaliseTransform(_[attr], to[attr]);
              if (eq) {
                from[attr] = eq.from;
                to[attr] = eq.to;
                diff[attr] = [];
                diff[attr].real = true;
                for (i = 0, ii = from[attr].length; i < ii; i++) {
                  diff[attr][i] = [from[attr][i][0]];
                  for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                    diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                  }
                }
              } else {
                var m = element.matrix || new Matrix(), to2 = {
                    _: { transform: _.transform },
                    getBBox: function () {
                      return element.getBBox(1);
                    }
                  };
                from[attr] = [
                  m.a,
                  m.b,
                  m.c,
                  m.d,
                  m.e,
                  m.f
                ];
                extractTransform(to2, to[attr]);
                to[attr] = to2._.transform;
                diff[attr] = [
                  (to2.matrix.a - m.a) / ms,
                  (to2.matrix.b - m.b) / ms,
                  (to2.matrix.c - m.c) / ms,
                  (to2.matrix.d - m.d) / ms,
                  (to2.matrix.e - m.e) / ms,
                  (to2.matrix.f - m.f) / ms
                ];  // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                    // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                    // extractTransform(to2, to[attr]);
                    // diff[attr] = [
                    //     (to2._.sx - _.sx) / ms,
                    //     (to2._.sy - _.sy) / ms,
                    //     (to2._.deg - _.deg) / ms,
                    //     (to2._.dx - _.dx) / ms,
                    //     (to2._.dy - _.dy) / ms
                    // ];
              }
              break;
            case 'csv':
              var values = Str(params[attr])[split](separator), from2 = Str(from[attr])[split](separator);
              if (attr == 'clip-rect') {
                from[attr] = from2;
                diff[attr] = [];
                i = from2.length;
                while (i--) {
                  diff[attr][i] = (values[i] - from[attr][i]) / ms;
                }
              }
              to[attr] = values;
              break;
            default:
              values = [][concat](params[attr]);
              from2 = [][concat](from[attr]);
              diff[attr] = [];
              i = element.paper.customAttributes[attr].length;
              while (i--) {
                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
              }
              break;
            }
          }
        }
      var easing = params.easing, easyeasy = R.easing_formulas[easing];
      if (!easyeasy) {
        easyeasy = Str(easing).match(bezierrg);
        if (easyeasy && easyeasy.length == 5) {
          var curve = easyeasy;
          easyeasy = function (t) {
            return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
          };
        } else {
          easyeasy = pipe;
        }
      }
      timestamp = params.start || anim.start || +new Date();
      e = {
        anim: anim,
        percent: percent,
        timestamp: timestamp,
        start: timestamp + (anim.del || 0),
        status: 0,
        initstatus: status || 0,
        stop: false,
        ms: ms,
        easing: easyeasy,
        from: from,
        diff: diff,
        to: to,
        el: element,
        callback: params.callback,
        prev: prev,
        next: next,
        repeat: times || anim.times,
        origin: element.attr(),
        totalOrigin: totalOrigin
      };
      animationElements.push(e);
      if (status && !isInAnim && !isInAnimSet) {
        e.stop = true;
        e.start = new Date() - ms * status;
        if (animationElements.length == 1) {
          return animation();
        }
      }
      if (isInAnimSet) {
        e.start = new Date() - e.ms * status;
      }
      animationElements.length == 1 && requestAnimFrame(animation);
    } else {
      isInAnim.initstatus = status;
      isInAnim.start = new Date() - isInAnim.ms * status;
    }
    eve('raphael.anim.start.' + element.id, element, anim);
  }
  /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/
  R.animation = function (params, ms, easing, callback) {
    if (params instanceof Animation) {
      return params;
    }
    if (R.is(easing, 'function') || !easing) {
      callback = callback || easing || null;
      easing = null;
    }
    params = Object(params);
    ms = +ms || 0;
    var p = {}, json, attr;
    for (attr in params)
      if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + '%' != attr) {
        json = true;
        p[attr] = params[attr];
      }
    if (!json) {
      // if percent-like syntax is used and end-of-all animation callback used
      if (callback) {
        // find the last one
        var lastKey = 0;
        for (var i in params) {
          var percent = toInt(i);
          if (params[has](i) && percent > lastKey) {
            lastKey = percent;
          }
        }
        lastKey += '%';
        // if already defined callback in the last keyframe, skip
        !params[lastKey].callback && (params[lastKey].callback = callback);
      }
      return new Animation(params, ms);
    } else {
      easing && (p.easing = easing);
      callback && (p.callback = callback);
      return new Animation({ 100: p }, ms);
    }
  };
  /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
  elproto.animate = function (params, ms, easing, callback) {
    var element = this;
    if (element.removed) {
      callback && callback.call(element);
      return element;
    }
    var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
    runAnimation(anim, element, anim.percents[0], null, element.attr());
    return element;
  };
  /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
    \*/
  elproto.setTime = function (anim, value) {
    if (anim && value != null) {
      this.status(anim, mmin(value, anim.ms) / anim.ms);
    }
    return this;
  };
  /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/
  elproto.status = function (anim, value) {
    var out = [], i = 0, len, e;
    if (value != null) {
      runAnimation(anim, this, -1, mmin(value, 1));
      return this;
    } else {
      len = animationElements.length;
      for (; i < len; i++) {
        e = animationElements[i];
        if (e.el.id == this.id && (!anim || e.anim == anim)) {
          if (anim) {
            return e.status;
          }
          out.push({
            anim: e.anim,
            status: e.status
          });
        }
      }
      if (anim) {
        return 0;
      }
      return out;
    }
  };
  /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
  elproto.pause = function (anim) {
    for (var i = 0; i < animationElements.length; i++)
      if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
        if (eve('raphael.anim.pause.' + this.id, this, animationElements[i].anim) !== false) {
          animationElements[i].paused = true;
        }
      }
    return this;
  };
  /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
  elproto.resume = function (anim) {
    for (var i = 0; i < animationElements.length; i++)
      if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
        var e = animationElements[i];
        if (eve('raphael.anim.resume.' + this.id, this, e.anim) !== false) {
          delete e.paused;
          this.status(e.anim, e.status);
        }
      }
    return this;
  };
  /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
  elproto.stop = function (anim) {
    for (var i = 0; i < animationElements.length; i++)
      if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
        if (eve('raphael.anim.stop.' + this.id, this, animationElements[i].anim) !== false) {
          animationElements.splice(i--, 1);
        }
      }
    return this;
  };
  function stopAnimation(paper) {
    for (var i = 0; i < animationElements.length; i++)
      if (animationElements[i].el.paper == paper) {
        animationElements.splice(i--, 1);
      }
  }
  eve.on('raphael.remove', stopAnimation);
  eve.on('raphael.clear', stopAnimation);
  elproto.toString = function () {
    return 'Rapha\xebl\u2019s object';
  };
  // Set
  var Set = function (items) {
      this.items = [];
      this.length = 0;
      this.type = 'set';
      if (items) {
        for (var i = 0, ii = items.length; i < ii; i++) {
          if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
            this[this.items.length] = this.items[this.items.length] = items[i];
            this.length++;
          }
        }
      }
    }, setproto = Set.prototype;
  /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
    \*/
  setproto.push = function () {
    var item, len;
    for (var i = 0, ii = arguments.length; i < ii; i++) {
      item = arguments[i];
      if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
        len = this.items.length;
        this[len] = this.items[len] = item;
        this.length++;
      }
    }
    return this;
  };
  /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
    \*/
  setproto.pop = function () {
    this.length && delete this[this.length--];
    return this.items.pop();
  };
  /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
  setproto.forEach = function (callback, thisArg) {
    for (var i = 0, ii = this.items.length; i < ii; i++) {
      if (callback.call(thisArg, this.items[i], i) === false) {
        return this;
      }
    }
    return this;
  };
  for (var method in elproto)
    if (elproto[has](method)) {
      setproto[method] = function (methodname) {
        return function () {
          var arg = arguments;
          return this.forEach(function (el) {
            el[methodname][apply](el, arg);
          });
        };
      }(method);
    }
  setproto.attr = function (name, value) {
    if (name && R.is(name, array) && R.is(name[0], 'object')) {
      for (var j = 0, jj = name.length; j < jj; j++) {
        this.items[j].attr(name[j]);
      }
    } else {
      for (var i = 0, ii = this.items.length; i < ii; i++) {
        this.items[i].attr(name, value);
      }
    }
    return this;
  };
  /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
  setproto.clear = function () {
    while (this.length) {
      this.pop();
    }
  };
  /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
  setproto.splice = function (index, count, insertion) {
    index = index < 0 ? mmax(this.length + index, 0) : index;
    count = mmax(0, mmin(this.length - index, count));
    var tail = [], todel = [], args = [], i;
    for (i = 2; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    for (i = 0; i < count; i++) {
      todel.push(this[index + i]);
    }
    for (; i < this.length - index; i++) {
      tail.push(this[index + i]);
    }
    var arglen = args.length;
    for (i = 0; i < arglen + tail.length; i++) {
      this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
    }
    i = this.items.length = this.length -= count - arglen;
    while (this[i]) {
      delete this[i++];
    }
    return new Set(todel);
  };
  /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
    \*/
  setproto.exclude = function (el) {
    for (var i = 0, ii = this.length; i < ii; i++)
      if (this[i] == el) {
        this.splice(i, 1);
        return true;
      }
  };
  setproto.animate = function (params, ms, easing, callback) {
    (R.is(easing, 'function') || !easing) && (callback = easing || null);
    var len = this.items.length, i = len, item, set = this, collector;
    if (!len) {
      return this;
    }
    callback && (collector = function () {
      !--len && callback.call(set);
    });
    easing = R.is(easing, string) ? easing : collector;
    var anim = R.animation(params, ms, easing, collector);
    item = this.items[--i].animate(anim);
    while (i--) {
      this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
      this.items[i] && !this.items[i].removed || len--;
    }
    return this;
  };
  setproto.insertAfter = function (el) {
    var i = this.items.length;
    while (i--) {
      this.items[i].insertAfter(el);
    }
    return this;
  };
  setproto.getBBox = function () {
    var x = [], y = [], x2 = [], y2 = [];
    for (var i = this.items.length; i--;)
      if (!this.items[i].removed) {
        var box = this.items[i].getBBox();
        x.push(box.x);
        y.push(box.y);
        x2.push(box.x + box.width);
        y2.push(box.y + box.height);
      }
    x = mmin[apply](0, x);
    y = mmin[apply](0, y);
    x2 = mmax[apply](0, x2);
    y2 = mmax[apply](0, y2);
    return {
      x: x,
      y: y,
      x2: x2,
      y2: y2,
      width: x2 - x,
      height: y2 - y
    };
  };
  setproto.clone = function (s) {
    s = this.paper.set();
    for (var i = 0, ii = this.items.length; i < ii; i++) {
      s.push(this.items[i].clone());
    }
    return s;
  };
  setproto.toString = function () {
    return 'Rapha\xebl\u2018s set';
  };
  setproto.glow = function (glowConfig) {
    var ret = this.paper.set();
    this.forEach(function (shape, index) {
      var g = shape.glow(glowConfig);
      if (g != null) {
        g.forEach(function (shape2, index2) {
          ret.push(shape2);
        });
      }
    });
    return ret;
  };
  /*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this set’s elements
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/
  setproto.isPointInside = function (x, y) {
    var isPointInside = false;
    this.forEach(function (el) {
      if (el.isPointInside(x, y)) {
        isPointInside = true;
        return false;  // stop loop
      }
    });
    return isPointInside;
  };
  /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({…}));
    \*/
  R.registerFont = function (font) {
    if (!font.face) {
      return font;
    }
    this.fonts = this.fonts || {};
    var fontcopy = {
        w: font.w,
        face: {},
        glyphs: {}
      }, family = font.face['font-family'];
    for (var prop in font.face)
      if (font.face[has](prop)) {
        fontcopy.face[prop] = font.face[prop];
      }
    if (this.fonts[family]) {
      this.fonts[family].push(fontcopy);
    } else {
      this.fonts[family] = [fontcopy];
    }
    if (!font.svg) {
      fontcopy.face['units-per-em'] = toInt(font.face['units-per-em'], 10);
      for (var glyph in font.glyphs)
        if (font.glyphs[has](glyph)) {
          var path = font.glyphs[glyph];
          fontcopy.glyphs[glyph] = {
            w: path.w,
            k: {},
            d: path.d && 'M' + path.d.replace(/[mlcxtrv]/g, function (command) {
              return {
                l: 'L',
                c: 'C',
                x: 'z',
                t: 'm',
                r: 'l',
                v: 'c'
              }[command] || 'M';
            }) + 'z'
          };
          if (path.k) {
            for (var k in path.k)
              if (path[has](k)) {
                fontcopy.glyphs[glyph].k[k] = path.k[k];
              }
          }
        }
    }
    return font;
  };
  /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/
  paperproto.getFont = function (family, weight, style, stretch) {
    stretch = stretch || 'normal';
    style = style || 'normal';
    weight = +weight || {
      normal: 400,
      bold: 700,
      lighter: 300,
      bolder: 800
    }[weight] || 400;
    if (!R.fonts) {
      return;
    }
    var font = R.fonts[family];
    if (!font) {
      var name = new RegExp('(^|\\s)' + family.replace(/[^\w\d\s+!~.:_-]/g, E) + '(\\s|$)', 'i');
      for (var fontName in R.fonts)
        if (R.fonts[has](fontName)) {
          if (name.test(fontName)) {
            font = R.fonts[fontName];
            break;
          }
        }
    }
    var thefont;
    if (font) {
      for (var i = 0, ii = font.length; i < ii; i++) {
        thefont = font[i];
        if (thefont.face['font-weight'] == weight && (thefont.face['font-style'] == style || !thefont.face['font-style']) && thefont.face['font-stretch'] == stretch) {
          break;
        }
      }
    }
    return thefont;
  };
  /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/
  paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
    origin = origin || 'middle';
    // baseline|middle
    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
    line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
    var letters = Str(string)[split](E), shift = 0, notfirst = 0, path = E, scale;
    R.is(font, 'string') && (font = this.getFont(font));
    if (font) {
      scale = (size || 16) / font.face['units-per-em'];
      var bb = font.face.bbox[split](separator), top = +bb[0], lineHeight = bb[3] - bb[1], shifty = 0, height = +bb[1] + (origin == 'baseline' ? lineHeight + +font.face.descent : lineHeight / 2);
      for (var i = 0, ii = letters.length; i < ii; i++) {
        if (letters[i] == '\n') {
          shift = 0;
          curr = 0;
          notfirst = 0;
          shifty += lineHeight * line_spacing;
        } else {
          var prev = notfirst && font.glyphs[letters[i - 1]] || {}, curr = font.glyphs[letters[i]];
          shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
          notfirst = 1;
        }
        if (curr && curr.d) {
          path += R.transformPath(curr.d, [
            't',
            shift * scale,
            shifty * scale,
            's',
            scale,
            scale,
            top,
            height,
            't',
            (x - top) / scale,
            (y - height) / scale
          ]);
        }
      }
    }
    return this.path(path).attr({
      fill: '#000',
      stroke: 'none'
    });
  };
  /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/
  paperproto.add = function (json) {
    if (R.is(json, 'array')) {
      var res = this.set(), i = 0, ii = json.length, j;
      for (; i < ii; i++) {
        j = json[i] || {};
        elements[has](j.type) && res.push(this[j.type]().attr(j));
      }
    }
    return res;
  };
  /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - … (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/
  R.format = function (token, params) {
    var args = R.is(params, array) ? [0][concat](params) : arguments;
    token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
      return args[++i] == null ? E : args[i];
    }));
    return token || E;
  };
  /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
  R.fullfill = function () {
    var tokenRegex = /\{([^\}]+)\}/g, objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,
      // matches .xxxxx or ["xxxxx"] to run over object properties
      replacer = function (all, key, obj) {
        var res = obj;
        key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
          name = name || quotedName;
          if (res) {
            if (name in res) {
              res = res[name];
            }
            typeof res == 'function' && isFunc && (res = res());
          }
        });
        res = (res == null || res == obj ? all : res) + '';
        return res;
      };
    return function (str, obj) {
      return String(str).replace(tokenRegex, function (all, key) {
        return replacer(all, key, obj);
      });
    };
  }();
  /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     …
     | })(Raphael.ninja());
    \*/
  R.ninja = function () {
    oldRaphael.was ? g.win.Raphael = oldRaphael.is : delete Raphael;
    return R;
  };
  /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/
  R.st = setproto;
  eve.on('raphael.DOMload', function () {
    loaded = true;
  });
  // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
  (function (doc, loaded, f) {
    if (doc.readyState == null && doc.addEventListener) {
      doc.addEventListener(loaded, f = function () {
        doc.removeEventListener(loaded, f, false);
        doc.readyState = 'complete';
      }, false);
      doc.readyState = 'loading';
    }
    function isLoaded() {
      /in/.test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve('raphael.DOMload');
    }
    isLoaded();
  }(document, 'DOMContentLoaded'));
  // ┌─────────────────────────────────────────────────────────────────────┐ \\
  // │ Raphaël - JavaScript Vector Library                                 │ \\
  // ├─────────────────────────────────────────────────────────────────────┤ \\
  // │ SVG Module                                                          │ \\
  // ├─────────────────────────────────────────────────────────────────────┤ \\
  // │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
  // │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
  // │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
  // └─────────────────────────────────────────────────────────────────────┘ \\
  (function () {
    if (!R.svg) {
      return;
    }
    var has = 'hasOwnProperty', Str = String, toFloat = parseFloat, toInt = parseInt, math = Math, mmax = math.max, abs = math.abs, pow = math.pow, separator = /[, ]+/, eve = R.eve, E = '', S = ' ';
    var xlink = 'http://www.w3.org/1999/xlink', markers = {
        block: 'M5,0 0,2.5 5,5z',
        classic: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z',
        diamond: 'M2.5,0 5,2.5 2.5,5 0,2.5z',
        open: 'M6,1 1,3.5 6,6',
        oval: 'M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z'
      }, markerCounter = {};
    R.toString = function () {
      return 'Your browser supports SVG.\nYou are running Rapha\xebl ' + this.version;
    };
    var $ = function (el, attr) {
        if (attr) {
          if (typeof el == 'string') {
            el = $(el);
          }
          for (var key in attr)
            if (attr[has](key)) {
              if (key.substring(0, 6) == 'xlink:') {
                el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
              } else {
                el.setAttribute(key, Str(attr[key]));
              }
            }
        } else {
          el = R._g.doc.createElementNS('http://www.w3.org/2000/svg', el);
          el.style && (el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)');
        }
        return el;
      }, addGradientFill = function (element, gradient) {
        var type = 'linear', id = element.id + gradient, fx = 0.5, fy = 0.5, o = element.node, SVG = element.paper, s = o.style, el = R._g.doc.getElementById(id);
        if (!el) {
          gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
            type = 'radial';
            if (_fx && _fy) {
              fx = toFloat(_fx);
              fy = toFloat(_fy);
              var dir = (fy > 0.5) * 2 - 1;
              pow(fx - 0.5, 2) + pow(fy - 0.5, 2) > 0.25 && (fy = math.sqrt(0.25 - pow(fx - 0.5, 2)) * dir + 0.5) && fy != 0.5 && (fy = fy.toFixed(5) - 0.00001 * dir);
            }
            return E;
          });
          gradient = gradient.split(/\s*\-\s*/);
          if (type == 'linear') {
            var angle = gradient.shift();
            angle = -toFloat(angle);
            if (isNaN(angle)) {
              return null;
            }
            var vector = [
                0,
                0,
                math.cos(R.rad(angle)),
                math.sin(R.rad(angle))
              ], max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
            vector[2] *= max;
            vector[3] *= max;
            if (vector[2] < 0) {
              vector[0] = -vector[2];
              vector[2] = 0;
            }
            if (vector[3] < 0) {
              vector[1] = -vector[3];
              vector[3] = 0;
            }
          }
          var dots = R._parseDots(gradient);
          if (!dots) {
            return null;
          }
          id = id.replace(/[\(\)\s,\xb0#]/g, '_');
          if (element.gradient && id != element.gradient.id) {
            SVG.defs.removeChild(element.gradient);
            delete element.gradient;
          }
          if (!element.gradient) {
            el = $(type + 'Gradient', { id: id });
            element.gradient = el;
            $(el, type == 'radial' ? {
              fx: fx,
              fy: fy
            } : {
              x1: vector[0],
              y1: vector[1],
              x2: vector[2],
              y2: vector[3],
              gradientTransform: element.matrix.invert()
            });
            SVG.defs.appendChild(el);
            for (var i = 0, ii = dots.length; i < ii; i++) {
              el.appendChild($('stop', {
                offset: dots[i].offset ? dots[i].offset : i ? '100%' : '0%',
                'stop-color': dots[i].color || '#fff'
              }));
            }
          }
        }
        $(o, {
          fill: 'url(\'' + document.location + '#' + id + '\')',
          opacity: 1,
          'fill-opacity': 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
      }, updatePosition = function (o) {
        var bbox = o.getBBox(1);
        $(o.pattern, { patternTransform: o.matrix.invert() + ' translate(' + bbox.x + ',' + bbox.y + ')' });
      }, addArrow = function (o, value, isEnd) {
        if (o.type == 'path') {
          var values = Str(value).toLowerCase().split('-'), p = o.paper, se = isEnd ? 'end' : 'start', node = o.node, attrs = o.attrs, stroke = attrs['stroke-width'], i = values.length, type = 'classic', from, to, dx, refX, attr, w = 3, h = 3, t = 5;
          while (i--) {
            switch (values[i]) {
            case 'block':
            case 'classic':
            case 'oval':
            case 'diamond':
            case 'open':
            case 'none':
              type = values[i];
              break;
            case 'wide':
              h = 5;
              break;
            case 'narrow':
              h = 2;
              break;
            case 'long':
              w = 5;
              break;
            case 'short':
              w = 2;
              break;
            }
          }
          if (type == 'open') {
            w += 2;
            h += 2;
            t += 2;
            dx = 1;
            refX = isEnd ? 4 : 1;
            attr = {
              fill: 'none',
              stroke: attrs.stroke
            };
          } else {
            refX = dx = w / 2;
            attr = {
              fill: attrs.stroke,
              stroke: 'none'
            };
          }
          if (o._.arrows) {
            if (isEnd) {
              o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
              o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
            } else {
              o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
              o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
            }
          } else {
            o._.arrows = {};
          }
          if (type != 'none') {
            var pathId = 'raphael-marker-' + type, markerId = 'raphael-marker-' + se + type + w + h + '-obj' + o.id;
            if (!R._g.doc.getElementById(pathId)) {
              p.defs.appendChild($($('path'), {
                'stroke-linecap': 'round',
                d: markers[type],
                id: pathId
              }));
              markerCounter[pathId] = 1;
            } else {
              markerCounter[pathId]++;
            }
            var marker = R._g.doc.getElementById(markerId), use;
            if (!marker) {
              marker = $($('marker'), {
                id: markerId,
                markerHeight: h,
                markerWidth: w,
                orient: 'auto',
                refX: refX,
                refY: h / 2
              });
              use = $($('use'), {
                'xlink:href': '#' + pathId,
                transform: (isEnd ? 'rotate(180 ' + w / 2 + ' ' + h / 2 + ') ' : E) + 'scale(' + w / t + ',' + h / t + ')',
                'stroke-width': (1 / ((w / t + h / t) / 2)).toFixed(4)
              });
              marker.appendChild(use);
              p.defs.appendChild(marker);
              markerCounter[markerId] = 1;
            } else {
              markerCounter[markerId]++;
              use = marker.getElementsByTagName('use')[0];
            }
            $(use, attr);
            var delta = dx * (type != 'diamond' && type != 'oval');
            if (isEnd) {
              from = o._.arrows.startdx * stroke || 0;
              to = R.getTotalLength(attrs.path) - delta * stroke;
            } else {
              from = delta * stroke;
              to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
            }
            attr = {};
            attr['marker-' + se] = 'url(#' + markerId + ')';
            if (to || from) {
              attr.d = R.getSubpath(attrs.path, from, to);
            }
            $(node, attr);
            o._.arrows[se + 'Path'] = pathId;
            o._.arrows[se + 'Marker'] = markerId;
            o._.arrows[se + 'dx'] = delta;
            o._.arrows[se + 'Type'] = type;
            o._.arrows[se + 'String'] = value;
          } else {
            if (isEnd) {
              from = o._.arrows.startdx * stroke || 0;
              to = R.getTotalLength(attrs.path) - from;
            } else {
              from = 0;
              to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
            }
            o._.arrows[se + 'Path'] && $(node, { d: R.getSubpath(attrs.path, from, to) });
            delete o._.arrows[se + 'Path'];
            delete o._.arrows[se + 'Marker'];
            delete o._.arrows[se + 'dx'];
            delete o._.arrows[se + 'Type'];
            delete o._.arrows[se + 'String'];
          }
          for (attr in markerCounter)
            if (markerCounter[has](attr) && !markerCounter[attr]) {
              var item = R._g.doc.getElementById(attr);
              item && item.parentNode.removeChild(item);
            }
        }
      }, dasharray = {
        '': [0],
        'none': [0],
        '-': [
          3,
          1
        ],
        '.': [
          1,
          1
        ],
        '-.': [
          3,
          1,
          1,
          1
        ],
        '-..': [
          3,
          1,
          1,
          1,
          1,
          1
        ],
        '. ': [
          1,
          3
        ],
        '- ': [
          4,
          3
        ],
        '--': [
          8,
          3
        ],
        '- .': [
          4,
          3,
          1,
          3
        ],
        '--.': [
          8,
          3,
          1,
          3
        ],
        '--..': [
          8,
          3,
          1,
          3,
          1,
          3
        ]
      }, addDashes = function (o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
          var width = o.attrs['stroke-width'] || '1', butt = {
              round: width,
              square: width,
              butt: 0
            }[o.attrs['stroke-linecap'] || params['stroke-linecap']] || 0, dashes = [], i = value.length;
          while (i--) {
            dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
          }
          $(o.node, { 'stroke-dasharray': dashes.join(',') });
        }
      }, setFillAndStroke = function (o, params) {
        var node = o.node, attrs = o.attrs, vis = node.style.visibility;
        node.style.visibility = 'hidden';
        for (var att in params) {
          if (params[has](att)) {
            if (!R._availableAttrs[has](att)) {
              continue;
            }
            var value = params[att];
            attrs[att] = value;
            switch (att) {
            case 'blur':
              o.blur(value);
              break;
            case 'title':
              var title = node.getElementsByTagName('title');
              // Use the existing <title>.
              if (title.length && (title = title[0])) {
                title.firstChild.nodeValue = value;
              } else {
                title = $('title');
                var val = R._g.doc.createTextNode(value);
                title.appendChild(val);
                node.appendChild(title);
              }
              break;
            case 'href':
            case 'target':
              var pn = node.parentNode;
              if (pn.tagName.toLowerCase() != 'a') {
                var hl = $('a');
                pn.insertBefore(hl, node);
                hl.appendChild(node);
                pn = hl;
              }
              if (att == 'target') {
                pn.setAttributeNS(xlink, 'show', value == 'blank' ? 'new' : value);
              } else {
                pn.setAttributeNS(xlink, att, value);
              }
              break;
            case 'cursor':
              node.style.cursor = value;
              break;
            case 'transform':
              o.transform(value);
              break;
            case 'arrow-start':
              addArrow(o, value);
              break;
            case 'arrow-end':
              addArrow(o, value, 1);
              break;
            case 'clip-rect':
              var rect = Str(value).split(separator);
              if (rect.length == 4) {
                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                var el = $('clipPath'), rc = $('rect');
                el.id = R.createUUID();
                $(rc, {
                  x: rect[0],
                  y: rect[1],
                  width: rect[2],
                  height: rect[3]
                });
                el.appendChild(rc);
                o.paper.defs.appendChild(el);
                $(node, { 'clip-path': 'url(#' + el.id + ')' });
                o.clip = rc;
              }
              if (!value) {
                var path = node.getAttribute('clip-path');
                if (path) {
                  var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                  clip && clip.parentNode.removeChild(clip);
                  $(node, { 'clip-path': E });
                  delete o.clip;
                }
              }
              break;
            case 'path':
              if (o.type == 'path') {
                $(node, { d: value ? attrs.path = R._pathToAbsolute(value) : 'M0,0' });
                o._.dirty = 1;
                if (o._.arrows) {
                  'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                  'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                }
              }
              break;
            case 'width':
              node.setAttribute(att, value);
              o._.dirty = 1;
              if (attrs.fx) {
                att = 'x';
                value = attrs.x;
              } else {
                break;
              }
            case 'x':
              if (attrs.fx) {
                value = -attrs.x - (attrs.width || 0);
              }
            case 'rx':
              if (att == 'rx' && o.type == 'rect') {
                break;
              }
            case 'cx':
              node.setAttribute(att, value);
              o.pattern && updatePosition(o);
              o._.dirty = 1;
              break;
            case 'height':
              node.setAttribute(att, value);
              o._.dirty = 1;
              if (attrs.fy) {
                att = 'y';
                value = attrs.y;
              } else {
                break;
              }
            case 'y':
              if (attrs.fy) {
                value = -attrs.y - (attrs.height || 0);
              }
            case 'ry':
              if (att == 'ry' && o.type == 'rect') {
                break;
              }
            case 'cy':
              node.setAttribute(att, value);
              o.pattern && updatePosition(o);
              o._.dirty = 1;
              break;
            case 'r':
              if (o.type == 'rect') {
                $(node, {
                  rx: value,
                  ry: value
                });
              } else {
                node.setAttribute(att, value);
              }
              o._.dirty = 1;
              break;
            case 'src':
              if (o.type == 'image') {
                node.setAttributeNS(xlink, 'href', value);
              }
              break;
            case 'stroke-width':
              if (o._.sx != 1 || o._.sy != 1) {
                value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
              }
              node.setAttribute(att, value);
              if (attrs['stroke-dasharray']) {
                addDashes(o, attrs['stroke-dasharray'], params);
              }
              if (o._.arrows) {
                'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
              }
              break;
            case 'stroke-dasharray':
              addDashes(o, value, params);
              break;
            case 'fill':
              var isURL = Str(value).match(R._ISURL);
              if (isURL) {
                el = $('pattern');
                var ig = $('image');
                el.id = R.createUUID();
                $(el, {
                  x: 0,
                  y: 0,
                  patternUnits: 'userSpaceOnUse',
                  height: 1,
                  width: 1
                });
                $(ig, {
                  x: 0,
                  y: 0,
                  'xlink:href': isURL[1]
                });
                el.appendChild(ig);
                (function (el) {
                  R._preload(isURL[1], function () {
                    var w = this.offsetWidth, h = this.offsetHeight;
                    $(el, {
                      width: w,
                      height: h
                    });
                    $(ig, {
                      width: w,
                      height: h
                    });
                    o.paper.safari();
                  });
                }(el));
                o.paper.defs.appendChild(el);
                $(node, { fill: 'url(#' + el.id + ')' });
                o.pattern = el;
                o.pattern && updatePosition(o);
                break;
              }
              var clr = R.getRGB(value);
              if (!clr.error) {
                delete params.gradient;
                delete attrs.gradient;
                !R.is(attrs.opacity, 'undefined') && R.is(params.opacity, 'undefined') && $(node, { opacity: attrs.opacity });
                !R.is(attrs['fill-opacity'], 'undefined') && R.is(params['fill-opacity'], 'undefined') && $(node, { 'fill-opacity': attrs['fill-opacity'] });
              } else if ((o.type == 'circle' || o.type == 'ellipse' || Str(value).charAt() != 'r') && addGradientFill(o, value)) {
                if ('opacity' in attrs || 'fill-opacity' in attrs) {
                  var gradient = R._g.doc.getElementById(node.getAttribute('fill').replace(/^url\(#|\)$/g, E));
                  if (gradient) {
                    var stops = gradient.getElementsByTagName('stop');
                    $(stops[stops.length - 1], { 'stop-opacity': ('opacity' in attrs ? attrs.opacity : 1) * ('fill-opacity' in attrs ? attrs['fill-opacity'] : 1) });
                  }
                }
                attrs.gradient = value;
                attrs.fill = 'none';
                break;
              }
              clr[has]('opacity') && $(node, { 'fill-opacity': clr.opacity > 1 ? clr.opacity / 100 : clr.opacity });
            case 'stroke':
              clr = R.getRGB(value);
              node.setAttribute(att, clr.hex);
              att == 'stroke' && clr[has]('opacity') && $(node, { 'stroke-opacity': clr.opacity > 1 ? clr.opacity / 100 : clr.opacity });
              if (att == 'stroke' && o._.arrows) {
                'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
              }
              break;
            case 'gradient':
              (o.type == 'circle' || o.type == 'ellipse' || Str(value).charAt() != 'r') && addGradientFill(o, value);
              break;
            case 'opacity':
              if (attrs.gradient && !attrs[has]('stroke-opacity')) {
                $(node, { 'stroke-opacity': value > 1 ? value / 100 : value });
              }
            // fall
            case 'fill-opacity':
              if (attrs.gradient) {
                gradient = R._g.doc.getElementById(node.getAttribute('fill').replace(/^url\(#|\)$/g, E));
                if (gradient) {
                  stops = gradient.getElementsByTagName('stop');
                  $(stops[stops.length - 1], { 'stop-opacity': value });
                }
                break;
              }
            default:
              att == 'font-size' && (value = toInt(value, 10) + 'px');
              var cssrule = att.replace(/(\-.)/g, function (w) {
                  return w.substring(1).toUpperCase();
                });
              node.style[cssrule] = value;
              o._.dirty = 1;
              node.setAttribute(att, value);
              break;
            }
          }
        }
        tuneText(o, params);
        node.style.visibility = vis;
      }, leading = 1.2, tuneText = function (el, params) {
        if (el.type != 'text' || !(params[has]('text') || params[has]('font') || params[has]('font-size') || params[has]('x') || params[has]('y'))) {
          return;
        }
        var a = el.attrs, node = el.node, fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue('font-size'), 10) : 10;
        if (params[has]('text')) {
          a.text = params.text;
          while (node.firstChild) {
            node.removeChild(node.firstChild);
          }
          var texts = Str(params.text).split('\n'), tspans = [], tspan;
          for (var i = 0, ii = texts.length; i < ii; i++) {
            tspan = $('tspan');
            i && $(tspan, {
              dy: fontSize * leading,
              x: a.x
            });
            tspan.appendChild(R._g.doc.createTextNode(texts[i]));
            node.appendChild(tspan);
            tspans[i] = tspan;
          }
        } else {
          tspans = node.getElementsByTagName('tspan');
          for (i = 0, ii = tspans.length; i < ii; i++)
            if (i) {
              $(tspans[i], {
                dy: fontSize * leading,
                x: a.x
              });
            } else {
              $(tspans[0], { dy: 0 });
            }
        }
        $(node, {
          x: a.x,
          y: a.y
        });
        el._.dirty = 1;
        var bb = el._getBBox(), dif = a.y - (bb.y + bb.height / 2);
        dif && R.is(dif, 'finite') && $(tspans[0], { dy: dif });
      }, getRealNode = function (node) {
        if (node.parentNode && node.parentNode.tagName.toLowerCase() === 'a') {
          return node.parentNode;
        } else {
          return node;
        }
      }, Element = function (node, svg) {
        var X = 0, Y = 0;
        /*\
         * Element.node
         [ property (object) ]
         **
         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
         **
         * Note: Don’t mess with it.
         > Usage
         | // draw a circle at coordinate 10,10 with radius of 10
         | var c = paper.circle(10, 10, 10);
         | c.node.onclick = function () {
         |     c.attr("fill", "red");
         | };
        \*/
        this[0] = this.node = node;
        /*\
         * Element.raphael
         [ property (object) ]
         **
         * Internal reference to @Raphael object. In case it is not available.
         > Usage
         | Raphael.el.red = function () {
         |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
         |     hsb.h = 1;
         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
         | }
        \*/
        node.raphael = true;
        /*\
         * Element.id
         [ property (number) ]
         **
         * Unique id of the element. Especially useful when you want to listen to events of the element,
         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
        \*/
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.matrix = R.matrix();
        this.realPath = null;
        /*\
         * Element.paper
         [ property (object) ]
         **
         * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
         > Usage
         | Raphael.el.cross = function () {
         |     this.attr({fill: "red"});
         |     this.paper.path("M10,10L50,50M50,10L10,50")
         |         .attr({stroke: "red"});
         | }
        \*/
        this.paper = svg;
        this.attrs = this.attrs || {};
        this._ = {
          transform: [],
          sx: 1,
          sy: 1,
          deg: 0,
          dx: 0,
          dy: 0,
          dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        /*\
         * Element.prev
         [ property (object) ]
         **
         * Reference to the previous element in the hierarchy.
        \*/
        this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        /*\
         * Element.next
         [ property (object) ]
         **
         * Reference to the next element in the hierarchy.
        \*/
        this.next = null;
      }, elproto = R.el;
    Element.prototype = elproto;
    elproto.constructor = Element;
    R._engine.path = function (pathString, SVG) {
      var el = $('path');
      SVG.canvas && SVG.canvas.appendChild(el);
      var p = new Element(el, SVG);
      p.type = 'path';
      setFillAndStroke(p, {
        fill: 'none',
        stroke: '#000',
        path: pathString
      });
      return p;
    };
    /*\
     * Element.rotate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds rotation by given angle around given point to the list of
     * transformations of the element.
     > Parameters
     - deg (number) angle in degrees
     - cx (number) #optional x coordinate of the centre of rotation
     - cy (number) #optional y coordinate of the centre of rotation
     * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
     = (object) @Element
    \*/
    elproto.rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }
      deg = Str(deg).split(separator);
      if (deg.length - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }
      deg = toFloat(deg[0]);
      cy == null && (cx = cy);
      if (cx == null || cy == null) {
        var bbox = this.getBBox(1);
        cx = bbox.x + bbox.width / 2;
        cy = bbox.y + bbox.height / 2;
      }
      this.transform(this._.transform.concat([[
          'r',
          deg,
          cx,
          cy
        ]]));
      return this;
    };
    /*\
     * Element.scale
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds scale by given amount relative to given point to the list of
     * transformations of the element.
     > Parameters
     - sx (number) horisontal scale amount
     - sy (number) vertical scale amount
     - cx (number) #optional x coordinate of the centre of scale
     - cy (number) #optional y coordinate of the centre of scale
     * If cx & cy aren’t specified centre of the shape is used instead.
     = (object) @Element
    \*/
    elproto.scale = function (sx, sy, cx, cy) {
      if (this.removed) {
        return this;
      }
      sx = Str(sx).split(separator);
      if (sx.length - 1) {
        sy = toFloat(sx[1]);
        cx = toFloat(sx[2]);
        cy = toFloat(sx[3]);
      }
      sx = toFloat(sx[0]);
      sy == null && (sy = sx);
      cy == null && (cx = cy);
      if (cx == null || cy == null) {
        var bbox = this.getBBox(1);
      }
      cx = cx == null ? bbox.x + bbox.width / 2 : cx;
      cy = cy == null ? bbox.y + bbox.height / 2 : cy;
      this.transform(this._.transform.concat([[
          's',
          sx,
          sy,
          cx,
          cy
        ]]));
      return this;
    };
    /*\
     * Element.translate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds translation by given amount to the list of transformations of the element.
     > Parameters
     - dx (number) horisontal shift
     - dy (number) vertical shift
     = (object) @Element
    \*/
    elproto.translate = function (dx, dy) {
      if (this.removed) {
        return this;
      }
      dx = Str(dx).split(separator);
      if (dx.length - 1) {
        dy = toFloat(dx[1]);
      }
      dx = toFloat(dx[0]) || 0;
      dy = +dy || 0;
      this.transform(this._.transform.concat([[
          't',
          dx,
          dy
        ]]));
      return this;
    };
    /*\
     * Element.transform
     [ method ]
     **
     * Adds transformation to the element which is separate to other attributes,
     * i.e. translation doesn’t change `x` or `y` of the rectange. The format
     * of transformation string is similar to the path string syntax:
     | "t100,100r30,100,100s2,2,100,100r45s1.5"
     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
     * scale and `m` is for matrix.
     *
     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
     *
     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
     * coordinates as optional parameters, the default is the centre point of the element.
     * Matrix accepts six parameters.
     > Usage
     | var el = paper.rect(10, 20, 300, 200);
     | // translate 100, 100, rotate 45°, translate -100, 0
     | el.transform("t100,100r45t-100,0");
     | // if you want you can append or prepend transformations
     | el.transform("...t50,50");
     | el.transform("s2...");
     | // or even wrap
     | el.transform("t50,50...t-50-50");
     | // to reset transformation call method with empty string
     | el.transform("");
     | // to get current value call it without parameters
     | console.log(el.transform());
     > Parameters
     - tstr (string) #optional transformation string
     * If tstr isn’t specified
     = (string) current transformation string
     * else
     = (object) @Element
    \*/
    elproto.transform = function (tstr) {
      var _ = this._;
      if (tstr == null) {
        return _.transform;
      }
      R._extractTransform(this, tstr);
      this.clip && $(this.clip, { transform: this.matrix.invert() });
      this.pattern && updatePosition(this);
      this.node && $(this.node, { transform: this.matrix });
      if (_.sx != 1 || _.sy != 1) {
        var sw = this.attrs[has]('stroke-width') ? this.attrs['stroke-width'] : 1;
        this.attr({ 'stroke-width': sw });
      }
      return this;
    };
    /*\
     * Element.hide
     [ method ]
     **
     * Makes element invisible. See @Element.show.
     = (object) @Element
    \*/
    elproto.hide = function () {
      !this.removed && this.paper.safari(this.node.style.display = 'none');
      return this;
    };
    /*\
     * Element.show
     [ method ]
     **
     * Makes element visible. See @Element.hide.
     = (object) @Element
    \*/
    elproto.show = function () {
      !this.removed && this.paper.safari(this.node.style.display = '');
      return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the paper.
    \*/
    elproto.remove = function () {
      var node = getRealNode(this.node);
      if (this.removed || !node.parentNode) {
        return;
      }
      var paper = this.paper;
      paper.__set__ && paper.__set__.exclude(this);
      eve.unbind('raphael.*.*.' + this.id);
      if (this.gradient) {
        paper.defs.removeChild(this.gradient);
      }
      R._tear(this, paper);
      node.parentNode.removeChild(node);
      // Remove custom data for element
      this.removeData();
      for (var i in this) {
        this[i] = typeof this[i] == 'function' ? R._removedFactory(i) : null;
      }
      this.removed = true;
    };
    elproto._getBBox = function () {
      if (this.node.style.display == 'none') {
        this.show();
        var hide = true;
      }
      var canvasHidden = false, containerStyle;
      if (this.paper.canvas.parentElement) {
        containerStyle = this.paper.canvas.parentElement.style;
      }  //IE10+ can't find parentElement
      else if (this.paper.canvas.parentNode) {
        containerStyle = this.paper.canvas.parentNode.style;
      }
      if (containerStyle && containerStyle.display == 'none') {
        canvasHidden = true;
        containerStyle.display = '';
      }
      var bbox = {};
      try {
        bbox = this.node.getBBox();
      } catch (e) {
        // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
        bbox = {
          x: this.node.clientLeft,
          y: this.node.clientTop,
          width: this.node.clientWidth,
          height: this.node.clientHeight
        };
      } finally {
        bbox = bbox || {};
        if (canvasHidden) {
          containerStyle.display = 'none';
        }
      }
      hide && this.hide();
      return bbox;
    };
    /*\
     * Element.attr
     [ method ]
     **
     * Sets the attributes of the element.
     > Parameters
     - attrName (string) attribute’s name
     - value (string) value
     * or
     - params (object) object of name/value pairs
     * or
     - attrName (string) attribute’s name
     * or
     - attrNames (array) in this case method returns array of current values for given attribute names
     = (object) @Element if attrsName & value or params are passed in.
     = (...) value of the attribute if only attrsName is passed in.
     = (array) array of values of the attribute if attrsNames is passed in.
     = (object) object of attributes if nothing is passed in.
     > Possible parameters
     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
     o clip-rect (string) comma or space separated values: x, y, width and height
     o cursor (string) CSS type of the cursor
     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
     o fill (string) colour, gradient or image
     o fill-opacity (number)
     o font (string)
     o font-family (string)
     o font-size (number) font size in pixels
     o font-weight (string)
     o height (number)
     o href (string) URL, if specified element behaves as hyperlink
     o opacity (number)
     o path (string) SVG path string format
     o r (number) radius of the circle, ellipse or rounded corner on the rect
     o rx (number) horisontal radius of the ellipse
     o ry (number) vertical radius of the ellipse
     o src (string) image URL, only works for @Element.image element
     o stroke (string) stroke colour
     o stroke-dasharray (string) [“”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
     o stroke-miterlimit (number)
     o stroke-opacity (number)
     o stroke-width (number) stroke width in pixels, default is '1'
     o target (string) used with href
     o text (string) contents of the text element. Use `\n` for multiline text
     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
     o title (string) will create tooltip with a given text
     o transform (string) see @Element.transform
     o width (number)
     o x (number)
     o y (number)
     > Gradients
     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
     *
     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
     > Path String
     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
     > Colour Parsing
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
     #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
     #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
     #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
     #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
     # </ul>
    \*/
    elproto.attr = function (name, value) {
      if (this.removed) {
        return this;
      }
      if (name == null) {
        var res = {};
        for (var a in this.attrs)
          if (this.attrs[has](a)) {
            res[a] = this.attrs[a];
          }
        res.gradient && res.fill == 'none' && (res.fill = res.gradient) && delete res.gradient;
        res.transform = this._.transform;
        return res;
      }
      if (value == null && R.is(name, 'string')) {
        if (name == 'fill' && this.attrs.fill == 'none' && this.attrs.gradient) {
          return this.attrs.gradient;
        }
        if (name == 'transform') {
          return this._.transform;
        }
        var names = name.split(separator), out = {};
        for (var i = 0, ii = names.length; i < ii; i++) {
          name = names[i];
          if (name in this.attrs) {
            out[name] = this.attrs[name];
          } else if (R.is(this.paper.customAttributes[name], 'function')) {
            out[name] = this.paper.customAttributes[name].def;
          } else {
            out[name] = R._availableAttrs[name];
          }
        }
        return ii - 1 ? out : out[names[0]];
      }
      if (value == null && R.is(name, 'array')) {
        out = {};
        for (i = 0, ii = name.length; i < ii; i++) {
          out[name[i]] = this.attr(name[i]);
        }
        return out;
      }
      if (value != null) {
        var params = {};
        params[name] = value;
      } else if (name != null && R.is(name, 'object')) {
        params = name;
      }
      for (var key in params) {
        eve('raphael.attr.' + key + '.' + this.id, this, params[key]);
      }
      for (key in this.paper.customAttributes)
        if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], 'function')) {
          var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
          this.attrs[key] = params[key];
          for (var subkey in par)
            if (par[has](subkey)) {
              params[subkey] = par[subkey];
            }
        }
      setFillAndStroke(this, params);
      return this;
    };
    /*\
     * Element.toFront
     [ method ]
     **
     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
     = (object) @Element
    \*/
    elproto.toFront = function () {
      if (this.removed) {
        return this;
      }
      var node = getRealNode(this.node);
      node.parentNode.appendChild(node);
      var svg = this.paper;
      svg.top != this && R._tofront(this, svg);
      return this;
    };
    /*\
     * Element.toBack
     [ method ]
     **
     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
     = (object) @Element
    \*/
    elproto.toBack = function () {
      if (this.removed) {
        return this;
      }
      var node = getRealNode(this.node);
      var parentNode = node.parentNode;
      parentNode.insertBefore(node, parentNode.firstChild);
      R._toback(this, this.paper);
      var svg = this.paper;
      return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts current object after the given one.
     = (object) @Element
    \*/
    elproto.insertAfter = function (element) {
      if (this.removed || !element) {
        return this;
      }
      var node = getRealNode(this.node);
      var afterNode = getRealNode(element.node || element[element.length - 1].node);
      if (afterNode.nextSibling) {
        afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
      } else {
        afterNode.parentNode.appendChild(node);
      }
      R._insertafter(this, element, this.paper);
      return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts current object before the given one.
     = (object) @Element
    \*/
    elproto.insertBefore = function (element) {
      if (this.removed || !element) {
        return this;
      }
      var node = getRealNode(this.node);
      var beforeNode = getRealNode(element.node || element[0].node);
      beforeNode.parentNode.insertBefore(node, beforeNode);
      R._insertbefore(this, element, this.paper);
      return this;
    };
    elproto.blur = function (size) {
      // Experimental. No Safari support. Use it on your own risk.
      var t = this;
      if (+size !== 0) {
        var fltr = $('filter'), blur = $('feGaussianBlur');
        t.attrs.blur = size;
        fltr.id = R.createUUID();
        $(blur, { stdDeviation: +size || 1.5 });
        fltr.appendChild(blur);
        t.paper.defs.appendChild(fltr);
        t._blur = fltr;
        $(t.node, { filter: 'url(#' + fltr.id + ')' });
      } else {
        if (t._blur) {
          t._blur.parentNode.removeChild(t._blur);
          delete t._blur;
          delete t.attrs.blur;
        }
        t.node.removeAttribute('filter');
      }
      return t;
    };
    R._engine.circle = function (svg, x, y, r) {
      var el = $('circle');
      svg.canvas && svg.canvas.appendChild(el);
      var res = new Element(el, svg);
      res.attrs = {
        cx: x,
        cy: y,
        r: r,
        fill: 'none',
        stroke: '#000'
      };
      res.type = 'circle';
      $(el, res.attrs);
      return res;
    };
    R._engine.rect = function (svg, x, y, w, h, r) {
      var el = $('rect');
      svg.canvas && svg.canvas.appendChild(el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        width: w,
        height: h,
        rx: r || 0,
        ry: r || 0,
        fill: 'none',
        stroke: '#000'
      };
      res.type = 'rect';
      $(el, res.attrs);
      return res;
    };
    R._engine.ellipse = function (svg, x, y, rx, ry) {
      var el = $('ellipse');
      svg.canvas && svg.canvas.appendChild(el);
      var res = new Element(el, svg);
      res.attrs = {
        cx: x,
        cy: y,
        rx: rx,
        ry: ry,
        fill: 'none',
        stroke: '#000'
      };
      res.type = 'ellipse';
      $(el, res.attrs);
      return res;
    };
    R._engine.image = function (svg, src, x, y, w, h) {
      var el = $('image');
      $(el, {
        x: x,
        y: y,
        width: w,
        height: h,
        preserveAspectRatio: 'none'
      });
      el.setAttributeNS(xlink, 'href', src);
      svg.canvas && svg.canvas.appendChild(el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        width: w,
        height: h,
        src: src
      };
      res.type = 'image';
      return res;
    };
    R._engine.text = function (svg, x, y, text) {
      var el = $('text');
      svg.canvas && svg.canvas.appendChild(el);
      var res = new Element(el, svg);
      res.attrs = {
        x: x,
        y: y,
        'text-anchor': 'middle',
        text: text,
        'font-family': R._availableAttrs['font-family'],
        'font-size': R._availableAttrs['font-size'],
        stroke: 'none',
        fill: '#000'
      };
      res.type = 'text';
      setFillAndStroke(res, res.attrs);
      return res;
    };
    R._engine.setSize = function (width, height) {
      this.width = width || this.width;
      this.height = height || this.height;
      this.canvas.setAttribute('width', this.width);
      this.canvas.setAttribute('height', this.height);
      if (this._viewBox) {
        this.setViewBox.apply(this, this._viewBox);
      }
      return this;
    };
    R._engine.create = function () {
      var con = R._getContainer.apply(0, arguments), container = con && con.container, x = con.x, y = con.y, width = con.width, height = con.height;
      if (!container) {
        throw new Error('SVG container not found.');
      }
      var cnvs = $('svg'), css = 'overflow:hidden;', isFloating;
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      $(cnvs, {
        height: height,
        version: 1.1,
        width: width,
        xmlns: 'http://www.w3.org/2000/svg',
        'xmlns:xlink': 'http://www.w3.org/1999/xlink'
      });
      if (container == 1) {
        cnvs.style.cssText = css + 'position:absolute;left:' + x + 'px;top:' + y + 'px';
        R._g.doc.body.appendChild(cnvs);
        isFloating = 1;
      } else {
        cnvs.style.cssText = css + 'position:relative';
        if (container.firstChild) {
          container.insertBefore(cnvs, container.firstChild);
        } else {
          container.appendChild(cnvs);
        }
      }
      container = new R._Paper();
      container.width = width;
      container.height = height;
      container.canvas = cnvs;
      container.clear();
      container._left = container._top = 0;
      isFloating && (container.renderfix = function () {
      });
      container.renderfix();
      return container;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
      eve('raphael.setViewBox', this, this._viewBox, [
        x,
        y,
        w,
        h,
        fit
      ]);
      var paperSize = this.getSize(), size = mmax(w / paperSize.width, h / paperSize.height), top = this.top, aspectRatio = fit ? 'xMidYMid meet' : 'xMinYMin', vb, sw;
      if (x == null) {
        if (this._vbSize) {
          size = 1;
        }
        delete this._vbSize;
        vb = '0 0 ' + this.width + S + this.height;
      } else {
        this._vbSize = size;
        vb = x + S + y + S + w + S + h;
      }
      $(this.canvas, {
        viewBox: vb,
        preserveAspectRatio: aspectRatio
      });
      while (size && top) {
        sw = 'stroke-width' in top.attrs ? top.attrs['stroke-width'] : 1;
        top.attr({ 'stroke-width': sw });
        top._.dirty = 1;
        top._.dirtyT = 1;
        top = top.prev;
      }
      this._viewBox = [
        x,
        y,
        w,
        h,
        !!fit
      ];
      return this;
    };
    /*\
     * Paper.renderfix
     [ method ]
     **
     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
     * This method fixes the issue.
     **
       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
    \*/
    R.prototype.renderfix = function () {
      var cnvs = this.canvas, s = cnvs.style, pos;
      try {
        pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
      } catch (e) {
        pos = cnvs.createSVGMatrix();
      }
      var left = -pos.e % 1, top = -pos.f % 1;
      if (left || top) {
        if (left) {
          this._left = (this._left + left) % 1;
          s.left = this._left + 'px';
        }
        if (top) {
          this._top = (this._top + top) % 1;
          s.top = this._top + 'px';
        }
      }
    };
    /*\
     * Paper.clear
     [ method ]
     **
     * Clears the paper, i.e. removes all the elements.
    \*/
    R.prototype.clear = function () {
      R.eve('raphael.clear', this);
      var c = this.canvas;
      while (c.firstChild) {
        c.removeChild(c.firstChild);
      }
      this.bottom = this.top = null;
      (this.desc = $('desc')).appendChild(R._g.doc.createTextNode('Created with Rapha\xebl ' + R.version));
      c.appendChild(this.desc);
      c.appendChild(this.defs = $('defs'));
    };
    /*\
     * Paper.remove
     [ method ]
     **
     * Removes the paper from the DOM.
    \*/
    R.prototype.remove = function () {
      eve('raphael.remove', this);
      this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
      for (var i in this) {
        this[i] = typeof this[i] == 'function' ? R._removedFactory(i) : null;
      }
    };
    var setproto = R.st;
    for (var method in elproto)
      if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = function (methodname) {
          return function () {
            var arg = arguments;
            return this.forEach(function (el) {
              el[methodname].apply(el, arg);
            });
          };
        }(method);
      }
  }());
  // ┌─────────────────────────────────────────────────────────────────────┐ \\
  // │ Raphaël - JavaScript Vector Library                                 │ \\
  // ├─────────────────────────────────────────────────────────────────────┤ \\
  // │ VML Module                                                          │ \\
  // ├─────────────────────────────────────────────────────────────────────┤ \\
  // │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
  // │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
  // │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
  // └─────────────────────────────────────────────────────────────────────┘ \\
  (function () {
    if (!R.vml) {
      return;
    }
    var has = 'hasOwnProperty', Str = String, toFloat = parseFloat, math = Math, round = math.round, mmax = math.max, mmin = math.min, abs = math.abs, fillString = 'fill', separator = /[, ]+/, eve = R.eve, ms = ' progid:DXImageTransform.Microsoft', S = ' ', E = '', map = {
        M: 'm',
        L: 'l',
        C: 'c',
        Z: 'x',
        m: 't',
        l: 'r',
        c: 'v',
        z: 'x'
      }, bites = /([clmz]),?([^clmz]*)/gi, blurregexp = / progid:\S+Blur\([^\)]+\)/g, val = /-?[^,\s-]+/g, cssDot = 'position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)', zoom = 21600, pathTypes = {
        path: 1,
        rect: 1,
        image: 1
      }, ovalTypes = {
        circle: 1,
        ellipse: 1
      }, path2vml = function (path) {
        var total = /[ahqstv]/gi, command = R._pathToAbsolute;
        Str(path).match(total) && (command = R._path2curve);
        total = /[clmz]/g;
        if (command == R._pathToAbsolute && !Str(path).match(total)) {
          var res = Str(path).replace(bites, function (all, command, args) {
              var vals = [], isMove = command.toLowerCase() == 'm', res = map[command];
              args.replace(val, function (value) {
                if (isMove && vals.length == 2) {
                  res += vals + map[command == 'm' ? 'l' : 'L'];
                  vals = [];
                }
                vals.push(round(value * zoom));
              });
              return res + vals;
            });
          return res;
        }
        var pa = command(path), p, r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
          p = pa[i];
          r = pa[i][0].toLowerCase();
          r == 'z' && (r = 'x');
          for (var j = 1, jj = p.length; j < jj; j++) {
            r += round(p[j] * zoom) + (j != jj - 1 ? ',' : E);
          }
          res.push(r);
        }
        return res.join(S);
      }, compensation = function (deg, dx, dy) {
        var m = R.matrix();
        m.rotate(-deg, 0.5, 0.5);
        return {
          dx: m.x(dx, dy),
          dy: m.y(dx, dy)
        };
      }, setCoords = function (p, sx, sy, dx, dy, deg) {
        var _ = p._, m = p.matrix, fillpos = _.fillpos, o = p.node, s = o.style, y = 1, flip = '', dxdy, kx = zoom / sx, ky = zoom / sy;
        s.visibility = 'hidden';
        if (!sx || !sy) {
          return;
        }
        o.coordsize = abs(kx) + S + abs(ky);
        s.rotation = deg * (sx * sy < 0 ? -1 : 1);
        if (deg) {
          var c = compensation(deg, dx, dy);
          dx = c.dx;
          dy = c.dy;
        }
        sx < 0 && (flip += 'x');
        sy < 0 && (flip += ' y') && (y = -1);
        s.flip = flip;
        o.coordorigin = dx * -kx + S + dy * -ky;
        if (fillpos || _.fillsize) {
          var fill = o.getElementsByTagName(fillString);
          fill = fill && fill[0];
          o.removeChild(fill);
          if (fillpos) {
            c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
            fill.position = c.dx * y + S + c.dy * y;
          }
          if (_.fillsize) {
            fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
          }
          o.appendChild(fill);
        }
        s.visibility = 'visible';
      };
    R.toString = function () {
      return 'Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl ' + this.version;
    };
    var addArrow = function (o, value, isEnd) {
        var values = Str(value).toLowerCase().split('-'), se = isEnd ? 'end' : 'start', i = values.length, type = 'classic', w = 'medium', h = 'medium';
        while (i--) {
          switch (values[i]) {
          case 'block':
          case 'classic':
          case 'oval':
          case 'diamond':
          case 'open':
          case 'none':
            type = values[i];
            break;
          case 'wide':
          case 'narrow':
            h = values[i];
            break;
          case 'long':
          case 'short':
            w = values[i];
            break;
          }
        }
        var stroke = o.node.getElementsByTagName('stroke')[0];
        stroke[se + 'arrow'] = type;
        stroke[se + 'arrowlength'] = w;
        stroke[se + 'arrowwidth'] = h;
      }, setFillAndStroke = function (o, params) {
        // o.paper.canvas.style.display = "none";
        o.attrs = o.attrs || {};
        var node = o.node, a = o.attrs, s = node.style, xy, newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r), isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry), res = o;
        for (var par in params)
          if (params[has](par)) {
            a[par] = params[par];
          }
        if (newpath) {
          a.path = R._getPath[o.type](o);
          o._.dirty = 1;
        }
        params.href && (node.href = params.href);
        params.title && (node.title = params.title);
        params.target && (node.target = params.target);
        params.cursor && (s.cursor = params.cursor);
        'blur' in params && o.blur(params.blur);
        if (params.path && o.type == 'path' || newpath) {
          node.path = path2vml(~Str(a.path).toLowerCase().indexOf('r') ? R._pathToAbsolute(a.path) : a.path);
          o._.dirty = 1;
          if (o.type == 'image') {
            o._.fillpos = [
              a.x,
              a.y
            ];
            o._.fillsize = [
              a.width,
              a.height
            ];
            setCoords(o, 1, 1, 0, 0, 0);
          }
        }
        'transform' in params && o.transform(params.transform);
        if (isOval) {
          var cx = +a.cx, cy = +a.cy, rx = +a.rx || +a.r || 0, ry = +a.ry || +a.r || 0;
          node.path = R.format('ar{0},{1},{2},{3},{4},{1},{4},{1}x', round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
          o._.dirty = 1;
        }
        if ('clip-rect' in params) {
          var rect = Str(params['clip-rect']).split(separator);
          if (rect.length == 4) {
            rect[2] = +rect[2] + +rect[0];
            rect[3] = +rect[3] + +rect[1];
            var div = node.clipRect || R._g.doc.createElement('div'), dstyle = div.style;
            dstyle.clip = R.format('rect({1}px {2}px {3}px {0}px)', rect);
            if (!node.clipRect) {
              dstyle.position = 'absolute';
              dstyle.top = 0;
              dstyle.left = 0;
              dstyle.width = o.paper.width + 'px';
              dstyle.height = o.paper.height + 'px';
              node.parentNode.insertBefore(div, node);
              div.appendChild(node);
              node.clipRect = div;
            }
          }
          if (!params['clip-rect']) {
            node.clipRect && (node.clipRect.style.clip = 'auto');
          }
        }
        if (o.textpath) {
          var textpathStyle = o.textpath.style;
          params.font && (textpathStyle.font = params.font);
          params['font-family'] && (textpathStyle.fontFamily = '"' + params['font-family'].split(',')[0].replace(/^['"]+|['"]+$/g, E) + '"');
          params['font-size'] && (textpathStyle.fontSize = params['font-size']);
          params['font-weight'] && (textpathStyle.fontWeight = params['font-weight']);
          params['font-style'] && (textpathStyle.fontStyle = params['font-style']);
        }
        if ('arrow-start' in params) {
          addArrow(res, params['arrow-start']);
        }
        if ('arrow-end' in params) {
          addArrow(res, params['arrow-end'], 1);
        }
        if (params.opacity != null || params['stroke-width'] != null || params.fill != null || params.src != null || params.stroke != null || params['stroke-width'] != null || params['stroke-opacity'] != null || params['fill-opacity'] != null || params['stroke-dasharray'] != null || params['stroke-miterlimit'] != null || params['stroke-linejoin'] != null || params['stroke-linecap'] != null) {
          var fill = node.getElementsByTagName(fillString), newfill = false;
          fill = fill && fill[0];
          !fill && (newfill = fill = createNode(fillString));
          if (o.type == 'image' && params.src) {
            fill.src = params.src;
          }
          params.fill && (fill.on = true);
          if (fill.on == null || params.fill == 'none' || params.fill === null) {
            fill.on = false;
          }
          if (fill.on && params.fill) {
            var isURL = Str(params.fill).match(R._ISURL);
            if (isURL) {
              fill.parentNode == node && node.removeChild(fill);
              fill.rotate = true;
              fill.src = isURL[1];
              fill.type = 'tile';
              var bbox = o.getBBox(1);
              fill.position = bbox.x + S + bbox.y;
              o._.fillpos = [
                bbox.x,
                bbox.y
              ];
              R._preload(isURL[1], function () {
                o._.fillsize = [
                  this.offsetWidth,
                  this.offsetHeight
                ];
              });
            } else {
              fill.color = R.getRGB(params.fill).hex;
              fill.src = E;
              fill.type = 'solid';
              if (R.getRGB(params.fill).error && (res.type in {
                  circle: 1,
                  ellipse: 1
                } || Str(params.fill).charAt() != 'r') && addGradientFill(res, params.fill, fill)) {
                a.fill = 'none';
                a.gradient = params.fill;
                fill.rotate = false;
              }
            }
          }
          if ('fill-opacity' in params || 'opacity' in params) {
            var opacity = ((+a['fill-opacity'] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
            opacity = mmin(mmax(opacity, 0), 1);
            fill.opacity = opacity;
            if (fill.src) {
              fill.color = 'none';
            }
          }
          node.appendChild(fill);
          var stroke = node.getElementsByTagName('stroke') && node.getElementsByTagName('stroke')[0], newstroke = false;
          !stroke && (newstroke = stroke = createNode('stroke'));
          if (params.stroke && params.stroke != 'none' || params['stroke-width'] || params['stroke-opacity'] != null || params['stroke-dasharray'] || params['stroke-miterlimit'] || params['stroke-linejoin'] || params['stroke-linecap']) {
            stroke.on = true;
          }
          (params.stroke == 'none' || params.stroke === null || stroke.on == null || params.stroke == 0 || params['stroke-width'] == 0) && (stroke.on = false);
          var strokeColor = R.getRGB(params.stroke);
          stroke.on && params.stroke && (stroke.color = strokeColor.hex);
          opacity = ((+a['stroke-opacity'] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
          var width = (toFloat(params['stroke-width']) || 1) * 0.75;
          opacity = mmin(mmax(opacity, 0), 1);
          params['stroke-width'] == null && (width = a['stroke-width']);
          params['stroke-width'] && (stroke.weight = width);
          width && width < 1 && (opacity *= width) && (stroke.weight = 1);
          stroke.opacity = opacity;
          params['stroke-linejoin'] && (stroke.joinstyle = params['stroke-linejoin'] || 'miter');
          stroke.miterlimit = params['stroke-miterlimit'] || 8;
          params['stroke-linecap'] && (stroke.endcap = params['stroke-linecap'] == 'butt' ? 'flat' : params['stroke-linecap'] == 'square' ? 'square' : 'round');
          if ('stroke-dasharray' in params) {
            var dasharray = {
                '-': 'shortdash',
                '.': 'shortdot',
                '-.': 'shortdashdot',
                '-..': 'shortdashdotdot',
                '. ': 'dot',
                '- ': 'dash',
                '--': 'longdash',
                '- .': 'dashdot',
                '--.': 'longdashdot',
                '--..': 'longdashdotdot'
              };
            stroke.dashstyle = dasharray[has](params['stroke-dasharray']) ? dasharray[params['stroke-dasharray']] : E;
          }
          newstroke && node.appendChild(stroke);
        }
        if (res.type == 'text') {
          res.paper.canvas.style.display = E;
          var span = res.paper.span, m = 100, fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
          s = span.style;
          a.font && (s.font = a.font);
          a['font-family'] && (s.fontFamily = a['font-family']);
          a['font-weight'] && (s.fontWeight = a['font-weight']);
          a['font-style'] && (s.fontStyle = a['font-style']);
          fontSize = toFloat(a['font-size'] || fontSize && fontSize[0]) || 10;
          s.fontSize = fontSize * m + 'px';
          res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, '&#60;').replace(/&/g, '&#38;').replace(/\n/g, '<br>'));
          var brect = span.getBoundingClientRect();
          res.W = a.w = (brect.right - brect.left) / m;
          res.H = a.h = (brect.bottom - brect.top) / m;
          // res.paper.canvas.style.display = "none";
          res.X = a.x;
          res.Y = a.y + res.H / 2;
          ('x' in params || 'y' in params) && (res.path.v = R.format('m{0},{1}l{2},{1}', round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
          var dirtyattrs = [
              'x',
              'y',
              'text',
              'font',
              'font-family',
              'font-weight',
              'font-style',
              'font-size'
            ];
          for (var d = 0, dd = dirtyattrs.length; d < dd; d++)
            if (dirtyattrs[d] in params) {
              res._.dirty = 1;
              break;
            }
          // text-anchor emulation
          switch (a['text-anchor']) {
          case 'start':
            res.textpath.style['v-text-align'] = 'left';
            res.bbx = res.W / 2;
            break;
          case 'end':
            res.textpath.style['v-text-align'] = 'right';
            res.bbx = -res.W / 2;
            break;
          default:
            res.textpath.style['v-text-align'] = 'center';
            res.bbx = 0;
            break;
          }
          res.textpath.style['v-text-kern'] = true;
        }  // res.paper.canvas.style.display = E;
      }, addGradientFill = function (o, gradient, fill) {
        o.attrs = o.attrs || {};
        var attrs = o.attrs, pow = Math.pow, opacity, oindex, type = 'linear', fxfy = '.5 .5';
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
          type = 'radial';
          if (fx && fy) {
            fx = toFloat(fx);
            fy = toFloat(fy);
            pow(fx - 0.5, 2) + pow(fy - 0.5, 2) > 0.25 && (fy = math.sqrt(0.25 - pow(fx - 0.5, 2)) * ((fy > 0.5) * 2 - 1) + 0.5);
            fxfy = fx + S + fy;
          }
          return E;
        });
        gradient = gradient.split(/\s*\-\s*/);
        if (type == 'linear') {
          var angle = gradient.shift();
          angle = -toFloat(angle);
          if (isNaN(angle)) {
            return null;
          }
        }
        var dots = R._parseDots(gradient);
        if (!dots) {
          return null;
        }
        o = o.shape || o.node;
        if (dots.length) {
          o.removeChild(fill);
          fill.on = true;
          fill.method = 'none';
          fill.color = dots[0].color;
          fill.color2 = dots[dots.length - 1].color;
          var clrs = [];
          for (var i = 0, ii = dots.length; i < ii; i++) {
            dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
          }
          fill.colors = clrs.length ? clrs.join() : '0% ' + fill.color;
          if (type == 'radial') {
            fill.type = 'gradientTitle';
            fill.focus = '100%';
            fill.focussize = '0 0';
            fill.focusposition = fxfy;
            fill.angle = 0;
          } else {
            // fill.rotate= true;
            fill.type = 'gradient';
            fill.angle = (270 - angle) % 360;
          }
          o.appendChild(fill);
        }
        return 1;
      }, Element = function (node, vml) {
        this[0] = this.node = node;
        node.raphael = true;
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.X = 0;
        this.Y = 0;
        this.attrs = {};
        this.paper = vml;
        this.matrix = R.matrix();
        this._ = {
          transform: [],
          sx: 1,
          sy: 1,
          dx: 0,
          dy: 0,
          deg: 0,
          dirty: 1,
          dirtyT: 1
        };
        !vml.bottom && (vml.bottom = this);
        this.prev = vml.top;
        vml.top && (vml.top.next = this);
        vml.top = this;
        this.next = null;
      };
    var elproto = R.el;
    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = function (tstr) {
      if (tstr == null) {
        return this._.transform;
      }
      var vbs = this.paper._viewBoxShift, vbt = vbs ? 's' + [
          vbs.scale,
          vbs.scale
        ] + '-1-1t' + [
          vbs.dx,
          vbs.dy
        ] : E, oldt;
      if (vbs) {
        oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
      }
      R._extractTransform(this, vbt + tstr);
      var matrix = this.matrix.clone(), skew = this.skew, o = this.node, split, isGrad = ~Str(this.attrs.fill).indexOf('-'), isPatt = !Str(this.attrs.fill).indexOf('url(');
      matrix.translate(1, 1);
      if (isPatt || isGrad || this.type == 'image') {
        skew.matrix = '1 0 0 1';
        skew.offset = '0 0';
        split = matrix.split();
        if (isGrad && split.noRotation || !split.isSimple) {
          o.style.filter = matrix.toFilter();
          var bb = this.getBBox(), bbt = this.getBBox(1), dx = bb.x - bbt.x, dy = bb.y - bbt.y;
          o.coordorigin = dx * -zoom + S + dy * -zoom;
          setCoords(this, 1, 1, dx, dy, 0);
        } else {
          o.style.filter = E;
          setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
        }
      } else {
        o.style.filter = E;
        skew.matrix = Str(matrix);
        skew.offset = matrix.offset();
      }
      if (oldt !== null) {
        // empty string value is true as well
        this._.transform = oldt;
        R._extractTransform(this, oldt);
      }
      return this;
    };
    elproto.rotate = function (deg, cx, cy) {
      if (this.removed) {
        return this;
      }
      if (deg == null) {
        return;
      }
      deg = Str(deg).split(separator);
      if (deg.length - 1) {
        cx = toFloat(deg[1]);
        cy = toFloat(deg[2]);
      }
      deg = toFloat(deg[0]);
      cy == null && (cx = cy);
      if (cx == null || cy == null) {
        var bbox = this.getBBox(1);
        cx = bbox.x + bbox.width / 2;
        cy = bbox.y + bbox.height / 2;
      }
      this._.dirtyT = 1;
      this.transform(this._.transform.concat([[
          'r',
          deg,
          cx,
          cy
        ]]));
      return this;
    };
    elproto.translate = function (dx, dy) {
      if (this.removed) {
        return this;
      }
      dx = Str(dx).split(separator);
      if (dx.length - 1) {
        dy = toFloat(dx[1]);
      }
      dx = toFloat(dx[0]) || 0;
      dy = +dy || 0;
      if (this._.bbox) {
        this._.bbox.x += dx;
        this._.bbox.y += dy;
      }
      this.transform(this._.transform.concat([[
          't',
          dx,
          dy
        ]]));
      return this;
    };
    elproto.scale = function (sx, sy, cx, cy) {
      if (this.removed) {
        return this;
      }
      sx = Str(sx).split(separator);
      if (sx.length - 1) {
        sy = toFloat(sx[1]);
        cx = toFloat(sx[2]);
        cy = toFloat(sx[3]);
        isNaN(cx) && (cx = null);
        isNaN(cy) && (cy = null);
      }
      sx = toFloat(sx[0]);
      sy == null && (sy = sx);
      cy == null && (cx = cy);
      if (cx == null || cy == null) {
        var bbox = this.getBBox(1);
      }
      cx = cx == null ? bbox.x + bbox.width / 2 : cx;
      cy = cy == null ? bbox.y + bbox.height / 2 : cy;
      this.transform(this._.transform.concat([[
          's',
          sx,
          sy,
          cx,
          cy
        ]]));
      this._.dirtyT = 1;
      return this;
    };
    elproto.hide = function () {
      !this.removed && (this.node.style.display = 'none');
      return this;
    };
    elproto.show = function () {
      !this.removed && (this.node.style.display = E);
      return this;
    };
    // Needed to fix the vml setViewBox issues
    elproto.auxGetBBox = R.el.getBBox;
    elproto.getBBox = function () {
      var b = this.auxGetBBox();
      if (this.paper && this.paper._viewBoxShift) {
        var c = {};
        var z = 1 / this.paper._viewBoxShift.scale;
        c.x = b.x - this.paper._viewBoxShift.dx;
        c.x *= z;
        c.y = b.y - this.paper._viewBoxShift.dy;
        c.y *= z;
        c.width = b.width * z;
        c.height = b.height * z;
        c.x2 = c.x + c.width;
        c.y2 = c.y + c.height;
        return c;
      }
      return b;
    };
    elproto._getBBox = function () {
      if (this.removed) {
        return {};
      }
      return {
        x: this.X + (this.bbx || 0) - this.W / 2,
        y: this.Y - this.H,
        width: this.W,
        height: this.H
      };
    };
    elproto.remove = function () {
      if (this.removed || !this.node.parentNode) {
        return;
      }
      this.paper.__set__ && this.paper.__set__.exclude(this);
      R.eve.unbind('raphael.*.*.' + this.id);
      R._tear(this, this.paper);
      this.node.parentNode.removeChild(this.node);
      this.shape && this.shape.parentNode.removeChild(this.shape);
      for (var i in this) {
        this[i] = typeof this[i] == 'function' ? R._removedFactory(i) : null;
      }
      this.removed = true;
    };
    elproto.attr = function (name, value) {
      if (this.removed) {
        return this;
      }
      if (name == null) {
        var res = {};
        for (var a in this.attrs)
          if (this.attrs[has](a)) {
            res[a] = this.attrs[a];
          }
        res.gradient && res.fill == 'none' && (res.fill = res.gradient) && delete res.gradient;
        res.transform = this._.transform;
        return res;
      }
      if (value == null && R.is(name, 'string')) {
        if (name == fillString && this.attrs.fill == 'none' && this.attrs.gradient) {
          return this.attrs.gradient;
        }
        var names = name.split(separator), out = {};
        for (var i = 0, ii = names.length; i < ii; i++) {
          name = names[i];
          if (name in this.attrs) {
            out[name] = this.attrs[name];
          } else if (R.is(this.paper.customAttributes[name], 'function')) {
            out[name] = this.paper.customAttributes[name].def;
          } else {
            out[name] = R._availableAttrs[name];
          }
        }
        return ii - 1 ? out : out[names[0]];
      }
      if (this.attrs && value == null && R.is(name, 'array')) {
        out = {};
        for (i = 0, ii = name.length; i < ii; i++) {
          out[name[i]] = this.attr(name[i]);
        }
        return out;
      }
      var params;
      if (value != null) {
        params = {};
        params[name] = value;
      }
      value == null && R.is(name, 'object') && (params = name);
      for (var key in params) {
        eve('raphael.attr.' + key + '.' + this.id, this, params[key]);
      }
      if (params) {
        for (key in this.paper.customAttributes)
          if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], 'function')) {
            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (var subkey in par)
              if (par[has](subkey)) {
                params[subkey] = par[subkey];
              }
          }
        // this.paper.canvas.style.display = "none";
        if (params.text && this.type == 'text') {
          this.textpath.string = params.text;
        }
        setFillAndStroke(this, params);  // this.paper.canvas.style.display = E;
      }
      return this;
    };
    elproto.toFront = function () {
      !this.removed && this.node.parentNode.appendChild(this.node);
      this.paper && this.paper.top != this && R._tofront(this, this.paper);
      return this;
    };
    elproto.toBack = function () {
      if (this.removed) {
        return this;
      }
      if (this.node.parentNode.firstChild != this.node) {
        this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
        R._toback(this, this.paper);
      }
      return this;
    };
    elproto.insertAfter = function (element) {
      if (this.removed) {
        return this;
      }
      if (element.constructor == R.st.constructor) {
        element = element[element.length - 1];
      }
      if (element.node.nextSibling) {
        element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
      } else {
        element.node.parentNode.appendChild(this.node);
      }
      R._insertafter(this, element, this.paper);
      return this;
    };
    elproto.insertBefore = function (element) {
      if (this.removed) {
        return this;
      }
      if (element.constructor == R.st.constructor) {
        element = element[0];
      }
      element.node.parentNode.insertBefore(this.node, element.node);
      R._insertbefore(this, element, this.paper);
      return this;
    };
    elproto.blur = function (size) {
      var s = this.node.runtimeStyle, f = s.filter;
      f = f.replace(blurregexp, E);
      if (+size !== 0) {
        this.attrs.blur = size;
        s.filter = f + S + ms + '.Blur(pixelradius=' + (+size || 1.5) + ')';
        s.margin = R.format('-{0}px 0 0 -{0}px', round(+size || 1.5));
      } else {
        s.filter = f;
        s.margin = 0;
        delete this.attrs.blur;
      }
      return this;
    };
    R._engine.path = function (pathString, vml) {
      var el = createNode('shape');
      el.style.cssText = cssDot;
      el.coordsize = zoom + S + zoom;
      el.coordorigin = vml.coordorigin;
      var p = new Element(el, vml), attr = {
          fill: 'none',
          stroke: '#000'
        };
      pathString && (attr.path = pathString);
      p.type = 'path';
      p.path = [];
      p.Path = E;
      setFillAndStroke(p, attr);
      vml.canvas.appendChild(el);
      var skew = createNode('skew');
      skew.on = true;
      el.appendChild(skew);
      p.skew = skew;
      p.transform(E);
      return p;
    };
    R._engine.rect = function (vml, x, y, w, h, r) {
      var path = R._rectPath(x, y, w, h, r), res = vml.path(path), a = res.attrs;
      res.X = a.x = x;
      res.Y = a.y = y;
      res.W = a.width = w;
      res.H = a.height = h;
      a.r = r;
      a.path = path;
      res.type = 'rect';
      return res;
    };
    R._engine.ellipse = function (vml, x, y, rx, ry) {
      var res = vml.path(), a = res.attrs;
      res.X = x - rx;
      res.Y = y - ry;
      res.W = rx * 2;
      res.H = ry * 2;
      res.type = 'ellipse';
      setFillAndStroke(res, {
        cx: x,
        cy: y,
        rx: rx,
        ry: ry
      });
      return res;
    };
    R._engine.circle = function (vml, x, y, r) {
      var res = vml.path(), a = res.attrs;
      res.X = x - r;
      res.Y = y - r;
      res.W = res.H = r * 2;
      res.type = 'circle';
      setFillAndStroke(res, {
        cx: x,
        cy: y,
        r: r
      });
      return res;
    };
    R._engine.image = function (vml, src, x, y, w, h) {
      var path = R._rectPath(x, y, w, h), res = vml.path(path).attr({ stroke: 'none' }), a = res.attrs, node = res.node, fill = node.getElementsByTagName(fillString)[0];
      a.src = src;
      res.X = a.x = x;
      res.Y = a.y = y;
      res.W = a.width = w;
      res.H = a.height = h;
      a.path = path;
      res.type = 'image';
      fill.parentNode == node && node.removeChild(fill);
      fill.rotate = true;
      fill.src = src;
      fill.type = 'tile';
      res._.fillpos = [
        x,
        y
      ];
      res._.fillsize = [
        w,
        h
      ];
      node.appendChild(fill);
      setCoords(res, 1, 1, 0, 0, 0);
      return res;
    };
    R._engine.text = function (vml, x, y, text) {
      var el = createNode('shape'), path = createNode('path'), o = createNode('textpath');
      x = x || 0;
      y = y || 0;
      text = text || '';
      path.v = R.format('m{0},{1}l{2},{1}', round(x * zoom), round(y * zoom), round(x * zoom) + 1);
      path.textpathok = true;
      o.string = Str(text);
      o.on = true;
      el.style.cssText = cssDot;
      el.coordsize = zoom + S + zoom;
      el.coordorigin = '0 0';
      var p = new Element(el, vml), attr = {
          fill: '#000',
          stroke: 'none',
          font: R._availableAttrs.font,
          text: text
        };
      p.shape = el;
      p.path = path;
      p.textpath = o;
      p.type = 'text';
      p.attrs.text = Str(text);
      p.attrs.x = x;
      p.attrs.y = y;
      p.attrs.w = 1;
      p.attrs.h = 1;
      setFillAndStroke(p, attr);
      el.appendChild(o);
      el.appendChild(path);
      vml.canvas.appendChild(el);
      var skew = createNode('skew');
      skew.on = true;
      el.appendChild(skew);
      p.skew = skew;
      p.transform(E);
      return p;
    };
    R._engine.setSize = function (width, height) {
      var cs = this.canvas.style;
      this.width = width;
      this.height = height;
      width == +width && (width += 'px');
      height == +height && (height += 'px');
      cs.width = width;
      cs.height = height;
      cs.clip = 'rect(0 ' + width + ' ' + height + ' 0)';
      if (this._viewBox) {
        R._engine.setViewBox.apply(this, this._viewBox);
      }
      return this;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
      R.eve('raphael.setViewBox', this, this._viewBox, [
        x,
        y,
        w,
        h,
        fit
      ]);
      var paperSize = this.getSize(), width = paperSize.width, height = paperSize.height, H, W;
      if (fit) {
        H = height / h;
        W = width / w;
        if (w * H < width) {
          x -= (width - w * H) / 2 / H;
        }
        if (h * W < height) {
          y -= (height - h * W) / 2 / W;
        }
      }
      this._viewBox = [
        x,
        y,
        w,
        h,
        !!fit
      ];
      this._viewBoxShift = {
        dx: -x,
        dy: -y,
        scale: paperSize
      };
      this.forEach(function (el) {
        el.transform('...');
      });
      return this;
    };
    var createNode;
    R._engine.initWin = function (win) {
      var doc = win.document;
      if (doc.styleSheets.length < 31) {
        doc.createStyleSheet().addRule('.rvml', 'behavior:url(#default#VML)');
      } else {
        // no more room, add to the existing one
        // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
        doc.styleSheets[0].addRule('.rvml', 'behavior:url(#default#VML)');
      }
      try {
        !doc.namespaces.rvml && doc.namespaces.add('rvml', 'urn:schemas-microsoft-com:vml');
        createNode = function (tagName) {
          return doc.createElement('<rvml:' + tagName + ' class="rvml">');
        };
      } catch (e) {
        createNode = function (tagName) {
          return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
        };
      }
    };
    R._engine.initWin(R._g.win);
    R._engine.create = function () {
      var con = R._getContainer.apply(0, arguments), container = con.container, height = con.height, s, width = con.width, x = con.x, y = con.y;
      if (!container) {
        throw new Error('VML container not found.');
      }
      var res = new R._Paper(), c = res.canvas = R._g.doc.createElement('div'), cs = c.style;
      x = x || 0;
      y = y || 0;
      width = width || 512;
      height = height || 342;
      res.width = width;
      res.height = height;
      width == +width && (width += 'px');
      height == +height && (height += 'px');
      res.coordsize = zoom * 1000 + S + zoom * 1000;
      res.coordorigin = '0 0';
      res.span = R._g.doc.createElement('span');
      res.span.style.cssText = 'position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;';
      c.appendChild(res.span);
      cs.cssText = R.format('top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden', width, height);
      if (container == 1) {
        R._g.doc.body.appendChild(c);
        cs.left = x + 'px';
        cs.top = y + 'px';
        cs.position = 'absolute';
      } else {
        if (container.firstChild) {
          container.insertBefore(c, container.firstChild);
        } else {
          container.appendChild(c);
        }
      }
      res.renderfix = function () {
      };
      return res;
    };
    R.prototype.clear = function () {
      R.eve('raphael.clear', this);
      this.canvas.innerHTML = E;
      this.span = R._g.doc.createElement('span');
      this.span.style.cssText = 'position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;';
      this.canvas.appendChild(this.span);
      this.bottom = this.top = null;
    };
    R.prototype.remove = function () {
      R.eve('raphael.remove', this);
      this.canvas.parentNode.removeChild(this.canvas);
      for (var i in this) {
        this[i] = typeof this[i] == 'function' ? R._removedFactory(i) : null;
      }
      return true;
    };
    var setproto = R.st;
    for (var method in elproto)
      if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = function (methodname) {
          return function () {
            var arg = arguments;
            return this.forEach(function (el) {
              el[methodname].apply(el, arg);
            });
          };
        }(method);
      }
  }());
  // EXPOSE
  // SVG and VML are appended just before the EXPOSE line
  // Even with AMD, Raphael should be defined globally
  oldRaphael.was ? g.win.Raphael = R : Raphael = R;
  if (typeof exports == 'object') {
    module.exports = R;
  }
  return R;
}));/* @license
morris.js v0.5.0
Copyright 2014 Olly Smith All rights reserved.
Licensed under the BSD-2-Clause License.
*/
(function () {
  var $, Morris, minutesSpecHelper, secondsSpecHelper, __slice = [].slice, __bind = function (fn, me) {
      return function () {
        return fn.apply(me, arguments);
      };
    }, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, __indexOf = [].indexOf || function (item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
  Morris = window.Morris = {};
  $ = jQuery;
  Morris.EventEmitter = function () {
    function EventEmitter() {
    }
    EventEmitter.prototype.on = function (name, handler) {
      if (this.handlers == null) {
        this.handlers = {};
      }
      if (this.handlers[name] == null) {
        this.handlers[name] = [];
      }
      this.handlers[name].push(handler);
      return this;
    };
    EventEmitter.prototype.fire = function () {
      var args, handler, name, _i, _len, _ref, _results;
      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.handlers != null && this.handlers[name] != null) {
        _ref = this.handlers[name];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          handler = _ref[_i];
          _results.push(handler.apply(null, args));
        }
        return _results;
      }
    };
    return EventEmitter;
  }();
  Morris.commas = function (num) {
    var absnum, intnum, ret, strabsnum;
    if (num != null) {
      ret = num < 0 ? '-' : '';
      absnum = Math.abs(num);
      intnum = Math.floor(absnum).toFixed(0);
      ret += intnum.replace(/(?=(?:\d{3})+$)(?!^)/g, ',');
      strabsnum = absnum.toString();
      if (strabsnum.length > intnum.length) {
        ret += strabsnum.slice(intnum.length);
      }
      return ret;
    } else {
      return '-';
    }
  };
  Morris.pad2 = function (number) {
    return (number < 10 ? '0' : '') + number;
  };
  Morris.Grid = function (_super) {
    __extends(Grid, _super);
    function Grid(options) {
      this.resizeHandler = __bind(this.resizeHandler, this);
      var _this = this;
      if (typeof options.element === 'string') {
        this.el = $(document.getElementById(options.element));
      } else {
        this.el = $(options.element);
      }
      if (this.el == null || this.el.length === 0) {
        throw new Error('Graph container element not found');
      }
      if (this.el.css('position') === 'static') {
        this.el.css('position', 'relative');
      }
      this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);
      if (typeof this.options.units === 'string') {
        this.options.postUnits = options.units;
      }
      this.raphael = new Raphael(this.el[0]);
      this.elementWidth = null;
      this.elementHeight = null;
      this.dirty = false;
      this.selectFrom = null;
      if (this.init) {
        this.init();
      }
      this.setData(this.options.data);
      this.el.bind('mousemove', function (evt) {
        var left, offset, right, width, x;
        offset = _this.el.offset();
        x = evt.pageX - offset.left;
        if (_this.selectFrom) {
          left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;
          right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;
          width = right - left;
          return _this.selectionRect.attr({
            x: left,
            width: width
          });
        } else {
          return _this.fire('hovermove', x, evt.pageY - offset.top);
        }
      });
      this.el.bind('mouseleave', function (evt) {
        if (_this.selectFrom) {
          _this.selectionRect.hide();
          _this.selectFrom = null;
        }
        return _this.fire('hoverout');
      });
      this.el.bind('touchstart touchmove touchend', function (evt) {
        var offset, touch;
        touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
        offset = _this.el.offset();
        return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);
      });
      this.el.bind('click', function (evt) {
        var offset;
        offset = _this.el.offset();
        return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);
      });
      if (this.options.rangeSelect) {
        this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
          fill: this.options.rangeSelectColor,
          stroke: false
        }).toBack().hide();
        this.el.bind('mousedown', function (evt) {
          var offset;
          offset = _this.el.offset();
          return _this.startRange(evt.pageX - offset.left);
        });
        this.el.bind('mouseup', function (evt) {
          var offset;
          offset = _this.el.offset();
          _this.endRange(evt.pageX - offset.left);
          return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);
        });
      }
      if (this.options.resize) {
        $(window).bind('resize', function (evt) {
          if (_this.timeoutId != null) {
            window.clearTimeout(_this.timeoutId);
          }
          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
        });
      }
      this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
      if (this.postInit) {
        this.postInit();
      }
    }
    Grid.prototype.gridDefaults = {
      dateFormat: null,
      axes: true,
      grid: true,
      gridLineColor: '#aaa',
      gridStrokeWidth: 0.5,
      gridTextColor: '#888',
      gridTextSize: 12,
      gridTextFamily: 'sans-serif',
      gridTextWeight: 'normal',
      hideHover: false,
      yLabelFormat: null,
      xLabelAngle: 0,
      numLines: 5,
      padding: 25,
      parseTime: true,
      postUnits: '',
      preUnits: '',
      ymax: 'auto',
      ymin: 'auto 0',
      goals: [],
      goalStrokeWidth: 1,
      goalLineColors: [
        '#666633',
        '#999966',
        '#cc6666',
        '#663333'
      ],
      events: [],
      eventStrokeWidth: 1,
      eventLineColors: [
        '#005a04',
        '#ccffbb',
        '#3a5f0b',
        '#005502'
      ],
      rangeSelect: null,
      rangeSelectColor: '#eef',
      resize: false
    };
    Grid.prototype.setData = function (data, redraw) {
      var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;
      if (redraw == null) {
        redraw = true;
      }
      this.options.data = data;
      if (data == null || data.length === 0) {
        this.data = [];
        this.raphael.clear();
        if (this.hover != null) {
          this.hover.hide();
        }
        return;
      }
      ymax = this.cumulative ? 0 : null;
      ymin = this.cumulative ? 0 : null;
      if (this.options.goals.length > 0) {
        minGoal = Math.min.apply(Math, this.options.goals);
        maxGoal = Math.max.apply(Math, this.options.goals);
        ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;
        ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;
      }
      this.data = function () {
        var _i, _len, _results;
        _results = [];
        for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
          row = data[index];
          ret = { src: row };
          ret.label = row[this.options.xkey];
          if (this.options.parseTime) {
            ret.x = Morris.parseDate(ret.label);
            if (this.options.dateFormat) {
              ret.label = this.options.dateFormat(ret.x);
            } else if (typeof ret.label === 'number') {
              ret.label = new Date(ret.label).toString();
            }
          } else {
            ret.x = index;
            if (this.options.xLabelFormat) {
              ret.label = this.options.xLabelFormat(ret);
            }
          }
          total = 0;
          ret.y = function () {
            var _j, _len1, _ref, _results1;
            _ref = this.options.ykeys;
            _results1 = [];
            for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {
              ykey = _ref[idx];
              yval = row[ykey];
              if (typeof yval === 'string') {
                yval = parseFloat(yval);
              }
              if (yval != null && typeof yval !== 'number') {
                yval = null;
              }
              if (yval != null) {
                if (this.cumulative) {
                  total += yval;
                } else {
                  if (ymax != null) {
                    ymax = Math.max(yval, ymax);
                    ymin = Math.min(yval, ymin);
                  } else {
                    ymax = ymin = yval;
                  }
                }
              }
              if (this.cumulative && total != null) {
                ymax = Math.max(total, ymax);
                ymin = Math.min(total, ymin);
              }
              _results1.push(yval);
            }
            return _results1;
          }.call(this);
          _results.push(ret);
        }
        return _results;
      }.call(this);
      if (this.options.parseTime) {
        this.data = this.data.sort(function (a, b) {
          return (a.x > b.x) - (b.x > a.x);
        });
      }
      this.xmin = this.data[0].x;
      this.xmax = this.data[this.data.length - 1].x;
      this.events = [];
      if (this.options.events.length > 0) {
        if (this.options.parseTime) {
          this.events = function () {
            var _i, _len, _ref, _results;
            _ref = this.options.events;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              e = _ref[_i];
              _results.push(Morris.parseDate(e));
            }
            return _results;
          }.call(this);
        } else {
          this.events = this.options.events;
        }
        this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));
        this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));
      }
      if (this.xmin === this.xmax) {
        this.xmin -= 1;
        this.xmax += 1;
      }
      this.ymin = this.yboundary('min', ymin);
      this.ymax = this.yboundary('max', ymax);
      if (this.ymin === this.ymax) {
        if (ymin) {
          this.ymin -= 1;
        }
        this.ymax += 1;
      }
      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y' || this.options.grid === true) {
        if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {
          this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);
          this.ymin = Math.min(this.ymin, this.grid[0]);
          this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);
        } else {
          step = (this.ymax - this.ymin) / (this.options.numLines - 1);
          this.grid = function () {
            var _i, _ref1, _ref2, _results;
            _results = [];
            for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {
              _results.push(y);
            }
            return _results;
          }.call(this);
        }
      }
      this.dirty = true;
      if (redraw) {
        return this.redraw();
      }
    };
    Grid.prototype.yboundary = function (boundaryType, currentValue) {
      var boundaryOption, suggestedValue;
      boundaryOption = this.options['y' + boundaryType];
      if (typeof boundaryOption === 'string') {
        if (boundaryOption.slice(0, 4) === 'auto') {
          if (boundaryOption.length > 5) {
            suggestedValue = parseInt(boundaryOption.slice(5), 10);
            if (currentValue == null) {
              return suggestedValue;
            }
            return Math[boundaryType](currentValue, suggestedValue);
          } else {
            if (currentValue != null) {
              return currentValue;
            } else {
              return 0;
            }
          }
        } else {
          return parseInt(boundaryOption, 10);
        }
      } else {
        return boundaryOption;
      }
    };
    Grid.prototype.autoGridLines = function (ymin, ymax, nlines) {
      var gmax, gmin, grid, smag, span, step, unit, y, ymag;
      span = ymax - ymin;
      ymag = Math.floor(Math.log(span) / Math.log(10));
      unit = Math.pow(10, ymag);
      gmin = Math.floor(ymin / unit) * unit;
      gmax = Math.ceil(ymax / unit) * unit;
      step = (gmax - gmin) / (nlines - 1);
      if (unit === 1 && step > 1 && Math.ceil(step) !== step) {
        step = Math.ceil(step);
        gmax = gmin + step * (nlines - 1);
      }
      if (gmin < 0 && gmax > 0) {
        gmin = Math.floor(ymin / step) * step;
        gmax = Math.ceil(ymax / step) * step;
      }
      if (step < 1) {
        smag = Math.floor(Math.log(step) / Math.log(10));
        grid = function () {
          var _i, _results;
          _results = [];
          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
            _results.push(parseFloat(y.toFixed(1 - smag)));
          }
          return _results;
        }();
      } else {
        grid = function () {
          var _i, _results;
          _results = [];
          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
            _results.push(y);
          }
          return _results;
        }();
      }
      return grid;
    };
    Grid.prototype._calc = function () {
      var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;
      w = this.el.width();
      h = this.el.height();
      if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {
        this.elementWidth = w;
        this.elementHeight = h;
        this.dirty = false;
        this.left = this.options.padding;
        this.right = this.elementWidth - this.options.padding;
        this.top = this.options.padding;
        this.bottom = this.elementHeight - this.options.padding;
        if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {
          yLabelWidths = function () {
            var _i, _len, _ref1, _results;
            _ref1 = this.grid;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              gridLine = _ref1[_i];
              _results.push(this.measureText(this.yAxisFormat(gridLine)).width);
            }
            return _results;
          }.call(this);
          this.left += Math.max.apply(Math, yLabelWidths);
        }
        if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {
          bottomOffsets = function () {
            var _i, _ref2, _results;
            _results = [];
            for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
              _results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);
            }
            return _results;
          }.call(this);
          this.bottom -= Math.max.apply(Math, bottomOffsets);
        }
        this.width = Math.max(1, this.right - this.left);
        this.height = Math.max(1, this.bottom - this.top);
        this.dx = this.width / (this.xmax - this.xmin);
        this.dy = this.height / (this.ymax - this.ymin);
        if (this.calc) {
          return this.calc();
        }
      }
    };
    Grid.prototype.transY = function (y) {
      return this.bottom - (y - this.ymin) * this.dy;
    };
    Grid.prototype.transX = function (x) {
      if (this.data.length === 1) {
        return (this.left + this.right) / 2;
      } else {
        return this.left + (x - this.xmin) * this.dx;
      }
    };
    Grid.prototype.redraw = function () {
      this.raphael.clear();
      this._calc();
      this.drawGrid();
      this.drawGoals();
      this.drawEvents();
      if (this.draw) {
        return this.draw();
      }
    };
    Grid.prototype.measureText = function (text, angle) {
      var ret, tt;
      if (angle == null) {
        angle = 0;
      }
      tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);
      ret = tt.getBBox();
      tt.remove();
      return ret;
    };
    Grid.prototype.yAxisFormat = function (label) {
      return this.yLabelFormat(label);
    };
    Grid.prototype.yLabelFormat = function (label) {
      if (typeof this.options.yLabelFormat === 'function') {
        return this.options.yLabelFormat(label);
      } else {
        return '' + this.options.preUnits + Morris.commas(label) + this.options.postUnits;
      }
    };
    Grid.prototype.drawGrid = function () {
      var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;
      if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {
        return;
      }
      _ref1 = this.grid;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        lineY = _ref1[_i];
        y = this.transY(lineY);
        if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {
          this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));
        }
        if (this.options.grid) {
          _results.push(this.drawGridLine('M' + this.left + ',' + y + 'H' + (this.left + this.width)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    Grid.prototype.drawGoals = function () {
      var color, goal, i, _i, _len, _ref, _results;
      _ref = this.options.goals;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        goal = _ref[i];
        color = this.options.goalLineColors[i % this.options.goalLineColors.length];
        _results.push(this.drawGoal(goal, color));
      }
      return _results;
    };
    Grid.prototype.drawEvents = function () {
      var color, event, i, _i, _len, _ref, _results;
      _ref = this.events;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        event = _ref[i];
        color = this.options.eventLineColors[i % this.options.eventLineColors.length];
        _results.push(this.drawEvent(event, color));
      }
      return _results;
    };
    Grid.prototype.drawGoal = function (goal, color) {
      return this.raphael.path('M' + this.left + ',' + this.transY(goal) + 'H' + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);
    };
    Grid.prototype.drawEvent = function (event, color) {
      return this.raphael.path('M' + this.transX(event) + ',' + this.bottom + 'V' + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);
    };
    Grid.prototype.drawYAxisLabel = function (xPos, yPos, text) {
      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');
    };
    Grid.prototype.drawGridLine = function (path) {
      return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);
    };
    Grid.prototype.startRange = function (x) {
      this.hover.hide();
      this.selectFrom = x;
      return this.selectionRect.attr({
        x: x,
        width: 0
      }).show();
    };
    Grid.prototype.endRange = function (x) {
      var end, start;
      if (this.selectFrom) {
        start = Math.min(this.selectFrom, x);
        end = Math.max(this.selectFrom, x);
        this.options.rangeSelect.call(this.el, {
          start: this.data[this.hitTest(start)].x,
          end: this.data[this.hitTest(end)].x
        });
        return this.selectFrom = null;
      }
    };
    Grid.prototype.resizeHandler = function () {
      this.timeoutId = null;
      this.raphael.setSize(this.el.width(), this.el.height());
      return this.redraw();
    };
    return Grid;
  }(Morris.EventEmitter);
  Morris.parseDate = function (date) {
    var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;
    if (typeof date === 'number') {
      return date;
    }
    m = date.match(/^(\d+) Q(\d)$/);
    n = date.match(/^(\d+)-(\d+)$/);
    o = date.match(/^(\d+)-(\d+)-(\d+)$/);
    p = date.match(/^(\d+) W(\d+)$/);
    q = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/);
    r = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/);
    if (m) {
      return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();
    } else if (n) {
      return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();
    } else if (o) {
      return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();
    } else if (p) {
      ret = new Date(parseInt(p[1], 10), 0, 1);
      if (ret.getDay() !== 4) {
        ret.setMonth(0, 1 + (4 - ret.getDay() + 7) % 7);
      }
      return ret.getTime() + parseInt(p[2], 10) * 604800000;
    } else if (q) {
      if (!q[6]) {
        return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();
      } else {
        offsetmins = 0;
        if (q[6] !== 'Z') {
          offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);
          if (q[7] === '+') {
            offsetmins = 0 - offsetmins;
          }
        }
        return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);
      }
    } else if (r) {
      secs = parseFloat(r[6]);
      isecs = Math.floor(secs);
      msecs = Math.round((secs - isecs) * 1000);
      if (!r[8]) {
        return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();
      } else {
        offsetmins = 0;
        if (r[8] !== 'Z') {
          offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);
          if (r[9] === '+') {
            offsetmins = 0 - offsetmins;
          }
        }
        return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);
      }
    } else {
      return new Date(parseInt(date, 10), 0, 1).getTime();
    }
  };
  Morris.Hover = function () {
    Hover.defaults = { 'class': 'morris-hover morris-default-style' };
    function Hover(options) {
      if (options == null) {
        options = {};
      }
      this.options = $.extend({}, Morris.Hover.defaults, options);
      this.el = $('<div class=\'' + this.options['class'] + '\'></div>');
      this.el.hide();
      this.options.parent.append(this.el);
    }
    Hover.prototype.update = function (html, x, y) {
      if (!html) {
        return this.hide();
      } else {
        this.html(html);
        this.show();
        return this.moveTo(x, y);
      }
    };
    Hover.prototype.html = function (content) {
      return this.el.html(content);
    };
    Hover.prototype.moveTo = function (x, y) {
      var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;
      parentWidth = this.options.parent.innerWidth();
      parentHeight = this.options.parent.innerHeight();
      hoverWidth = this.el.outerWidth();
      hoverHeight = this.el.outerHeight();
      left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);
      if (y != null) {
        top = y - hoverHeight - 10;
        if (top < 0) {
          top = y + 10;
          if (top + hoverHeight > parentHeight) {
            top = parentHeight / 2 - hoverHeight / 2;
          }
        }
      } else {
        top = parentHeight / 2 - hoverHeight / 2;
      }
      return this.el.css({
        left: left + 'px',
        top: parseInt(top) + 'px'
      });
    };
    Hover.prototype.show = function () {
      return this.el.show();
    };
    Hover.prototype.hide = function () {
      return this.el.hide();
    };
    return Hover;
  }();
  Morris.Line = function (_super) {
    __extends(Line, _super);
    function Line(options) {
      this.hilight = __bind(this.hilight, this);
      this.onHoverOut = __bind(this.onHoverOut, this);
      this.onHoverMove = __bind(this.onHoverMove, this);
      this.onGridClick = __bind(this.onGridClick, this);
      if (!(this instanceof Morris.Line)) {
        return new Morris.Line(options);
      }
      Line.__super__.constructor.call(this, options);
    }
    Line.prototype.init = function () {
      if (this.options.hideHover !== 'always') {
        this.hover = new Morris.Hover({ parent: this.el });
        this.on('hovermove', this.onHoverMove);
        this.on('hoverout', this.onHoverOut);
        return this.on('gridclick', this.onGridClick);
      }
    };
    Line.prototype.defaults = {
      lineWidth: 3,
      pointSize: 4,
      lineColors: [
        '#0b62a4',
        '#7A92A3',
        '#4da74d',
        '#afd8f8',
        '#edc240',
        '#cb4b4b',
        '#9440ed'
      ],
      pointStrokeWidths: [1],
      pointStrokeColors: ['#ffffff'],
      pointFillColors: [],
      smooth: true,
      xLabels: 'auto',
      xLabelFormat: null,
      xLabelMargin: 24,
      hideHover: false
    };
    Line.prototype.calc = function () {
      this.calcPoints();
      return this.generatePaths();
    };
    Line.prototype.calcPoints = function () {
      var row, y, _i, _len, _ref, _results;
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        row._x = this.transX(row.x);
        row._y = function () {
          var _j, _len1, _ref1, _results1;
          _ref1 = row.y;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            y = _ref1[_j];
            if (y != null) {
              _results1.push(this.transY(y));
            } else {
              _results1.push(y);
            }
          }
          return _results1;
        }.call(this);
        _results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat(function () {
          var _j, _len1, _ref1, _results1;
          _ref1 = row._y;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            y = _ref1[_j];
            if (y != null) {
              _results1.push(y);
            }
          }
          return _results1;
        }())));
      }
      return _results;
    };
    Line.prototype.hitTest = function (x) {
      var index, r, _i, _len, _ref;
      if (this.data.length === 0) {
        return null;
      }
      _ref = this.data.slice(1);
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        r = _ref[index];
        if (x < (r._x + this.data[index]._x) / 2) {
          break;
        }
      }
      return index;
    };
    Line.prototype.onGridClick = function (x, y) {
      var index;
      index = this.hitTest(x);
      return this.fire('click', index, this.data[index].src, x, y);
    };
    Line.prototype.onHoverMove = function (x, y) {
      var index;
      index = this.hitTest(x);
      return this.displayHoverForRow(index);
    };
    Line.prototype.onHoverOut = function () {
      if (this.options.hideHover !== false) {
        return this.displayHoverForRow(null);
      }
    };
    Line.prototype.displayHoverForRow = function (index) {
      var _ref;
      if (index != null) {
        (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
        return this.hilight(index);
      } else {
        this.hover.hide();
        return this.hilight();
      }
    };
    Line.prototype.hoverContentForRow = function (index) {
      var content, j, row, y, _i, _len, _ref;
      row = this.data[index];
      content = '<div class=\'morris-hover-row-label\'>' + row.label + '</div>';
      _ref = row.y;
      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
        y = _ref[j];
        content += '<div class=\'morris-hover-point\' style=\'color: ' + this.colorFor(row, j, 'label') + '\'>\n  ' + this.options.labels[j] + ':\n  ' + this.yLabelFormat(y) + '\n</div>';
      }
      if (typeof this.options.hoverCallback === 'function') {
        content = this.options.hoverCallback(index, this.options, content, row.src);
      }
      return [
        content,
        row._x,
        row._ymax
      ];
    };
    Line.prototype.generatePaths = function () {
      var coords, i, r, smooth;
      return this.paths = function () {
        var _i, _ref, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          smooth = typeof this.options.smooth === 'boolean' ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);
          coords = function () {
            var _j, _len, _ref2, _results1;
            _ref2 = this.data;
            _results1 = [];
            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
              r = _ref2[_j];
              if (r._y[i] !== void 0) {
                _results1.push({
                  x: r._x,
                  y: r._y[i]
                });
              }
            }
            return _results1;
          }.call(this);
          if (coords.length > 1) {
            _results.push(Morris.Line.createPath(coords, smooth, this.bottom));
          } else {
            _results.push(null);
          }
        }
        return _results;
      }.call(this);
    };
    Line.prototype.draw = function () {
      var _ref;
      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
        this.drawXAxis();
      }
      this.drawSeries();
      if (this.options.hideHover === false) {
        return this.displayHoverForRow(this.data.length - 1);
      }
    };
    Line.prototype.drawXAxis = function () {
      var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results, _this = this;
      ypos = this.bottom + this.options.padding / 2;
      prevLabelMargin = null;
      prevAngleMargin = null;
      drawLabel = function (labelText, xpos) {
        var label, labelBox, margin, offset, textBox;
        label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);
        textBox = label.getBBox();
        label.transform('r' + -_this.options.xLabelAngle);
        labelBox = label.getBBox();
        label.transform('t0,' + labelBox.height / 2 + '...');
        if (_this.options.xLabelAngle !== 0) {
          offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180);
          label.transform('t' + offset + ',0...');
        }
        labelBox = label.getBBox();
        if ((prevLabelMargin == null || prevLabelMargin >= labelBox.x + labelBox.width || prevAngleMargin != null && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && labelBox.x + labelBox.width < _this.el.width()) {
          if (_this.options.xLabelAngle !== 0) {
            margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180);
            prevAngleMargin = labelBox.x - margin;
          }
          return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;
        } else {
          return label.remove();
        }
      };
      if (this.options.parseTime) {
        if (this.data.length === 1 && this.options.xLabels === 'auto') {
          labels = [[
              this.data[0].label,
              this.data[0].x
            ]];
        } else {
          labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);
        }
      } else {
        labels = function () {
          var _i, _len, _ref, _results;
          _ref = this.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            row = _ref[_i];
            _results.push([
              row.label,
              row.x
            ]);
          }
          return _results;
        }.call(this);
      }
      labels.reverse();
      _results = [];
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        l = labels[_i];
        _results.push(drawLabel(l[0], l[1]));
      }
      return _results;
    };
    Line.prototype.drawSeries = function () {
      var i, _i, _j, _ref, _ref1, _results;
      this.seriesPoints = [];
      for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        this._drawLineFor(i);
      }
      _results = [];
      for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {
        _results.push(this._drawPointFor(i));
      }
      return _results;
    };
    Line.prototype._drawPointFor = function (index) {
      var circle, row, _i, _len, _ref, _results;
      this.seriesPoints[index] = [];
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        circle = null;
        if (row._y[index] != null) {
          circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);
        }
        _results.push(this.seriesPoints[index].push(circle));
      }
      return _results;
    };
    Line.prototype._drawLineFor = function (index) {
      var path;
      path = this.paths[index];
      if (path !== null) {
        return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);
      }
    };
    Line.createPath = function (coords, smooth, bottom) {
      var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;
      path = '';
      if (smooth) {
        grads = Morris.Line.gradients(coords);
      }
      prevCoord = { y: null };
      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
        coord = coords[i];
        if (coord.y != null) {
          if (prevCoord.y != null) {
            if (smooth) {
              g = grads[i];
              lg = grads[i - 1];
              ix = (coord.x - prevCoord.x) / 4;
              x1 = prevCoord.x + ix;
              y1 = Math.min(bottom, prevCoord.y + ix * lg);
              x2 = coord.x - ix;
              y2 = Math.min(bottom, coord.y - ix * g);
              path += 'C' + x1 + ',' + y1 + ',' + x2 + ',' + y2 + ',' + coord.x + ',' + coord.y;
            } else {
              path += 'L' + coord.x + ',' + coord.y;
            }
          } else {
            if (!smooth || grads[i] != null) {
              path += 'M' + coord.x + ',' + coord.y;
            }
          }
        }
        prevCoord = coord;
      }
      return path;
    };
    Line.gradients = function (coords) {
      var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;
      grad = function (a, b) {
        return (a.y - b.y) / (a.x - b.x);
      };
      _results = [];
      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
        coord = coords[i];
        if (coord.y != null) {
          nextCoord = coords[i + 1] || { y: null };
          prevCoord = coords[i - 1] || { y: null };
          if (prevCoord.y != null && nextCoord.y != null) {
            _results.push(grad(prevCoord, nextCoord));
          } else if (prevCoord.y != null) {
            _results.push(grad(prevCoord, coord));
          } else if (nextCoord.y != null) {
            _results.push(grad(coord, nextCoord));
          } else {
            _results.push(null);
          }
        } else {
          _results.push(null);
        }
      }
      return _results;
    };
    Line.prototype.hilight = function (index) {
      var i, _i, _j, _ref, _ref1;
      if (this.prevHilight !== null && this.prevHilight !== index) {
        for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.seriesPoints[i][this.prevHilight]) {
            this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));
          }
        }
      }
      if (index !== null && this.prevHilight !== index) {
        for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          if (this.seriesPoints[i][index]) {
            this.seriesPoints[i][index].animate(this.pointGrowSeries(i));
          }
        }
      }
      return this.prevHilight = index;
    };
    Line.prototype.colorFor = function (row, sidx, type) {
      if (typeof this.options.lineColors === 'function') {
        return this.options.lineColors.call(this, row, sidx, type);
      } else if (type === 'point') {
        return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];
      } else {
        return this.options.lineColors[sidx % this.options.lineColors.length];
      }
    };
    Line.prototype.drawXAxisLabel = function (xPos, yPos, text) {
      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
    };
    Line.prototype.drawLinePath = function (path, lineColor, lineIndex) {
      return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));
    };
    Line.prototype.drawLinePoint = function (xPos, yPos, pointColor, lineIndex) {
      return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));
    };
    Line.prototype.pointStrokeWidthForSeries = function (index) {
      return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];
    };
    Line.prototype.pointStrokeColorForSeries = function (index) {
      return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];
    };
    Line.prototype.lineWidthForSeries = function (index) {
      if (this.options.lineWidth instanceof Array) {
        return this.options.lineWidth[index % this.options.lineWidth.length];
      } else {
        return this.options.lineWidth;
      }
    };
    Line.prototype.pointSizeForSeries = function (index) {
      if (this.options.pointSize instanceof Array) {
        return this.options.pointSize[index % this.options.pointSize.length];
      } else {
        return this.options.pointSize;
      }
    };
    Line.prototype.pointGrowSeries = function (index) {
      return Raphael.animation({ r: this.pointSizeForSeries(index) + 3 }, 25, 'linear');
    };
    Line.prototype.pointShrinkSeries = function (index) {
      return Raphael.animation({ r: this.pointSizeForSeries(index) }, 25, 'linear');
    };
    return Line;
  }(Morris.Grid);
  Morris.labelSeries = function (dmin, dmax, pxwidth, specName, xLabelFormat) {
    var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;
    ddensity = 200 * (dmax - dmin) / pxwidth;
    d0 = new Date(dmin);
    spec = Morris.LABEL_SPECS[specName];
    if (spec === void 0) {
      _ref = Morris.AUTO_LABEL_ORDER;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        s = Morris.LABEL_SPECS[name];
        if (ddensity >= s.span) {
          spec = s;
          break;
        }
      }
    }
    if (spec === void 0) {
      spec = Morris.LABEL_SPECS['second'];
    }
    if (xLabelFormat) {
      spec = $.extend({}, spec, { fmt: xLabelFormat });
    }
    d = spec.start(d0);
    ret = [];
    while ((t = d.getTime()) <= dmax) {
      if (t >= dmin) {
        ret.push([
          spec.fmt(d),
          t
        ]);
      }
      spec.incr(d);
    }
    return ret;
  };
  minutesSpecHelper = function (interval) {
    return {
      span: interval * 60 * 1000,
      start: function (d) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());
      },
      fmt: function (d) {
        return '' + Morris.pad2(d.getHours()) + ':' + Morris.pad2(d.getMinutes());
      },
      incr: function (d) {
        return d.setUTCMinutes(d.getUTCMinutes() + interval);
      }
    };
  };
  secondsSpecHelper = function (interval) {
    return {
      span: interval * 1000,
      start: function (d) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
      },
      fmt: function (d) {
        return '' + Morris.pad2(d.getHours()) + ':' + Morris.pad2(d.getMinutes()) + ':' + Morris.pad2(d.getSeconds());
      },
      incr: function (d) {
        return d.setUTCSeconds(d.getUTCSeconds() + interval);
      }
    };
  };
  Morris.LABEL_SPECS = {
    'decade': {
      span: 172800000000,
      start: function (d) {
        return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);
      },
      fmt: function (d) {
        return '' + d.getFullYear();
      },
      incr: function (d) {
        return d.setFullYear(d.getFullYear() + 10);
      }
    },
    'year': {
      span: 17280000000,
      start: function (d) {
        return new Date(d.getFullYear(), 0, 1);
      },
      fmt: function (d) {
        return '' + d.getFullYear();
      },
      incr: function (d) {
        return d.setFullYear(d.getFullYear() + 1);
      }
    },
    'month': {
      span: 2419200000,
      start: function (d) {
        return new Date(d.getFullYear(), d.getMonth(), 1);
      },
      fmt: function (d) {
        return '' + d.getFullYear() + '-' + Morris.pad2(d.getMonth() + 1);
      },
      incr: function (d) {
        return d.setMonth(d.getMonth() + 1);
      }
    },
    'week': {
      span: 604800000,
      start: function (d) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      },
      fmt: function (d) {
        return '' + d.getFullYear() + '-' + Morris.pad2(d.getMonth() + 1) + '-' + Morris.pad2(d.getDate());
      },
      incr: function (d) {
        return d.setDate(d.getDate() + 7);
      }
    },
    'day': {
      span: 86400000,
      start: function (d) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      },
      fmt: function (d) {
        return '' + d.getFullYear() + '-' + Morris.pad2(d.getMonth() + 1) + '-' + Morris.pad2(d.getDate());
      },
      incr: function (d) {
        return d.setDate(d.getDate() + 1);
      }
    },
    'hour': minutesSpecHelper(60),
    '30min': minutesSpecHelper(30),
    '15min': minutesSpecHelper(15),
    '10min': minutesSpecHelper(10),
    '5min': minutesSpecHelper(5),
    'minute': minutesSpecHelper(1),
    '30sec': secondsSpecHelper(30),
    '15sec': secondsSpecHelper(15),
    '10sec': secondsSpecHelper(10),
    '5sec': secondsSpecHelper(5),
    'second': secondsSpecHelper(1)
  };
  Morris.AUTO_LABEL_ORDER = [
    'decade',
    'year',
    'month',
    'week',
    'day',
    'hour',
    '30min',
    '15min',
    '10min',
    '5min',
    'minute',
    '30sec',
    '15sec',
    '10sec',
    '5sec',
    'second'
  ];
  Morris.Area = function (_super) {
    var areaDefaults;
    __extends(Area, _super);
    areaDefaults = {
      fillOpacity: 'auto',
      behaveLikeLine: false
    };
    function Area(options) {
      var areaOptions;
      if (!(this instanceof Morris.Area)) {
        return new Morris.Area(options);
      }
      areaOptions = $.extend({}, areaDefaults, options);
      this.cumulative = !areaOptions.behaveLikeLine;
      if (areaOptions.fillOpacity === 'auto') {
        areaOptions.fillOpacity = areaOptions.behaveLikeLine ? 0.8 : 1;
      }
      Area.__super__.constructor.call(this, areaOptions);
    }
    Area.prototype.calcPoints = function () {
      var row, total, y, _i, _len, _ref, _results;
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        row._x = this.transX(row.x);
        total = 0;
        row._y = function () {
          var _j, _len1, _ref1, _results1;
          _ref1 = row.y;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            y = _ref1[_j];
            if (this.options.behaveLikeLine) {
              _results1.push(this.transY(y));
            } else {
              total += y || 0;
              _results1.push(this.transY(total));
            }
          }
          return _results1;
        }.call(this);
        _results.push(row._ymax = Math.max.apply(Math, row._y));
      }
      return _results;
    };
    Area.prototype.drawSeries = function () {
      var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;
      this.seriesPoints = [];
      if (this.options.behaveLikeLine) {
        range = function () {
          _results = [];
          for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--) {
            _results.push(_i);
          }
          return _results;
        }.apply(this);
      } else {
        range = function () {
          _results1 = [];
          for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--) {
            _results1.push(_j);
          }
          return _results1;
        }.apply(this);
      }
      _results2 = [];
      for (_k = 0, _len = range.length; _k < _len; _k++) {
        i = range[_k];
        this._drawFillFor(i);
        this._drawLineFor(i);
        _results2.push(this._drawPointFor(i));
      }
      return _results2;
    };
    Area.prototype._drawFillFor = function (index) {
      var path;
      path = this.paths[index];
      if (path !== null) {
        path = path + ('L' + this.transX(this.xmax) + ',' + this.bottom + 'L' + this.transX(this.xmin) + ',' + this.bottom + 'Z');
        return this.drawFilledPath(path, this.fillForSeries(index));
      }
    };
    Area.prototype.fillForSeries = function (i) {
      var color;
      color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));
      return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));
    };
    Area.prototype.drawFilledPath = function (path, fill) {
      return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');
    };
    return Area;
  }(Morris.Line);
  Morris.Bar = function (_super) {
    __extends(Bar, _super);
    function Bar(options) {
      this.onHoverOut = __bind(this.onHoverOut, this);
      this.onHoverMove = __bind(this.onHoverMove, this);
      this.onGridClick = __bind(this.onGridClick, this);
      if (!(this instanceof Morris.Bar)) {
        return new Morris.Bar(options);
      }
      Bar.__super__.constructor.call(this, $.extend({}, options, { parseTime: false }));
    }
    Bar.prototype.init = function () {
      this.cumulative = this.options.stacked;
      if (this.options.hideHover !== 'always') {
        this.hover = new Morris.Hover({ parent: this.el });
        this.on('hovermove', this.onHoverMove);
        this.on('hoverout', this.onHoverOut);
        return this.on('gridclick', this.onGridClick);
      }
    };
    Bar.prototype.defaults = {
      barSizeRatio: 0.75,
      barGap: 3,
      barColors: [
        '#0b62a4',
        '#7a92a3',
        '#4da74d',
        '#afd8f8',
        '#edc240',
        '#cb4b4b',
        '#9440ed'
      ],
      barOpacity: 1,
      barRadius: [
        0,
        0,
        0,
        0
      ],
      xLabelMargin: 50
    };
    Bar.prototype.calc = function () {
      var _ref;
      this.calcBars();
      if (this.options.hideHover === false) {
        return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));
      }
    };
    Bar.prototype.calcBars = function () {
      var idx, row, y, _i, _len, _ref, _results;
      _ref = this.data;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        row = _ref[idx];
        row._x = this.left + this.width * (idx + 0.5) / this.data.length;
        _results.push(row._y = function () {
          var _j, _len1, _ref1, _results1;
          _ref1 = row.y;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            y = _ref1[_j];
            if (y != null) {
              _results1.push(this.transY(y));
            } else {
              _results1.push(null);
            }
          }
          return _results1;
        }.call(this));
      }
      return _results;
    };
    Bar.prototype.draw = function () {
      var _ref;
      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
        this.drawXAxis();
      }
      return this.drawSeries();
    };
    Bar.prototype.drawXAxis = function () {
      var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref, _results;
      ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);
      prevLabelMargin = null;
      prevAngleMargin = null;
      _results = [];
      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = this.data[this.data.length - 1 - i];
        label = this.drawXAxisLabel(row._x, ypos, row.label);
        textBox = label.getBBox();
        label.transform('r' + -this.options.xLabelAngle);
        labelBox = label.getBBox();
        label.transform('t0,' + labelBox.height / 2 + '...');
        if (this.options.xLabelAngle !== 0) {
          offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180);
          label.transform('t' + offset + ',0...');
        }
        if ((prevLabelMargin == null || prevLabelMargin >= labelBox.x + labelBox.width || prevAngleMargin != null && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && labelBox.x + labelBox.width < this.el.width()) {
          if (this.options.xLabelAngle !== 0) {
            margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180);
            prevAngleMargin = labelBox.x - margin;
          }
          _results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);
        } else {
          _results.push(label.remove());
        }
      }
      return _results;
    };
    Bar.prototype.drawSeries = function () {
      var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top, ypos, zeroPos;
      groupWidth = this.width / this.options.data.length;
      numBars = this.options.stacked ? 1 : this.options.ykeys.length;
      barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;
      if (this.options.barSize) {
        barWidth = Math.min(barWidth, this.options.barSize);
      }
      spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);
      leftPadding = spaceLeft / 2;
      zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;
      return this.bars = function () {
        var _i, _len, _ref, _results;
        _ref = this.data;
        _results = [];
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          row = _ref[idx];
          lastTop = 0;
          _results.push(function () {
            var _j, _len1, _ref1, _results1;
            _ref1 = row._y;
            _results1 = [];
            for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {
              ypos = _ref1[sidx];
              if (ypos !== null) {
                if (zeroPos) {
                  top = Math.min(ypos, zeroPos);
                  bottom = Math.max(ypos, zeroPos);
                } else {
                  top = ypos;
                  bottom = this.bottom;
                }
                left = this.left + idx * groupWidth + leftPadding;
                if (!this.options.stacked) {
                  left += sidx * (barWidth + this.options.barGap);
                }
                size = bottom - top;
                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {
                  this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);
                }
                if (this.options.stacked) {
                  top -= lastTop;
                }
                this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);
                _results1.push(lastTop += size);
              } else {
                _results1.push(null);
              }
            }
            return _results1;
          }.call(this));
        }
        return _results;
      }.call(this);
    };
    Bar.prototype.colorFor = function (row, sidx, type) {
      var r, s;
      if (typeof this.options.barColors === 'function') {
        r = {
          x: row.x,
          y: row.y[sidx],
          label: row.label
        };
        s = {
          index: sidx,
          key: this.options.ykeys[sidx],
          label: this.options.labels[sidx]
        };
        return this.options.barColors.call(this, r, s, type);
      } else {
        return this.options.barColors[sidx % this.options.barColors.length];
      }
    };
    Bar.prototype.hitTest = function (x) {
      if (this.data.length === 0) {
        return null;
      }
      x = Math.max(Math.min(x, this.right), this.left);
      return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));
    };
    Bar.prototype.onGridClick = function (x, y) {
      var index;
      index = this.hitTest(x);
      return this.fire('click', index, this.data[index].src, x, y);
    };
    Bar.prototype.onHoverMove = function (x, y) {
      var index, _ref;
      index = this.hitTest(x);
      return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
    };
    Bar.prototype.onHoverOut = function () {
      if (this.options.hideHover !== false) {
        return this.hover.hide();
      }
    };
    Bar.prototype.hoverContentForRow = function (index) {
      var content, j, row, x, y, _i, _len, _ref;
      row = this.data[index];
      content = '<div class=\'morris-hover-row-label\'>' + row.label + '</div>';
      _ref = row.y;
      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
        y = _ref[j];
        content += '<div class=\'morris-hover-point\' style=\'color: ' + this.colorFor(row, j, 'label') + '\'>\n  ' + this.options.labels[j] + ':\n  ' + this.yLabelFormat(y) + '\n</div>';
      }
      if (typeof this.options.hoverCallback === 'function') {
        content = this.options.hoverCallback(index, this.options, content, row.src);
      }
      x = this.left + (index + 0.5) * this.width / this.data.length;
      return [
        content,
        x
      ];
    };
    Bar.prototype.drawXAxisLabel = function (xPos, yPos, text) {
      var label;
      return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
    };
    Bar.prototype.drawBar = function (xPos, yPos, width, height, barColor, opacity, radiusArray) {
      var maxRadius, path;
      maxRadius = Math.max.apply(Math, radiusArray);
      if (maxRadius === 0 || maxRadius > height) {
        path = this.raphael.rect(xPos, yPos, width, height);
      } else {
        path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));
      }
      return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');
    };
    Bar.prototype.roundedRect = function (x, y, w, h, r) {
      if (r == null) {
        r = [
          0,
          0,
          0,
          0
        ];
      }
      return [
        'M',
        x,
        r[0] + y,
        'Q',
        x,
        y,
        x + r[0],
        y,
        'L',
        x + w - r[1],
        y,
        'Q',
        x + w,
        y,
        x + w,
        y + r[1],
        'L',
        x + w,
        y + h - r[2],
        'Q',
        x + w,
        y + h,
        x + w - r[2],
        y + h,
        'L',
        x + r[3],
        y + h,
        'Q',
        x,
        y + h,
        x,
        y + h - r[3],
        'Z'
      ];
    };
    return Bar;
  }(Morris.Grid);
  Morris.Donut = function (_super) {
    __extends(Donut, _super);
    Donut.prototype.defaults = {
      colors: [
        '#0B62A4',
        '#3980B5',
        '#679DC6',
        '#95BBD7',
        '#B0CCE1',
        '#095791',
        '#095085',
        '#083E67',
        '#052C48',
        '#042135'
      ],
      backgroundColor: '#FFFFFF',
      labelColor: '#000000',
      formatter: Morris.commas,
      resize: false
    };
    function Donut(options) {
      this.resizeHandler = __bind(this.resizeHandler, this);
      this.select = __bind(this.select, this);
      this.click = __bind(this.click, this);
      var _this = this;
      if (!(this instanceof Morris.Donut)) {
        return new Morris.Donut(options);
      }
      this.options = $.extend({}, this.defaults, options);
      if (typeof options.element === 'string') {
        this.el = $(document.getElementById(options.element));
      } else {
        this.el = $(options.element);
      }
      if (this.el === null || this.el.length === 0) {
        throw new Error('Graph placeholder not found.');
      }
      if (options.data === void 0 || options.data.length === 0) {
        return;
      }
      this.raphael = new Raphael(this.el[0]);
      if (this.options.resize) {
        $(window).bind('resize', function (evt) {
          if (_this.timeoutId != null) {
            window.clearTimeout(_this.timeoutId);
          }
          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
        });
      }
      this.setData(options.data);
    }
    Donut.prototype.redraw = function () {
      var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      this.raphael.clear();
      cx = this.el.width() / 2;
      cy = this.el.height() / 2;
      w = (Math.min(cx, cy) - 10) / 3;
      total = 0;
      _ref = this.values;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        value = _ref[_i];
        total += value;
      }
      min = 5 / (2 * w);
      C = 1.9999 * Math.PI - min * this.data.length;
      last = 0;
      idx = 0;
      this.segments = [];
      _ref1 = this.values;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        value = _ref1[i];
        next = last + min + C * (value / total);
        seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);
        seg.render();
        this.segments.push(seg);
        seg.on('hover', this.select);
        seg.on('click', this.click);
        last = next;
        idx += 1;
      }
      this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);
      this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);
      max_value = Math.max.apply(Math, this.values);
      idx = 0;
      _ref2 = this.values;
      _results = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        value = _ref2[_k];
        if (value === max_value) {
          this.select(idx);
          break;
        }
        _results.push(idx += 1);
      }
      return _results;
    };
    Donut.prototype.setData = function (data) {
      var row;
      this.data = data;
      this.values = function () {
        var _i, _len, _ref, _results;
        _ref = this.data;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          row = _ref[_i];
          _results.push(parseFloat(row.value));
        }
        return _results;
      }.call(this);
      return this.redraw();
    };
    Donut.prototype.click = function (idx) {
      return this.fire('click', idx, this.data[idx]);
    };
    Donut.prototype.select = function (idx) {
      var row, s, segment, _i, _len, _ref;
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        s.deselect();
      }
      segment = this.segments[idx];
      segment.select();
      row = this.data[idx];
      return this.setLabels(row.label, this.options.formatter(row.value, row));
    };
    Donut.prototype.setLabels = function (label1, label2) {
      var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;
      inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;
      maxWidth = 1.8 * inner;
      maxHeightTop = inner / 2;
      maxHeightBottom = inner / 3;
      this.text1.attr({
        text: label1,
        transform: ''
      });
      text1bbox = this.text1.getBBox();
      text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);
      this.text1.attr({ transform: 'S' + text1scale + ',' + text1scale + ',' + (text1bbox.x + text1bbox.width / 2) + ',' + (text1bbox.y + text1bbox.height) });
      this.text2.attr({
        text: label2,
        transform: ''
      });
      text2bbox = this.text2.getBBox();
      text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);
      return this.text2.attr({ transform: 'S' + text2scale + ',' + text2scale + ',' + (text2bbox.x + text2bbox.width / 2) + ',' + text2bbox.y });
    };
    Donut.prototype.drawEmptyDonutLabel = function (xPos, yPos, color, fontSize, fontWeight) {
      var text;
      text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);
      if (fontWeight != null) {
        text.attr('font-weight', fontWeight);
      }
      return text;
    };
    Donut.prototype.resizeHandler = function () {
      this.timeoutId = null;
      this.raphael.setSize(this.el.width(), this.el.height());
      return this.redraw();
    };
    return Donut;
  }(Morris.EventEmitter);
  Morris.DonutSegment = function (_super) {
    __extends(DonutSegment, _super);
    function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {
      this.cx = cx;
      this.cy = cy;
      this.inner = inner;
      this.outer = outer;
      this.color = color;
      this.backgroundColor = backgroundColor;
      this.index = index;
      this.raphael = raphael;
      this.deselect = __bind(this.deselect, this);
      this.select = __bind(this.select, this);
      this.sin_p0 = Math.sin(p0);
      this.cos_p0 = Math.cos(p0);
      this.sin_p1 = Math.sin(p1);
      this.cos_p1 = Math.cos(p1);
      this.is_long = p1 - p0 > Math.PI ? 1 : 0;
      this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);
      this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);
      this.hilight = this.calcArc(this.inner);
    }
    DonutSegment.prototype.calcArcPoints = function (r) {
      return [
        this.cx + r * this.sin_p0,
        this.cy + r * this.cos_p0,
        this.cx + r * this.sin_p1,
        this.cy + r * this.cos_p1
      ];
    };
    DonutSegment.prototype.calcSegment = function (r1, r2) {
      var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;
      _ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
      _ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];
      return 'M' + ix0 + ',' + iy0 + ('A' + r1 + ',' + r1 + ',0,' + this.is_long + ',0,' + ix1 + ',' + iy1) + ('L' + ox1 + ',' + oy1) + ('A' + r2 + ',' + r2 + ',0,' + this.is_long + ',1,' + ox0 + ',' + oy0) + 'Z';
    };
    DonutSegment.prototype.calcArc = function (r) {
      var ix0, ix1, iy0, iy1, _ref;
      _ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
      return 'M' + ix0 + ',' + iy0 + ('A' + r + ',' + r + ',0,' + this.is_long + ',0,' + ix1 + ',' + iy1);
    };
    DonutSegment.prototype.render = function () {
      var _this = this;
      this.arc = this.drawDonutArc(this.hilight, this.color);
      return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function () {
        return _this.fire('hover', _this.index);
      }, function () {
        return _this.fire('click', _this.index);
      });
    };
    DonutSegment.prototype.drawDonutArc = function (path, color) {
      return this.raphael.path(path).attr({
        stroke: color,
        'stroke-width': 2,
        opacity: 0
      });
    };
    DonutSegment.prototype.drawDonutSegment = function (path, fillColor, strokeColor, hoverFunction, clickFunction) {
      return this.raphael.path(path).attr({
        fill: fillColor,
        stroke: strokeColor,
        'stroke-width': 3
      }).hover(hoverFunction).click(clickFunction);
    };
    DonutSegment.prototype.select = function () {
      if (!this.selected) {
        this.seg.animate({ path: this.selectedPath }, 150, '<>');
        this.arc.animate({ opacity: 1 }, 150, '<>');
        return this.selected = true;
      }
    };
    DonutSegment.prototype.deselect = function () {
      if (this.selected) {
        this.seg.animate({ path: this.path }, 150, '<>');
        this.arc.animate({ opacity: 0 }, 150, '<>');
        return this.selected = false;
      }
    };
    return DonutSegment;
  }(Morris.EventEmitter);
}.call(this));/*!
 * jQuery Validation Plugin v1.13.1
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2014 Jörn Zaefferer
 * Released under the MIT license
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else {
    factory(jQuery);
  }
}(function ($) {
  $.extend($.fn, {
    validate: function (options) {
      // if nothing is selected, return nothing; can't chain anyway
      if (!this.length) {
        if (options && options.debug && window.console) {
          console.warn('Nothing selected, can\'t validate, returning nothing.');
        }
        return;
      }
      // check if a validator for this form was already created
      var validator = $.data(this[0], 'validator');
      if (validator) {
        return validator;
      }
      // Add novalidate tag if HTML5.
      this.attr('novalidate', 'novalidate');
      validator = new $.validator(options, this[0]);
      $.data(this[0], 'validator', validator);
      if (validator.settings.onsubmit) {
        this.validateDelegate(':submit', 'click', function (event) {
          if (validator.settings.submitHandler) {
            validator.submitButton = event.target;
          }
          // allow suppressing validation by adding a cancel class to the submit button
          if ($(event.target).hasClass('cancel')) {
            validator.cancelSubmit = true;
          }
          // allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
          if ($(event.target).attr('formnovalidate') !== undefined) {
            validator.cancelSubmit = true;
          }
        });
        // validate the form on submit
        this.submit(function (event) {
          if (validator.settings.debug) {
            // prevent form submit to be able to see console output
            event.preventDefault();
          }
          function handle() {
            var hidden, result;
            if (validator.settings.submitHandler) {
              if (validator.submitButton) {
                // insert a hidden input as a replacement for the missing submit button
                hidden = $('<input type=\'hidden\'/>').attr('name', validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm);
              }
              result = validator.settings.submitHandler.call(validator, validator.currentForm, event);
              if (validator.submitButton) {
                // and clean up afterwards; thanks to no-block-scope, hidden can be referenced
                hidden.remove();
              }
              if (result !== undefined) {
                return result;
              }
              return false;
            }
            return true;
          }
          // prevent submit for invalid forms or custom submit handlers
          if (validator.cancelSubmit) {
            validator.cancelSubmit = false;
            return handle();
          }
          if (validator.form()) {
            if (validator.pendingRequest) {
              validator.formSubmitted = true;
              return false;
            }
            return handle();
          } else {
            validator.focusInvalid();
            return false;
          }
        });
      }
      return validator;
    },
    valid: function () {
      var valid, validator;
      if ($(this[0]).is('form')) {
        valid = this.validate().form();
      } else {
        valid = true;
        validator = $(this[0].form).validate();
        this.each(function () {
          valid = validator.element(this) && valid;
        });
      }
      return valid;
    },
    removeAttrs: function (attributes) {
      var result = {}, $element = this;
      $.each(attributes.split(/\s/), function (index, value) {
        result[value] = $element.attr(value);
        $element.removeAttr(value);
      });
      return result;
    },
    rules: function (command, argument) {
      var element = this[0], settings, staticRules, existingRules, data, param, filtered;
      if (command) {
        settings = $.data(element.form, 'validator').settings;
        staticRules = settings.rules;
        existingRules = $.validator.staticRules(element);
        switch (command) {
        case 'add':
          $.extend(existingRules, $.validator.normalizeRule(argument));
          // remove messages from rules, but allow them to be set separately
          delete existingRules.messages;
          staticRules[element.name] = existingRules;
          if (argument.messages) {
            settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
          }
          break;
        case 'remove':
          if (!argument) {
            delete staticRules[element.name];
            return existingRules;
          }
          filtered = {};
          $.each(argument.split(/\s/), function (index, method) {
            filtered[method] = existingRules[method];
            delete existingRules[method];
            if (method === 'required') {
              $(element).removeAttr('aria-required');
            }
          });
          return filtered;
        }
      }
      data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element);
      // make sure required is at front
      if (data.required) {
        param = data.required;
        delete data.required;
        data = $.extend({ required: param }, data);
        $(element).attr('aria-required', 'true');
      }
      // make sure remote is at back
      if (data.remote) {
        param = data.remote;
        delete data.remote;
        data = $.extend(data, { remote: param });
      }
      return data;
    }
  });
  // Custom selectors
  $.extend($.expr[':'], {
    blank: function (a) {
      return !$.trim('' + $(a).val());
    },
    filled: function (a) {
      return !!$.trim('' + $(a).val());
    },
    unchecked: function (a) {
      return !$(a).prop('checked');
    }
  });
  // constructor for validator
  $.validator = function (options, form) {
    this.settings = $.extend(true, {}, $.validator.defaults, options);
    this.currentForm = form;
    this.init();
  };
  // http://jqueryvalidation.org/jQuery.validator.format/
  $.validator.format = function (source, params) {
    if (arguments.length === 1) {
      return function () {
        var args = $.makeArray(arguments);
        args.unshift(source);
        return $.validator.format.apply(this, args);
      };
    }
    if (arguments.length > 2 && params.constructor !== Array) {
      params = $.makeArray(arguments).slice(1);
    }
    if (params.constructor !== Array) {
      params = [params];
    }
    $.each(params, function (i, n) {
      source = source.replace(new RegExp('\\{' + i + '\\}', 'g'), function () {
        return n;
      });
    });
    return source;
  };
  $.extend($.validator, {
    defaults: {
      messages: {},
      groups: {},
      rules: {},
      errorClass: 'error',
      validClass: 'valid',
      errorElement: 'label',
      focusCleanup: false,
      focusInvalid: true,
      errorContainer: $([]),
      errorLabelContainer: $([]),
      onsubmit: true,
      ignore: ':hidden',
      ignoreTitle: false,
      onfocusin: function (element) {
        this.lastActive = element;
        // Hide error label and remove error class on focus if enabled
        if (this.settings.focusCleanup) {
          if (this.settings.unhighlight) {
            this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
          }
          this.hideThese(this.errorsFor(element));
        }
      },
      onfocusout: function (element) {
        if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
          this.element(element);
        }
      },
      onkeyup: function (element, event) {
        if (event.which === 9 && this.elementValue(element) === '') {
          return;
        } else if (element.name in this.submitted || element === this.lastElement) {
          this.element(element);
        }
      },
      onclick: function (element) {
        // click on selects, radiobuttons and checkboxes
        if (element.name in this.submitted) {
          this.element(element);  // or option elements, check parent select in that case
        } else if (element.parentNode.name in this.submitted) {
          this.element(element.parentNode);
        }
      },
      highlight: function (element, errorClass, validClass) {
        if (element.type === 'radio') {
          this.findByName(element.name).addClass(errorClass).removeClass(validClass);
        } else {
          $(element).addClass(errorClass).removeClass(validClass);
        }
      },
      unhighlight: function (element, errorClass, validClass) {
        if (element.type === 'radio') {
          this.findByName(element.name).removeClass(errorClass).addClass(validClass);
        } else {
          $(element).removeClass(errorClass).addClass(validClass);
        }
      }
    },
    setDefaults: function (settings) {
      $.extend($.validator.defaults, settings);
    },
    messages: {
      required: 'This field is required.',
      remote: 'Please fix this field.',
      email: 'Please enter a valid email address.',
      url: 'Please enter a valid URL.',
      date: 'Please enter a valid date.',
      dateISO: 'Please enter a valid date ( ISO ).',
      number: 'Please enter a valid number.',
      digits: 'Please enter only digits.',
      creditcard: 'Please enter a valid credit card number.',
      equalTo: 'Please enter the same value again.',
      maxlength: $.validator.format('Please enter no more than {0} characters.'),
      minlength: $.validator.format('Please enter at least {0} characters.'),
      rangelength: $.validator.format('Please enter a value between {0} and {1} characters long.'),
      range: $.validator.format('Please enter a value between {0} and {1}.'),
      max: $.validator.format('Please enter a value less than or equal to {0}.'),
      min: $.validator.format('Please enter a value greater than or equal to {0}.')
    },
    autoCreateRanges: false,
    prototype: {
      init: function () {
        this.labelContainer = $(this.settings.errorLabelContainer);
        this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
        this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
        this.submitted = {};
        this.valueCache = {};
        this.pendingRequest = 0;
        this.pending = {};
        this.invalid = {};
        this.reset();
        var groups = this.groups = {}, rules;
        $.each(this.settings.groups, function (key, value) {
          if (typeof value === 'string') {
            value = value.split(/\s/);
          }
          $.each(value, function (index, name) {
            groups[name] = key;
          });
        });
        rules = this.settings.rules;
        $.each(rules, function (key, value) {
          rules[key] = $.validator.normalizeRule(value);
        });
        function delegate(event) {
          var validator = $.data(this[0].form, 'validator'), eventType = 'on' + event.type.replace(/^validate/, ''), settings = validator.settings;
          if (settings[eventType] && !this.is(settings.ignore)) {
            settings[eventType].call(validator, this[0], event);
          }
        }
        $(this.currentForm).validateDelegate(':text, [type=\'password\'], [type=\'file\'], select, textarea, ' + '[type=\'number\'], [type=\'search\'] ,[type=\'tel\'], [type=\'url\'], ' + '[type=\'email\'], [type=\'datetime\'], [type=\'date\'], [type=\'month\'], ' + '[type=\'week\'], [type=\'time\'], [type=\'datetime-local\'], ' + '[type=\'range\'], [type=\'color\'], [type=\'radio\'], [type=\'checkbox\']', 'focusin focusout keyup', delegate).validateDelegate('select, option, [type=\'radio\'], [type=\'checkbox\']', 'click', delegate);
        if (this.settings.invalidHandler) {
          $(this.currentForm).bind('invalid-form.validate', this.settings.invalidHandler);
        }
        // Add aria-required to any Static/Data/Class required fields before first validation
        // Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html
        $(this.currentForm).find('[required], [data-rule-required], .required').attr('aria-required', 'true');
      },
      form: function () {
        this.checkForm();
        $.extend(this.submitted, this.errorMap);
        this.invalid = $.extend({}, this.errorMap);
        if (!this.valid()) {
          $(this.currentForm).triggerHandler('invalid-form', [this]);
        }
        this.showErrors();
        return this.valid();
      },
      checkForm: function () {
        this.prepareForm();
        for (var i = 0, elements = this.currentElements = this.elements(); elements[i]; i++) {
          this.check(elements[i]);
        }
        return this.valid();
      },
      element: function (element) {
        var cleanElement = this.clean(element), checkElement = this.validationTargetFor(cleanElement), result = true;
        this.lastElement = checkElement;
        if (checkElement === undefined) {
          delete this.invalid[cleanElement.name];
        } else {
          this.prepareElement(checkElement);
          this.currentElements = $(checkElement);
          result = this.check(checkElement) !== false;
          if (result) {
            delete this.invalid[checkElement.name];
          } else {
            this.invalid[checkElement.name] = true;
          }
        }
        // Add aria-invalid status for screen readers
        $(element).attr('aria-invalid', !result);
        if (!this.numberOfInvalids()) {
          // Hide error containers on last error
          this.toHide = this.toHide.add(this.containers);
        }
        this.showErrors();
        return result;
      },
      showErrors: function (errors) {
        if (errors) {
          // add items to error list and map
          $.extend(this.errorMap, errors);
          this.errorList = [];
          for (var name in errors) {
            this.errorList.push({
              message: errors[name],
              element: this.findByName(name)[0]
            });
          }
          // remove items from success list
          this.successList = $.grep(this.successList, function (element) {
            return !(element.name in errors);
          });
        }
        if (this.settings.showErrors) {
          this.settings.showErrors.call(this, this.errorMap, this.errorList);
        } else {
          this.defaultShowErrors();
        }
      },
      resetForm: function () {
        if ($.fn.resetForm) {
          $(this.currentForm).resetForm();
        }
        this.submitted = {};
        this.lastElement = null;
        this.prepareForm();
        this.hideErrors();
        this.elements().removeClass(this.settings.errorClass).removeData('previousValue').removeAttr('aria-invalid');
      },
      numberOfInvalids: function () {
        return this.objectLength(this.invalid);
      },
      objectLength: function (obj) {
        /* jshint unused: false */
        var count = 0, i;
        for (i in obj) {
          count++;
        }
        return count;
      },
      hideErrors: function () {
        this.hideThese(this.toHide);
      },
      hideThese: function (errors) {
        errors.not(this.containers).text('');
        this.addWrapper(errors).hide();
      },
      valid: function () {
        return this.size() === 0;
      },
      size: function () {
        return this.errorList.length;
      },
      focusInvalid: function () {
        if (this.settings.focusInvalid) {
          try {
            $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(':visible').focus().trigger('focusin');
          } catch (e) {
          }
        }
      },
      findLastActive: function () {
        var lastActive = this.lastActive;
        return lastActive && $.grep(this.errorList, function (n) {
          return n.element.name === lastActive.name;
        }).length === 1 && lastActive;
      },
      elements: function () {
        var validator = this, rulesCache = {};
        // select all valid inputs inside the form (no submit or reset buttons)
        return $(this.currentForm).find('input, select, textarea').not(':submit, :reset, :image, [disabled], [readonly]').not(this.settings.ignore).filter(function () {
          if (!this.name && validator.settings.debug && window.console) {
            console.error('%o has no name assigned', this);
          }
          // select only the first element for each name, and only those with rules specified
          if (this.name in rulesCache || !validator.objectLength($(this).rules())) {
            return false;
          }
          rulesCache[this.name] = true;
          return true;
        });
      },
      clean: function (selector) {
        return $(selector)[0];
      },
      errors: function () {
        var errorClass = this.settings.errorClass.split(' ').join('.');
        return $(this.settings.errorElement + '.' + errorClass, this.errorContext);
      },
      reset: function () {
        this.successList = [];
        this.errorList = [];
        this.errorMap = {};
        this.toShow = $([]);
        this.toHide = $([]);
        this.currentElements = $([]);
      },
      prepareForm: function () {
        this.reset();
        this.toHide = this.errors().add(this.containers);
      },
      prepareElement: function (element) {
        this.reset();
        this.toHide = this.errorsFor(element);
      },
      elementValue: function (element) {
        var val, $element = $(element), type = element.type;
        if (type === 'radio' || type === 'checkbox') {
          return $('input[name=\'' + element.name + '\']:checked').val();
        } else if (type === 'number' && typeof element.validity !== 'undefined') {
          return element.validity.badInput ? false : $element.val();
        }
        val = $element.val();
        if (typeof val === 'string') {
          return val.replace(/\r/g, '');
        }
        return val;
      },
      check: function (element) {
        element = this.validationTargetFor(this.clean(element));
        var rules = $(element).rules(), rulesCount = $.map(rules, function (n, i) {
            return i;
          }).length, dependencyMismatch = false, val = this.elementValue(element), result, method, rule;
        for (method in rules) {
          rule = {
            method: method,
            parameters: rules[method]
          };
          try {
            result = $.validator.methods[method].call(this, val, element, rule.parameters);
            // if a method indicates that the field is optional and therefore valid,
            // don't mark it as valid when there are no other rules
            if (result === 'dependency-mismatch' && rulesCount === 1) {
              dependencyMismatch = true;
              continue;
            }
            dependencyMismatch = false;
            if (result === 'pending') {
              this.toHide = this.toHide.not(this.errorsFor(element));
              return;
            }
            if (!result) {
              this.formatAndAdd(element, rule);
              return false;
            }
          } catch (e) {
            if (this.settings.debug && window.console) {
              console.log('Exception occurred when checking element ' + element.id + ', check the \'' + rule.method + '\' method.', e);
            }
            throw e;
          }
        }
        if (dependencyMismatch) {
          return;
        }
        if (this.objectLength(rules)) {
          this.successList.push(element);
        }
        return true;
      },
      customDataMessage: function (element, method) {
        return $(element).data('msg' + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()) || $(element).data('msg');
      },
      customMessage: function (name, method) {
        var m = this.settings.messages[name];
        return m && (m.constructor === String ? m : m[method]);
      },
      findDefined: function () {
        for (var i = 0; i < arguments.length; i++) {
          if (arguments[i] !== undefined) {
            return arguments[i];
          }
        }
        return undefined;
      },
      defaultMessage: function (element, method) {
        return this.findDefined(this.customMessage(element.name, method), this.customDataMessage(element, method), !this.settings.ignoreTitle && element.title || undefined, $.validator.messages[method], '<strong>Warning: No message defined for ' + element.name + '</strong>');
      },
      formatAndAdd: function (element, rule) {
        var message = this.defaultMessage(element, rule.method), theregex = /\$?\{(\d+)\}/g;
        if (typeof message === 'function') {
          message = message.call(this, rule.parameters, element);
        } else if (theregex.test(message)) {
          message = $.validator.format(message.replace(theregex, '{$1}'), rule.parameters);
        }
        this.errorList.push({
          message: message,
          element: element,
          method: rule.method
        });
        this.errorMap[element.name] = message;
        this.submitted[element.name] = message;
      },
      addWrapper: function (toToggle) {
        if (this.settings.wrapper) {
          toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
        }
        return toToggle;
      },
      defaultShowErrors: function () {
        var i, elements, error;
        for (i = 0; this.errorList[i]; i++) {
          error = this.errorList[i];
          if (this.settings.highlight) {
            this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
          }
          this.showLabel(error.element, error.message);
        }
        if (this.errorList.length) {
          this.toShow = this.toShow.add(this.containers);
        }
        if (this.settings.success) {
          for (i = 0; this.successList[i]; i++) {
            this.showLabel(this.successList[i]);
          }
        }
        if (this.settings.unhighlight) {
          for (i = 0, elements = this.validElements(); elements[i]; i++) {
            this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
          }
        }
        this.toHide = this.toHide.not(this.toShow);
        this.hideErrors();
        this.addWrapper(this.toShow).show();
      },
      validElements: function () {
        return this.currentElements.not(this.invalidElements());
      },
      invalidElements: function () {
        return $(this.errorList).map(function () {
          return this.element;
        });
      },
      showLabel: function (element, message) {
        var place, group, errorID, error = this.errorsFor(element), elementID = this.idOrName(element), describedBy = $(element).attr('aria-describedby');
        if (error.length) {
          // refresh error/success class
          error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);
          // replace message on existing label
          error.html(message);
        } else {
          // create error element
          error = $('<' + this.settings.errorElement + '>').attr('id', elementID + '-error').addClass(this.settings.errorClass).html(message || '');
          // Maintain reference to the element to be placed into the DOM
          place = error;
          if (this.settings.wrapper) {
            // make sure the element is visible, even in IE
            // actually showing the wrapped element is handled elsewhere
            place = error.hide().show().wrap('<' + this.settings.wrapper + '/>').parent();
          }
          if (this.labelContainer.length) {
            this.labelContainer.append(place);
          } else if (this.settings.errorPlacement) {
            this.settings.errorPlacement(place, $(element));
          } else {
            place.insertAfter(element);
          }
          // Link error back to the element
          if (error.is('label')) {
            // If the error is a label, then associate using 'for'
            error.attr('for', elementID);
          } else if (error.parents('label[for=\'' + elementID + '\']').length === 0) {
            // If the element is not a child of an associated label, then it's necessary
            // to explicitly apply aria-describedby
            errorID = error.attr('id').replace(/(:|\.|\[|\])/g, '\\$1');
            // Respect existing non-error aria-describedby
            if (!describedBy) {
              describedBy = errorID;
            } else if (!describedBy.match(new RegExp('\\b' + errorID + '\\b'))) {
              // Add to end of list if not already present
              describedBy += ' ' + errorID;
            }
            $(element).attr('aria-describedby', describedBy);
            // If this element is grouped, then assign to all elements in the same group
            group = this.groups[element.name];
            if (group) {
              $.each(this.groups, function (name, testgroup) {
                if (testgroup === group) {
                  $('[name=\'' + name + '\']', this.currentForm).attr('aria-describedby', error.attr('id'));
                }
              });
            }
          }
        }
        if (!message && this.settings.success) {
          error.text('');
          if (typeof this.settings.success === 'string') {
            error.addClass(this.settings.success);
          } else {
            this.settings.success(error, element);
          }
        }
        this.toShow = this.toShow.add(error);
      },
      errorsFor: function (element) {
        var name = this.idOrName(element), describer = $(element).attr('aria-describedby'), selector = 'label[for=\'' + name + '\'], label[for=\'' + name + '\'] *';
        // aria-describedby should directly reference the error element
        if (describer) {
          selector = selector + ', #' + describer.replace(/\s+/g, ', #');
        }
        return this.errors().filter(selector);
      },
      idOrName: function (element) {
        return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
      },
      validationTargetFor: function (element) {
        // If radio/checkbox, validate first element in group instead
        if (this.checkable(element)) {
          element = this.findByName(element.name);
        }
        // Always apply ignore filter
        return $(element).not(this.settings.ignore)[0];
      },
      checkable: function (element) {
        return /radio|checkbox/i.test(element.type);
      },
      findByName: function (name) {
        return $(this.currentForm).find('[name=\'' + name + '\']');
      },
      getLength: function (value, element) {
        switch (element.nodeName.toLowerCase()) {
        case 'select':
          return $('option:selected', element).length;
        case 'input':
          if (this.checkable(element)) {
            return this.findByName(element.name).filter(':checked').length;
          }
        }
        return value.length;
      },
      depend: function (param, element) {
        return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
      },
      dependTypes: {
        'boolean': function (param) {
          return param;
        },
        'string': function (param, element) {
          return !!$(param, element.form).length;
        },
        'function': function (param, element) {
          return param(element);
        }
      },
      optional: function (element) {
        var val = this.elementValue(element);
        return !$.validator.methods.required.call(this, val, element) && 'dependency-mismatch';
      },
      startRequest: function (element) {
        if (!this.pending[element.name]) {
          this.pendingRequest++;
          this.pending[element.name] = true;
        }
      },
      stopRequest: function (element, valid) {
        this.pendingRequest--;
        // sometimes synchronization fails, make sure pendingRequest is never < 0
        if (this.pendingRequest < 0) {
          this.pendingRequest = 0;
        }
        delete this.pending[element.name];
        if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
          $(this.currentForm).submit();
          this.formSubmitted = false;
        } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
          $(this.currentForm).triggerHandler('invalid-form', [this]);
          this.formSubmitted = false;
        }
      },
      previousValue: function (element) {
        return $.data(element, 'previousValue') || $.data(element, 'previousValue', {
          old: null,
          valid: true,
          message: this.defaultMessage(element, 'remote')
        });
      }
    },
    classRuleSettings: {
      required: { required: true },
      email: { email: true },
      url: { url: true },
      date: { date: true },
      dateISO: { dateISO: true },
      number: { number: true },
      digits: { digits: true },
      creditcard: { creditcard: true }
    },
    addClassRules: function (className, rules) {
      if (className.constructor === String) {
        this.classRuleSettings[className] = rules;
      } else {
        $.extend(this.classRuleSettings, className);
      }
    },
    classRules: function (element) {
      var rules = {}, classes = $(element).attr('class');
      if (classes) {
        $.each(classes.split(' '), function () {
          if (this in $.validator.classRuleSettings) {
            $.extend(rules, $.validator.classRuleSettings[this]);
          }
        });
      }
      return rules;
    },
    attributeRules: function (element) {
      var rules = {}, $element = $(element), type = element.getAttribute('type'), method, value;
      for (method in $.validator.methods) {
        // support for <input required> in both html5 and older browsers
        if (method === 'required') {
          value = element.getAttribute(method);
          // Some browsers return an empty string for the required attribute
          // and non-HTML5 browsers might have required="" markup
          if (value === '') {
            value = true;
          }
          // force non-HTML5 browsers to return bool
          value = !!value;
        } else {
          value = $element.attr(method);
        }
        // convert the value to a number for number inputs, and for text for backwards compability
        // allows type="date" and others to be compared as strings
        if (/min|max/.test(method) && (type === null || /number|range|text/.test(type))) {
          value = Number(value);
        }
        if (value || value === 0) {
          rules[method] = value;
        } else if (type === method && type !== 'range') {
          // exception: the jquery validate 'range' method
          // does not test for the html5 'range' type
          rules[method] = true;
        }
      }
      // maxlength may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
      if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
        delete rules.maxlength;
      }
      return rules;
    },
    dataRules: function (element) {
      var method, value, rules = {}, $element = $(element);
      for (method in $.validator.methods) {
        value = $element.data('rule' + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());
        if (value !== undefined) {
          rules[method] = value;
        }
      }
      return rules;
    },
    staticRules: function (element) {
      var rules = {}, validator = $.data(element.form, 'validator');
      if (validator.settings.rules) {
        rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
      }
      return rules;
    },
    normalizeRules: function (rules, element) {
      // handle dependency check
      $.each(rules, function (prop, val) {
        // ignore rule when param is explicitly false, eg. required:false
        if (val === false) {
          delete rules[prop];
          return;
        }
        if (val.param || val.depends) {
          var keepRule = true;
          switch (typeof val.depends) {
          case 'string':
            keepRule = !!$(val.depends, element.form).length;
            break;
          case 'function':
            keepRule = val.depends.call(element, element);
            break;
          }
          if (keepRule) {
            rules[prop] = val.param !== undefined ? val.param : true;
          } else {
            delete rules[prop];
          }
        }
      });
      // evaluate parameters
      $.each(rules, function (rule, parameter) {
        rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
      });
      // clean number parameters
      $.each([
        'minlength',
        'maxlength'
      ], function () {
        if (rules[this]) {
          rules[this] = Number(rules[this]);
        }
      });
      $.each([
        'rangelength',
        'range'
      ], function () {
        var parts;
        if (rules[this]) {
          if ($.isArray(rules[this])) {
            rules[this] = [
              Number(rules[this][0]),
              Number(rules[this][1])
            ];
          } else if (typeof rules[this] === 'string') {
            parts = rules[this].replace(/[\[\]]/g, '').split(/[\s,]+/);
            rules[this] = [
              Number(parts[0]),
              Number(parts[1])
            ];
          }
        }
      });
      if ($.validator.autoCreateRanges) {
        // auto-create ranges
        if (rules.min != null && rules.max != null) {
          rules.range = [
            rules.min,
            rules.max
          ];
          delete rules.min;
          delete rules.max;
        }
        if (rules.minlength != null && rules.maxlength != null) {
          rules.rangelength = [
            rules.minlength,
            rules.maxlength
          ];
          delete rules.minlength;
          delete rules.maxlength;
        }
      }
      return rules;
    },
    normalizeRule: function (data) {
      if (typeof data === 'string') {
        var transformed = {};
        $.each(data.split(/\s/), function () {
          transformed[this] = true;
        });
        data = transformed;
      }
      return data;
    },
    addMethod: function (name, method, message) {
      $.validator.methods[name] = method;
      $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
      if (method.length < 3) {
        $.validator.addClassRules(name, $.validator.normalizeRule(name));
      }
    },
    methods: {
      required: function (value, element, param) {
        // check if dependency is met
        if (!this.depend(param, element)) {
          return 'dependency-mismatch';
        }
        if (element.nodeName.toLowerCase() === 'select') {
          // could be an array for select-multiple or a string, both are fine this way
          var val = $(element).val();
          return val && val.length > 0;
        }
        if (this.checkable(element)) {
          return this.getLength(value, element) > 0;
        }
        return $.trim(value).length > 0;
      },
      email: function (value, element) {
        // From http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29
        // Retrieved 2014-01-14
        // If you have a problem with this implementation, report a bug against the above spec
        // Or use custom methods to implement your own email validation
        return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
      },
      url: function (value, element) {
        // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
        return this.optional(element) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
      },
      date: function (value, element) {
        return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
      },
      dateISO: function (value, element) {
        return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
      },
      number: function (value, element) {
        return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
      },
      digits: function (value, element) {
        return this.optional(element) || /^\d+$/.test(value);
      },
      creditcard: function (value, element) {
        if (this.optional(element)) {
          return 'dependency-mismatch';
        }
        // accept only spaces, digits and dashes
        if (/[^0-9 \-]+/.test(value)) {
          return false;
        }
        var nCheck = 0, nDigit = 0, bEven = false, n, cDigit;
        value = value.replace(/\D/g, '');
        // Basing min and max length on
        // http://developer.ean.com/general_info/Valid_Credit_Card_Types
        if (value.length < 13 || value.length > 19) {
          return false;
        }
        for (n = value.length - 1; n >= 0; n--) {
          cDigit = value.charAt(n);
          nDigit = parseInt(cDigit, 10);
          if (bEven) {
            if ((nDigit *= 2) > 9) {
              nDigit -= 9;
            }
          }
          nCheck += nDigit;
          bEven = !bEven;
        }
        return nCheck % 10 === 0;
      },
      minlength: function (value, element, param) {
        var length = $.isArray(value) ? value.length : this.getLength(value, element);
        return this.optional(element) || length >= param;
      },
      maxlength: function (value, element, param) {
        var length = $.isArray(value) ? value.length : this.getLength(value, element);
        return this.optional(element) || length <= param;
      },
      rangelength: function (value, element, param) {
        var length = $.isArray(value) ? value.length : this.getLength(value, element);
        return this.optional(element) || length >= param[0] && length <= param[1];
      },
      min: function (value, element, param) {
        return this.optional(element) || value >= param;
      },
      max: function (value, element, param) {
        return this.optional(element) || value <= param;
      },
      range: function (value, element, param) {
        return this.optional(element) || value >= param[0] && value <= param[1];
      },
      equalTo: function (value, element, param) {
        // bind to the blur event of the target in order to revalidate whenever the target field is updated
        // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
        var target = $(param);
        if (this.settings.onfocusout) {
          target.unbind('.validate-equalTo').bind('blur.validate-equalTo', function () {
            $(element).valid();
          });
        }
        return value === target.val();
      },
      remote: function (value, element, param) {
        if (this.optional(element)) {
          return 'dependency-mismatch';
        }
        var previous = this.previousValue(element), validator, data;
        if (!this.settings.messages[element.name]) {
          this.settings.messages[element.name] = {};
        }
        previous.originalMessage = this.settings.messages[element.name].remote;
        this.settings.messages[element.name].remote = previous.message;
        param = typeof param === 'string' && { url: param } || param;
        if (previous.old === value) {
          return previous.valid;
        }
        previous.old = value;
        validator = this;
        this.startRequest(element);
        data = {};
        data[element.name] = value;
        $.ajax($.extend(true, {
          url: param,
          mode: 'abort',
          port: 'validate' + element.name,
          dataType: 'json',
          data: data,
          context: validator.currentForm,
          success: function (response) {
            var valid = response === true || response === 'true', errors, message, submitted;
            validator.settings.messages[element.name].remote = previous.originalMessage;
            if (valid) {
              submitted = validator.formSubmitted;
              validator.prepareElement(element);
              validator.formSubmitted = submitted;
              validator.successList.push(element);
              delete validator.invalid[element.name];
              validator.showErrors();
            } else {
              errors = {};
              message = response || validator.defaultMessage(element, 'remote');
              errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
              validator.invalid[element.name] = true;
              validator.showErrors(errors);
            }
            previous.valid = valid;
            validator.stopRequest(element, valid);
          }
        }, param));
        return 'pending';
      }
    }
  });
  $.format = function deprecated() {
    throw '$.format has been deprecated. Please use $.validator.format instead.';
  };
  // ajax mode: abort
  // usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
  // if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
  var pendingRequests = {}, ajax;
  // Use a prefilter if available (1.5+)
  if ($.ajaxPrefilter) {
    $.ajaxPrefilter(function (settings, _, xhr) {
      var port = settings.port;
      if (settings.mode === 'abort') {
        if (pendingRequests[port]) {
          pendingRequests[port].abort();
        }
        pendingRequests[port] = xhr;
      }
    });
  } else {
    // Proxy ajax
    ajax = $.ajax;
    $.ajax = function (settings) {
      var mode = ('mode' in settings ? settings : $.ajaxSettings).mode, port = ('port' in settings ? settings : $.ajaxSettings).port;
      if (mode === 'abort') {
        if (pendingRequests[port]) {
          pendingRequests[port].abort();
        }
        pendingRequests[port] = ajax.apply(this, arguments);
        return pendingRequests[port];
      }
      return ajax.apply(this, arguments);
    };
  }
  // provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
  // handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
  $.extend($.fn, {
    validateDelegate: function (delegate, type, handler) {
      return this.bind(type, function (event) {
        var target = $(event.target);
        if (target.is(delegate)) {
          return handler.apply(target, arguments);
        }
      });
    }
  });
}));// This [jQuery](https://jquery.com/) plugin implements an `<iframe>`
// [transport](https://api.jquery.com/jQuery.ajax/#extending-ajax) so that
// `$.ajax()` calls support the uploading of files using standard HTML file
// input fields. This is done by switching the exchange from `XMLHttpRequest`
// to a hidden `iframe` element containing a form that is submitted.
// The [source for the plugin](https://github.com/cmlenz/jquery-iframe-transport)
// is available on [Github](https://github.com/) and licensed under the [MIT
// license](https://github.com/cmlenz/jquery-iframe-transport/blob/master/LICENSE).
// ## Usage
// To use this plugin, you simply add an `iframe` option with the value `true`
// to the Ajax settings an `$.ajax()` call, and specify the file fields to
// include in the submssion using the `files` option, which can be a selector,
// jQuery object, or a list of DOM elements containing one or more
// `<input type="file">` elements:
//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             files: $(":file", this),
//             iframe: true
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });
// The plugin will construct hidden `<iframe>` and `<form>` elements, add the
// file field(s) to that form, submit the form, and process the response.
// If you want to include other form fields in the form submission, include
// them in the `data` option, and set the `processData` option to `false`:
//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             data: $(":text", this).serializeArray(),
//             files: $(":file", this),
//             iframe: true,
//             processData: false
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });
// ### Response Data Types
// As the transport does not have access to the HTTP headers of the server
// response, it is not as simple to make use of the automatic content type
// detection provided by jQuery as with regular XHR. If you can't set the
// expected response data type (for example because it may vary depending on
// the outcome of processing by the server), you will need to employ a
// workaround on the server side: Send back an HTML document containing just a
// `<textarea>` element with a `data-type` attribute that specifies the MIME
// type, and put the actual payload in the textarea:
//     <textarea data-type="application/json">
//       {"ok": true, "message": "Thanks so much"}
//     </textarea>
// The iframe transport plugin will detect this and pass the value of the
// `data-type` attribute on to jQuery as if it was the "Content-Type" response
// header, thereby enabling the same kind of conversions that jQuery applies
// to regular responses. For the example above you should get a Javascript
// object as the `data` parameter of the `complete` callback, with the
// properties `ok: true` and `message: "Thanks so much"`.
// ### Handling Server Errors
// Another problem with using an `iframe` for file uploads is that it is
// impossible for the javascript code to determine the HTTP status code of the
// servers response. Effectively, all of the calls you make will look like they
// are getting successful responses, and thus invoke the `done()` or
// `complete()` callbacks. You can only communicate problems using the content
// of the response payload. For example, consider using a JSON response such as
// the following to indicate a problem with an uploaded file:
//     <textarea data-type="application/json">
//       {"ok": false, "message": "Please only upload reasonably sized files."}
//     </textarea>
// ### Compatibility
// This plugin has primarily been tested on Safari 5 (or later), Firefox 4 (or
// later), and Internet Explorer (all the way back to version 6). While I
// haven't found any issues with it so far, I'm fairly sure it still doesn't
// work around all the quirks in all different browsers. But the code is still
// pretty simple overall, so you should be able to fix it and contribute a
// patch :)
// ## Annotated Source
(function ($, undefined) {
  'use strict';
  // Register a prefilter that checks whether the `iframe` option is set, and
  // switches to the "iframe" data type if it is `true`.
  $.ajaxPrefilter(function (options, origOptions, jqXHR) {
    if (options.iframe) {
      options.originalURL = options.url;
      return 'iframe';
    }
  });
  // Register a transport for the "iframe" data type. It will only activate
  // when the "files" option has been set to a non-empty list of enabled file
  // inputs.
  $.ajaxTransport('iframe', function (options, origOptions, jqXHR) {
    var form = null, iframe = null, name = 'iframe-' + $.now(), files = $(options.files).filter(':file:enabled'), markers = null, accepts = null;
    // This function gets called after a successful submission or an abortion
    // and should revert all changes made to the page to enable the
    // submission via this transport.
    function cleanUp() {
      files.each(function (i, file) {
        var $file = $(file);
        $file.data('clone').replaceWith($file);
      });
      form.remove();
      iframe.one('load', function () {
        iframe.remove();
      });
      iframe.attr('src', 'javascript:false;');
    }
    // Remove "iframe" from the data types list so that further processing is
    // based on the content type returned by the server, without attempting an
    // (unsupported) conversion from "iframe" to the actual type.
    options.dataTypes.shift();
    // Use the data from the original AJAX options, as it doesn't seem to be 
    // copied over since jQuery 1.7.
    // See https://github.com/cmlenz/jquery-iframe-transport/issues/6
    options.data = origOptions.data;
    if (files.length) {
      form = $('<form enctype=\'multipart/form-data\' method=\'post\'></form>').hide().attr({
        action: options.originalURL,
        target: name
      });
      // If there is any additional data specified via the `data` option,
      // we add it as hidden fields to the form. This (currently) requires
      // the `processData` option to be set to false so that the data doesn't
      // get serialized to a string.
      if (typeof options.data === 'string' && options.data.length > 0) {
        $.error('data must not be serialized');
      }
      $.each(options.data || {}, function (name, value) {
        if ($.isPlainObject(value)) {
          name = value.name;
          value = value.value;
        }
        $('<input type=\'hidden\' />').attr({
          name: name,
          value: value
        }).appendTo(form);
      });
      // Add a hidden `X-Requested-With` field with the value `IFrame` to the
      // field, to help server-side code to determine that the upload happened
      // through this transport.
      $('<input type=\'hidden\' value=\'IFrame\' name=\'X-Requested-With\' />').appendTo(form);
      // Borrowed straight from the JQuery source.
      // Provides a way of specifying the accepted data type similar to the
      // HTTP "Accept" header
      if (options.dataTypes[0] && options.accepts[options.dataTypes[0]]) {
        accepts = options.accepts[options.dataTypes[0]] + (options.dataTypes[0] !== '*' ? ', */*; q=0.01' : '');
      } else {
        accepts = options.accepts['*'];
      }
      $('<input type=\'hidden\' name=\'X-HTTP-Accept\'>').attr('value', accepts).appendTo(form);
      // Move the file fields into the hidden form, but first remember their
      // original locations in the document by replacing them with disabled
      // clones. This should also avoid introducing unwanted changes to the
      // page layout during submission.
      markers = files.after(function (idx) {
        var $this = $(this), $clone = $this.clone().prop('disabled', true);
        $this.data('clone', $clone);
        return $clone;
      }).next();
      files.appendTo(form);
      return {
        send: function (headers, completeCallback) {
          iframe = $('<iframe src=\'javascript:false;\' name=\'' + name + '\' id=\'' + name + '\' style=\'display:none\'></iframe>');
          // The first load event gets fired after the iframe has been injected
          // into the DOM, and is used to prepare the actual submission.
          iframe.one('load', function () {
            // The second load event gets fired when the response to the form
            // submission is received. The implementation detects whether the
            // actual payload is embedded in a `<textarea>` element, and
            // prepares the required conversions to be made in that case.
            iframe.one('load', function () {
              var doc = this.contentWindow ? this.contentWindow.document : this.contentDocument ? this.contentDocument : this.document, root = doc.documentElement ? doc.documentElement : doc.body, textarea = root.getElementsByTagName('textarea')[0], type = textarea && textarea.getAttribute('data-type') || null, status = textarea && textarea.getAttribute('data-status') || 200, statusText = textarea && textarea.getAttribute('data-statusText') || 'OK', content = {
                  html: root.innerHTML,
                  text: type ? textarea.value : root ? root.textContent || root.innerText : null
                };
              cleanUp();
              completeCallback(status, statusText, content, type ? 'Content-Type: ' + type : null);
            });
            // Now that the load handler has been set up, submit the form.
            form[0].submit();
          });
          // After everything has been set up correctly, the form and iframe
          // get injected into the DOM so that the submission can be
          // initiated.
          $('body').append(form, iframe);
        },
        abort: function () {
          if (iframe !== null) {
            iframe.unbind('load').attr('src', 'javascript:false;');
            cleanUp();
          }
        }
      };
    }
  });
}(jQuery));/*
 * jQuery File Upload Plugin 5.42.3
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, require, window, document, location, Blob, FormData */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      'jquery.ui.widget'
    ], factory);
  } else if (typeof exports === 'object') {
    // Node/CommonJS:
    factory(require('jquery'), require('./vendor/jquery.ui.widget'));
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  // Detect file input support, based on
  // http://viljamis.com/blog/2012/file-upload-support-on-mobile/
  $.support.fileInput = !(new RegExp('(Android (1\\.[0156]|2\\.[01]))' + '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' + '|(w(eb)?OSBrowser)|(webOS)' + '|(Kindle/(1\\.0|2\\.[05]|3\\.0))').test(window.navigator.userAgent) || $('<input type="file">').prop('disabled'));
  // The FileReader API is not actually used, but works as feature detection,
  // as some Safari versions (5?) support XHR file uploads via the FormData API,
  // but not non-multipart XHR file uploads.
  // window.XMLHttpRequestUpload is not available on IE10, so we check for
  // window.ProgressEvent instead to detect XHR2 file upload capability:
  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
  $.support.xhrFormDataFileUpload = !!window.FormData;
  // Detect support for Blob slicing (required for chunked uploads):
  $.support.blobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);
  // Helper function to create drag handlers for dragover/dragenter/dragleave:
  function getDragHandler(type) {
    var isDragOver = type === 'dragover';
    return function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var dataTransfer = e.dataTransfer;
      if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 && this._trigger(type, $.Event(type, { delegatedEvent: e })) !== false) {
        e.preventDefault();
        if (isDragOver) {
          dataTransfer.dropEffect = 'copy';
        }
      }
    };
  }
  // The fileupload widget listens for change events on file input fields defined
  // via fileInput setting and paste or drop events of the given dropZone.
  // In addition to the default jQuery Widget methods, the fileupload widget
  // exposes the "add" and "send" methods, to add or directly send files using
  // the fileupload API.
  // By default, files added via file input selection, paste, drag & drop or
  // "add" method are uploaded immediately, but it is possible to override
  // the "add" callback option to queue file uploads.
  $.widget('blueimp.fileupload', {
    options: {
      dropZone: $(document),
      pasteZone: undefined,
      fileInput: undefined,
      replaceFileInput: true,
      paramName: undefined,
      singleFileUploads: true,
      limitMultiFileUploads: undefined,
      limitMultiFileUploadSize: undefined,
      limitMultiFileUploadSizeOverhead: 512,
      sequentialUploads: false,
      limitConcurrentUploads: undefined,
      forceIframeTransport: false,
      redirect: undefined,
      redirectParamName: undefined,
      postMessage: undefined,
      multipart: true,
      maxChunkSize: undefined,
      uploadedBytes: undefined,
      recalculateProgress: true,
      progressInterval: 100,
      bitrateInterval: 500,
      autoUpload: true,
      messages: { uploadedBytes: 'Uploaded bytes exceed file size' },
      i18n: function (message, context) {
        message = this.messages[message] || message.toString();
        if (context) {
          $.each(context, function (key, value) {
            message = message.replace('{' + key + '}', value);
          });
        }
        return message;
      },
      formData: function (form) {
        return form.serializeArray();
      },
      add: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        if (data.autoUpload || data.autoUpload !== false && $(this).fileupload('option', 'autoUpload')) {
          data.process().done(function () {
            data.submit();
          });
        }
      },
      processData: false,
      contentType: false,
      cache: false
    },
    _specialOptions: [
      'fileInput',
      'dropZone',
      'pasteZone',
      'multipart',
      'forceIframeTransport'
    ],
    _blobSlice: $.support.blobSlice && function () {
      var slice = this.slice || this.webkitSlice || this.mozSlice;
      return slice.apply(this, arguments);
    },
    _BitrateTimer: function () {
      this.timestamp = Date.now ? Date.now() : new Date().getTime();
      this.loaded = 0;
      this.bitrate = 0;
      this.getBitrate = function (now, loaded, interval) {
        var timeDiff = now - this.timestamp;
        if (!this.bitrate || !interval || timeDiff > interval) {
          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
          this.loaded = loaded;
          this.timestamp = now;
        }
        return this.bitrate;
      };
    },
    _isXHRUpload: function (options) {
      return !options.forceIframeTransport && (!options.multipart && $.support.xhrFileUpload || $.support.xhrFormDataFileUpload);
    },
    _getFormData: function (options) {
      var formData;
      if ($.type(options.formData) === 'function') {
        return options.formData(options.form);
      }
      if ($.isArray(options.formData)) {
        return options.formData;
      }
      if ($.type(options.formData) === 'object') {
        formData = [];
        $.each(options.formData, function (name, value) {
          formData.push({
            name: name,
            value: value
          });
        });
        return formData;
      }
      return [];
    },
    _getTotal: function (files) {
      var total = 0;
      $.each(files, function (index, file) {
        total += file.size || 1;
      });
      return total;
    },
    _initProgressObject: function (obj) {
      var progress = {
          loaded: 0,
          total: 0,
          bitrate: 0
        };
      if (obj._progress) {
        $.extend(obj._progress, progress);
      } else {
        obj._progress = progress;
      }
    },
    _initResponseObject: function (obj) {
      var prop;
      if (obj._response) {
        for (prop in obj._response) {
          if (obj._response.hasOwnProperty(prop)) {
            delete obj._response[prop];
          }
        }
      } else {
        obj._response = {};
      }
    },
    _onProgress: function (e, data) {
      if (e.lengthComputable) {
        var now = Date.now ? Date.now() : new Date().getTime(), loaded;
        if (data._time && data.progressInterval && now - data._time < data.progressInterval && e.loaded !== e.total) {
          return;
        }
        data._time = now;
        loaded = Math.floor(e.loaded / e.total * (data.chunkSize || data._progress.total)) + (data.uploadedBytes || 0);
        // Add the difference from the previously loaded state
        // to the global loaded counter:
        this._progress.loaded += loaded - data._progress.loaded;
        this._progress.bitrate = this._bitrateTimer.getBitrate(now, this._progress.loaded, data.bitrateInterval);
        data._progress.loaded = data.loaded = loaded;
        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(now, loaded, data.bitrateInterval);
        // Trigger a custom progress event with a total data property set
        // to the file size(s) of the current upload and a loaded data
        // property calculated accordingly:
        this._trigger('progress', $.Event('progress', { delegatedEvent: e }), data);
        // Trigger a global progress event for all current file uploads,
        // including ajax calls queued for sequential file uploads:
        this._trigger('progressall', $.Event('progressall', { delegatedEvent: e }), this._progress);
      }
    },
    _initProgressListener: function (options) {
      var that = this, xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
      // Accesss to the native XHR object is required to add event listeners
      // for the upload progress event:
      if (xhr.upload) {
        $(xhr.upload).bind('progress', function (e) {
          var oe = e.originalEvent;
          // Make sure the progress event properties get copied over:
          e.lengthComputable = oe.lengthComputable;
          e.loaded = oe.loaded;
          e.total = oe.total;
          that._onProgress(e, options);
        });
        options.xhr = function () {
          return xhr;
        };
      }
    },
    _isInstanceOf: function (type, obj) {
      // Cross-frame instanceof check
      return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    },
    _initXHRData: function (options) {
      var that = this, formData, file = options.files[0],
        // Ignore non-multipart setting if not supported:
        multipart = options.multipart || !$.support.xhrFileUpload, paramName = $.type(options.paramName) === 'array' ? options.paramName[0] : options.paramName;
      options.headers = $.extend({}, options.headers);
      if (options.contentRange) {
        options.headers['Content-Range'] = options.contentRange;
      }
      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
        options.headers['Content-Disposition'] = 'attachment; filename="' + encodeURI(file.name) + '"';
      }
      if (!multipart) {
        options.contentType = file.type || 'application/octet-stream';
        options.data = options.blob || file;
      } else if ($.support.xhrFormDataFileUpload) {
        if (options.postMessage) {
          // window.postMessage does not allow sending FormData
          // objects, so we just add the File/Blob objects to
          // the formData array and let the postMessage window
          // create the FormData object out of this array:
          formData = this._getFormData(options);
          if (options.blob) {
            formData.push({
              name: paramName,
              value: options.blob
            });
          } else {
            $.each(options.files, function (index, file) {
              formData.push({
                name: $.type(options.paramName) === 'array' && options.paramName[index] || paramName,
                value: file
              });
            });
          }
        } else {
          if (that._isInstanceOf('FormData', options.formData)) {
            formData = options.formData;
          } else {
            formData = new FormData();
            $.each(this._getFormData(options), function (index, field) {
              formData.append(field.name, field.value);
            });
          }
          if (options.blob) {
            formData.append(paramName, options.blob, file.name);
          } else {
            $.each(options.files, function (index, file) {
              // This check allows the tests to run with
              // dummy objects:
              if (that._isInstanceOf('File', file) || that._isInstanceOf('Blob', file)) {
                formData.append($.type(options.paramName) === 'array' && options.paramName[index] || paramName, file, file.uploadName || file.name);
              }
            });
          }
        }
        options.data = formData;
      }
      // Blob reference is not needed anymore, free memory:
      options.blob = null;
    },
    _initIframeSettings: function (options) {
      var targetHost = $('<a></a>').prop('href', options.url).prop('host');
      // Setting the dataType to iframe enables the iframe transport:
      options.dataType = 'iframe ' + (options.dataType || '');
      // The iframe transport accepts a serialized array as form data:
      options.formData = this._getFormData(options);
      // Add redirect url to form data on cross-domain uploads:
      if (options.redirect && targetHost && targetHost !== location.host) {
        options.formData.push({
          name: options.redirectParamName || 'redirect',
          value: options.redirect
        });
      }
    },
    _initDataSettings: function (options) {
      if (this._isXHRUpload(options)) {
        if (!this._chunkedUpload(options, true)) {
          if (!options.data) {
            this._initXHRData(options);
          }
          this._initProgressListener(options);
        }
        if (options.postMessage) {
          // Setting the dataType to postmessage enables the
          // postMessage transport:
          options.dataType = 'postmessage ' + (options.dataType || '');
        }
      } else {
        this._initIframeSettings(options);
      }
    },
    _getParamName: function (options) {
      var fileInput = $(options.fileInput), paramName = options.paramName;
      if (!paramName) {
        paramName = [];
        fileInput.each(function () {
          var input = $(this), name = input.prop('name') || 'files[]', i = (input.prop('files') || [1]).length;
          while (i) {
            paramName.push(name);
            i -= 1;
          }
        });
        if (!paramName.length) {
          paramName = [fileInput.prop('name') || 'files[]'];
        }
      } else if (!$.isArray(paramName)) {
        paramName = [paramName];
      }
      return paramName;
    },
    _initFormSettings: function (options) {
      // Retrieve missing options from the input field and the
      // associated form, if available:
      if (!options.form || !options.form.length) {
        options.form = $(options.fileInput.prop('form'));
        // If the given file input doesn't have an associated form,
        // use the default widget file input's form:
        if (!options.form.length) {
          options.form = $(this.options.fileInput.prop('form'));
        }
      }
      options.paramName = this._getParamName(options);
      if (!options.url) {
        options.url = options.form.prop('action') || location.href;
      }
      // The HTTP request method must be "POST" or "PUT":
      options.type = (options.type || $.type(options.form.prop('method')) === 'string' && options.form.prop('method') || '').toUpperCase();
      if (options.type !== 'POST' && options.type !== 'PUT' && options.type !== 'PATCH') {
        options.type = 'POST';
      }
      if (!options.formAcceptCharset) {
        options.formAcceptCharset = options.form.attr('accept-charset');
      }
    },
    _getAJAXSettings: function (data) {
      var options = $.extend({}, this.options, data);
      this._initFormSettings(options);
      this._initDataSettings(options);
      return options;
    },
    _getDeferredState: function (deferred) {
      if (deferred.state) {
        return deferred.state();
      }
      if (deferred.isResolved()) {
        return 'resolved';
      }
      if (deferred.isRejected()) {
        return 'rejected';
      }
      return 'pending';
    },
    _enhancePromise: function (promise) {
      promise.success = promise.done;
      promise.error = promise.fail;
      promise.complete = promise.always;
      return promise;
    },
    _getXHRPromise: function (resolveOrReject, context, args) {
      var dfd = $.Deferred(), promise = dfd.promise();
      context = context || this.options.context || promise;
      if (resolveOrReject === true) {
        dfd.resolveWith(context, args);
      } else if (resolveOrReject === false) {
        dfd.rejectWith(context, args);
      }
      promise.abort = dfd.promise;
      return this._enhancePromise(promise);
    },
    _addConvenienceMethods: function (e, data) {
      var that = this, getPromise = function (args) {
          return $.Deferred().resolveWith(that, args).promise();
        };
      data.process = function (resolveFunc, rejectFunc) {
        if (resolveFunc || rejectFunc) {
          data._processQueue = this._processQueue = (this._processQueue || getPromise([this])).pipe(function () {
            if (data.errorThrown) {
              return $.Deferred().rejectWith(that, [data]).promise();
            }
            return getPromise(arguments);
          }).pipe(resolveFunc, rejectFunc);
        }
        return this._processQueue || getPromise([this]);
      };
      data.submit = function () {
        if (this.state() !== 'pending') {
          data.jqXHR = this.jqXHR = that._trigger('submit', $.Event('submit', { delegatedEvent: e }), this) !== false && that._onSend(e, this);
        }
        return this.jqXHR || that._getXHRPromise();
      };
      data.abort = function () {
        if (this.jqXHR) {
          return this.jqXHR.abort();
        }
        this.errorThrown = 'abort';
        that._trigger('fail', null, this);
        return that._getXHRPromise(false);
      };
      data.state = function () {
        if (this.jqXHR) {
          return that._getDeferredState(this.jqXHR);
        }
        if (this._processQueue) {
          return that._getDeferredState(this._processQueue);
        }
      };
      data.processing = function () {
        return !this.jqXHR && this._processQueue && that._getDeferredState(this._processQueue) === 'pending';
      };
      data.progress = function () {
        return this._progress;
      };
      data.response = function () {
        return this._response;
      };
    },
    _getUploadedBytes: function (jqXHR) {
      var range = jqXHR.getResponseHeader('Range'), parts = range && range.split('-'), upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);
      return upperBytesPos && upperBytesPos + 1;
    },
    _chunkedUpload: function (options, testOnly) {
      options.uploadedBytes = options.uploadedBytes || 0;
      var that = this, file = options.files[0], fs = file.size, ub = options.uploadedBytes, mcs = options.maxChunkSize || fs, slice = this._blobSlice, dfd = $.Deferred(), promise = dfd.promise(), jqXHR, upload;
      if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) || options.data) {
        return false;
      }
      if (testOnly) {
        return true;
      }
      if (ub >= fs) {
        file.error = options.i18n('uploadedBytes');
        return this._getXHRPromise(false, options.context, [
          null,
          'error',
          file.error
        ]);
      }
      // The chunk upload method:
      upload = function () {
        // Clone the options object for each chunk upload:
        var o = $.extend({}, options), currentLoaded = o._progress.loaded;
        o.blob = slice.call(file, ub, ub + mcs, file.type);
        // Store the current chunk size, as the blob itself
        // will be dereferenced after data processing:
        o.chunkSize = o.blob.size;
        // Expose the chunk bytes position range:
        o.contentRange = 'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;
        // Process the upload data (the blob and potential form data):
        that._initXHRData(o);
        // Add progress listeners for this chunk upload:
        that._initProgressListener(o);
        jqXHR = (that._trigger('chunksend', null, o) !== false && $.ajax(o) || that._getXHRPromise(false, o.context)).done(function (result, textStatus, jqXHR) {
          ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;
          // Create a progress event if no final progress event
          // with loaded equaling total has been triggered
          // for this chunk:
          if (currentLoaded + o.chunkSize - o._progress.loaded) {
            that._onProgress($.Event('progress', {
              lengthComputable: true,
              loaded: ub - o.uploadedBytes,
              total: ub - o.uploadedBytes
            }), o);
          }
          options.uploadedBytes = o.uploadedBytes = ub;
          o.result = result;
          o.textStatus = textStatus;
          o.jqXHR = jqXHR;
          that._trigger('chunkdone', null, o);
          that._trigger('chunkalways', null, o);
          if (ub < fs) {
            // File upload not yet complete,
            // continue with the next chunk:
            upload();
          } else {
            dfd.resolveWith(o.context, [
              result,
              textStatus,
              jqXHR
            ]);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          o.jqXHR = jqXHR;
          o.textStatus = textStatus;
          o.errorThrown = errorThrown;
          that._trigger('chunkfail', null, o);
          that._trigger('chunkalways', null, o);
          dfd.rejectWith(o.context, [
            jqXHR,
            textStatus,
            errorThrown
          ]);
        });
      };
      this._enhancePromise(promise);
      promise.abort = function () {
        return jqXHR.abort();
      };
      upload();
      return promise;
    },
    _beforeSend: function (e, data) {
      if (this._active === 0) {
        // the start callback is triggered when an upload starts
        // and no other uploads are currently running,
        // equivalent to the global ajaxStart event:
        this._trigger('start');
        // Set timer for global bitrate progress calculation:
        this._bitrateTimer = new this._BitrateTimer();
        // Reset the global progress values:
        this._progress.loaded = this._progress.total = 0;
        this._progress.bitrate = 0;
      }
      // Make sure the container objects for the .response() and
      // .progress() methods on the data object are available
      // and reset to their initial state:
      this._initResponseObject(data);
      this._initProgressObject(data);
      data._progress.loaded = data.loaded = data.uploadedBytes || 0;
      data._progress.total = data.total = this._getTotal(data.files) || 1;
      data._progress.bitrate = data.bitrate = 0;
      this._active += 1;
      // Initialize the global progress values:
      this._progress.loaded += data.loaded;
      this._progress.total += data.total;
    },
    _onDone: function (result, textStatus, jqXHR, options) {
      var total = options._progress.total, response = options._response;
      if (options._progress.loaded < total) {
        // Create a progress event if no final progress event
        // with loaded equaling total has been triggered:
        this._onProgress($.Event('progress', {
          lengthComputable: true,
          loaded: total,
          total: total
        }), options);
      }
      response.result = options.result = result;
      response.textStatus = options.textStatus = textStatus;
      response.jqXHR = options.jqXHR = jqXHR;
      this._trigger('done', null, options);
    },
    _onFail: function (jqXHR, textStatus, errorThrown, options) {
      var response = options._response;
      if (options.recalculateProgress) {
        // Remove the failed (error or abort) file upload from
        // the global progress calculation:
        this._progress.loaded -= options._progress.loaded;
        this._progress.total -= options._progress.total;
      }
      response.jqXHR = options.jqXHR = jqXHR;
      response.textStatus = options.textStatus = textStatus;
      response.errorThrown = options.errorThrown = errorThrown;
      this._trigger('fail', null, options);
    },
    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
      // jqXHRorResult, textStatus and jqXHRorError are added to the
      // options object via done and fail callbacks
      this._trigger('always', null, options);
    },
    _onSend: function (e, data) {
      if (!data.submit) {
        this._addConvenienceMethods(e, data);
      }
      var that = this, jqXHR, aborted, slot, pipe, options = that._getAJAXSettings(data), send = function () {
          that._sending += 1;
          // Set timer for bitrate progress calculation:
          options._bitrateTimer = new that._BitrateTimer();
          jqXHR = jqXHR || ((aborted || that._trigger('send', $.Event('send', { delegatedEvent: e }), options) === false) && that._getXHRPromise(false, options.context, aborted) || that._chunkedUpload(options) || $.ajax(options)).done(function (result, textStatus, jqXHR) {
            that._onDone(result, textStatus, jqXHR, options);
          }).fail(function (jqXHR, textStatus, errorThrown) {
            that._onFail(jqXHR, textStatus, errorThrown, options);
          }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
            that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options);
            that._sending -= 1;
            that._active -= 1;
            if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) {
              // Start the next queued upload,
              // that has not been aborted:
              var nextSlot = that._slots.shift();
              while (nextSlot) {
                if (that._getDeferredState(nextSlot) === 'pending') {
                  nextSlot.resolve();
                  break;
                }
                nextSlot = that._slots.shift();
              }
            }
            if (that._active === 0) {
              // The stop callback is triggered when all uploads have
              // been completed, equivalent to the global ajaxStop event:
              that._trigger('stop');
            }
          });
          return jqXHR;
        };
      this._beforeSend(e, options);
      if (this.options.sequentialUploads || this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending) {
        if (this.options.limitConcurrentUploads > 1) {
          slot = $.Deferred();
          this._slots.push(slot);
          pipe = slot.pipe(send);
        } else {
          this._sequence = this._sequence.pipe(send, send);
          pipe = this._sequence;
        }
        // Return the piped Promise object, enhanced with an abort method,
        // which is delegated to the jqXHR object of the current upload,
        // and jqXHR callbacks mapped to the equivalent Promise methods:
        pipe.abort = function () {
          aborted = [
            undefined,
            'abort',
            'abort'
          ];
          if (!jqXHR) {
            if (slot) {
              slot.rejectWith(options.context, aborted);
            }
            return send();
          }
          return jqXHR.abort();
        };
        return this._enhancePromise(pipe);
      }
      return send();
    },
    _onAdd: function (e, data) {
      var that = this, result = true, options = $.extend({}, this.options, data), files = data.files, filesLength = files.length, limit = options.limitMultiFileUploads, limitSize = options.limitMultiFileUploadSize, overhead = options.limitMultiFileUploadSizeOverhead, batchSize = 0, paramName = this._getParamName(options), paramNameSet, paramNameSlice, fileSet, i, j = 0;
      if (limitSize && (!filesLength || files[0].size === undefined)) {
        limitSize = undefined;
      }
      if (!(options.singleFileUploads || limit || limitSize) || !this._isXHRUpload(options)) {
        fileSet = [files];
        paramNameSet = [paramName];
      } else if (!(options.singleFileUploads || limitSize) && limit) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i += limit) {
          fileSet.push(files.slice(i, i + limit));
          paramNameSlice = paramName.slice(i, i + limit);
          if (!paramNameSlice.length) {
            paramNameSlice = paramName;
          }
          paramNameSet.push(paramNameSlice);
        }
      } else if (!options.singleFileUploads && limitSize) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i = i + 1) {
          batchSize += files[i].size + overhead;
          if (i + 1 === filesLength || batchSize + files[i + 1].size + overhead > limitSize || limit && i + 1 - j >= limit) {
            fileSet.push(files.slice(j, i + 1));
            paramNameSlice = paramName.slice(j, i + 1);
            if (!paramNameSlice.length) {
              paramNameSlice = paramName;
            }
            paramNameSet.push(paramNameSlice);
            j = i + 1;
            batchSize = 0;
          }
        }
      } else {
        paramNameSet = paramName;
      }
      data.originalFiles = files;
      $.each(fileSet || files, function (index, element) {
        var newData = $.extend({}, data);
        newData.files = fileSet ? element : [element];
        newData.paramName = paramNameSet[index];
        that._initResponseObject(newData);
        that._initProgressObject(newData);
        that._addConvenienceMethods(e, newData);
        result = that._trigger('add', $.Event('add', { delegatedEvent: e }), newData);
        return result;
      });
      return result;
    },
    _replaceFileInput: function (data) {
      var input = data.fileInput, inputClone = input.clone(true);
      // Add a reference for the new cloned file input to the data argument:
      data.fileInputClone = inputClone;
      $('<form></form>').append(inputClone)[0].reset();
      // Detaching allows to insert the fileInput on another form
      // without loosing the file input value:
      input.after(inputClone).detach();
      // Avoid memory leaks with the detached file input:
      $.cleanData(input.unbind('remove'));
      // Replace the original file input element in the fileInput
      // elements set with the clone, which has been copied including
      // event handlers:
      this.options.fileInput = this.options.fileInput.map(function (i, el) {
        if (el === input[0]) {
          return inputClone[0];
        }
        return el;
      });
      // If the widget has been initialized on the file input itself,
      // override this.element with the file input clone:
      if (input[0] === this.element[0]) {
        this.element = inputClone;
      }
    },
    _handleFileTreeEntry: function (entry, path) {
      var that = this, dfd = $.Deferred(), errorHandler = function (e) {
          if (e && !e.entry) {
            e.entry = entry;
          }
          // Since $.when returns immediately if one
          // Deferred is rejected, we use resolve instead.
          // This allows valid files and invalid items
          // to be returned together in one set:
          dfd.resolve([e]);
        }, successHandler = function (entries) {
          that._handleFileTreeEntries(entries, path + entry.name + '/').done(function (files) {
            dfd.resolve(files);
          }).fail(errorHandler);
        }, readEntries = function () {
          dirReader.readEntries(function (results) {
            if (!results.length) {
              successHandler(entries);
            } else {
              entries = entries.concat(results);
              readEntries();
            }
          }, errorHandler);
        }, dirReader, entries = [];
      path = path || '';
      if (entry.isFile) {
        if (entry._file) {
          // Workaround for Chrome bug #149735
          entry._file.relativePath = path;
          dfd.resolve(entry._file);
        } else {
          entry.file(function (file) {
            file.relativePath = path;
            dfd.resolve(file);
          }, errorHandler);
        }
      } else if (entry.isDirectory) {
        dirReader = entry.createReader();
        readEntries();
      } else {
        // Return an empy list for file system items
        // other than files or directories:
        dfd.resolve([]);
      }
      return dfd.promise();
    },
    _handleFileTreeEntries: function (entries, path) {
      var that = this;
      return $.when.apply($, $.map(entries, function (entry) {
        return that._handleFileTreeEntry(entry, path);
      })).pipe(function () {
        return Array.prototype.concat.apply([], arguments);
      });
    },
    _getDroppedFiles: function (dataTransfer) {
      dataTransfer = dataTransfer || {};
      var items = dataTransfer.items;
      if (items && items.length && (items[0].webkitGetAsEntry || items[0].getAsEntry)) {
        return this._handleFileTreeEntries($.map(items, function (item) {
          var entry;
          if (item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
            if (entry) {
              // Workaround for Chrome bug #149735:
              entry._file = item.getAsFile();
            }
            return entry;
          }
          return item.getAsEntry();
        }));
      }
      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();
    },
    _getSingleFileInputFiles: function (fileInput) {
      fileInput = $(fileInput);
      var entries = fileInput.prop('webkitEntries') || fileInput.prop('entries'), files, value;
      if (entries && entries.length) {
        return this._handleFileTreeEntries(entries);
      }
      files = $.makeArray(fileInput.prop('files'));
      if (!files.length) {
        value = fileInput.prop('value');
        if (!value) {
          return $.Deferred().resolve([]).promise();
        }
        // If the files property is not available, the browser does not
        // support the File API and we add a pseudo File object with
        // the input value as name with path information removed:
        files = [{ name: value.replace(/^.*\\/, '') }];
      } else if (files[0].name === undefined && files[0].fileName) {
        // File normalization for Safari 4 and Firefox 3:
        $.each(files, function (index, file) {
          file.name = file.fileName;
          file.size = file.fileSize;
        });
      }
      return $.Deferred().resolve(files).promise();
    },
    _getFileInputFiles: function (fileInput) {
      if (!(fileInput instanceof $) || fileInput.length === 1) {
        return this._getSingleFileInputFiles(fileInput);
      }
      return $.when.apply($, $.map(fileInput, this._getSingleFileInputFiles)).pipe(function () {
        return Array.prototype.concat.apply([], arguments);
      });
    },
    _onChange: function (e) {
      var that = this, data = {
          fileInput: $(e.target),
          form: $(e.target.form)
        };
      this._getFileInputFiles(data.fileInput).always(function (files) {
        data.files = files;
        if (that.options.replaceFileInput) {
          that._replaceFileInput(data);
        }
        if (that._trigger('change', $.Event('change', { delegatedEvent: e }), data) !== false) {
          that._onAdd(e, data);
        }
      });
    },
    _onPaste: function (e) {
      var items = e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.items, data = { files: [] };
      if (items && items.length) {
        $.each(items, function (index, item) {
          var file = item.getAsFile && item.getAsFile();
          if (file) {
            data.files.push(file);
          }
        });
        if (this._trigger('paste', $.Event('paste', { delegatedEvent: e }), data) !== false) {
          this._onAdd(e, data);
        }
      }
    },
    _onDrop: function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var that = this, dataTransfer = e.dataTransfer, data = {};
      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
        e.preventDefault();
        this._getDroppedFiles(dataTransfer).always(function (files) {
          data.files = files;
          if (that._trigger('drop', $.Event('drop', { delegatedEvent: e }), data) !== false) {
            that._onAdd(e, data);
          }
        });
      }
    },
    _onDragOver: getDragHandler('dragover'),
    _onDragEnter: getDragHandler('dragenter'),
    _onDragLeave: getDragHandler('dragleave'),
    _initEventHandlers: function () {
      if (this._isXHRUpload(this.options)) {
        this._on(this.options.dropZone, {
          dragover: this._onDragOver,
          drop: this._onDrop,
          dragenter: this._onDragEnter,
          dragleave: this._onDragLeave
        });
        this._on(this.options.pasteZone, { paste: this._onPaste });
      }
      if ($.support.fileInput) {
        this._on(this.options.fileInput, { change: this._onChange });
      }
    },
    _destroyEventHandlers: function () {
      this._off(this.options.dropZone, 'dragenter dragleave dragover drop');
      this._off(this.options.pasteZone, 'paste');
      this._off(this.options.fileInput, 'change');
    },
    _setOption: function (key, value) {
      var reinit = $.inArray(key, this._specialOptions) !== -1;
      if (reinit) {
        this._destroyEventHandlers();
      }
      this._super(key, value);
      if (reinit) {
        this._initSpecialOptions();
        this._initEventHandlers();
      }
    },
    _initSpecialOptions: function () {
      var options = this.options;
      if (options.fileInput === undefined) {
        options.fileInput = this.element.is('input[type="file"]') ? this.element : this.element.find('input[type="file"]');
      } else if (!(options.fileInput instanceof $)) {
        options.fileInput = $(options.fileInput);
      }
      if (!(options.dropZone instanceof $)) {
        options.dropZone = $(options.dropZone);
      }
      if (!(options.pasteZone instanceof $)) {
        options.pasteZone = $(options.pasteZone);
      }
    },
    _getRegExp: function (str) {
      var parts = str.split('/'), modifiers = parts.pop();
      parts.shift();
      return new RegExp(parts.join('/'), modifiers);
    },
    _isRegExpOption: function (key, value) {
      return key !== 'url' && $.type(value) === 'string' && /^\/.*\/[igm]{0,3}$/.test(value);
    },
    _initDataAttributes: function () {
      var that = this, options = this.options, data = this.element.data();
      // Initialize options set via HTML5 data-attributes:
      $.each(this.element[0].attributes, function (index, attr) {
        var key = attr.name.toLowerCase(), value;
        if (/^data-/.test(key)) {
          // Convert hyphen-ated key to camelCase:
          key = key.slice(5).replace(/-[a-z]/g, function (str) {
            return str.charAt(1).toUpperCase();
          });
          value = data[key];
          if (that._isRegExpOption(key, value)) {
            value = that._getRegExp(value);
          }
          options[key] = value;
        }
      });
    },
    _create: function () {
      this._initDataAttributes();
      this._initSpecialOptions();
      this._slots = [];
      this._sequence = this._getXHRPromise(true);
      this._sending = this._active = 0;
      this._initProgressObject(this);
      this._initEventHandlers();
    },
    active: function () {
      return this._active;
    },
    progress: function () {
      return this._progress;
    },
    add: function (data) {
      var that = this;
      if (!data || this.options.disabled) {
        return;
      }
      if (data.fileInput && !data.files) {
        this._getFileInputFiles(data.fileInput).always(function (files) {
          data.files = files;
          that._onAdd(null, data);
        });
      } else {
        data.files = $.makeArray(data.files);
        this._onAdd(null, data);
      }
    },
    send: function (data) {
      if (data && !this.options.disabled) {
        if (data.fileInput && !data.files) {
          var that = this, dfd = $.Deferred(), promise = dfd.promise(), jqXHR, aborted;
          promise.abort = function () {
            aborted = true;
            if (jqXHR) {
              return jqXHR.abort();
            }
            dfd.reject(null, 'abort', 'abort');
            return promise;
          };
          this._getFileInputFiles(data.fileInput).always(function (files) {
            if (aborted) {
              return;
            }
            if (!files.length) {
              dfd.reject();
              return;
            }
            data.files = files;
            jqXHR = that._onSend(null, data);
            jqXHR.then(function (result, textStatus, jqXHR) {
              dfd.resolve(result, textStatus, jqXHR);
            }, function (jqXHR, textStatus, errorThrown) {
              dfd.reject(jqXHR, textStatus, errorThrown);
            });
          });
          return this._enhancePromise(promise);
        }
        data.files = $.makeArray(data.files);
        if (data.files.length) {
          return this._onSend(null, data);
        }
      }
      return this._getXHRPromise(false, data && data.context);
    }
  });
}));/*!jQuery Knob*/
/**
 * Downward compatible, touchable dial
 *
 * Version: 1.2.11
 * Requires: jQuery v1.7+
 *
 * Copyright (c) 2012 Anthony Terrien
 * Under MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Thanks to vor, eskimoblood, spiffistan, FabrizioC
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function ($) {
  /**
     * Kontrol library
     */
  'use strict';
  /**
     * Definition of globals and core
     */
  var k = {},
    // kontrol
    max = Math.max, min = Math.min;
  k.c = {};
  k.c.d = $(document);
  k.c.t = function (e) {
    return e.originalEvent.touches.length - 1;
  };
  /**
     * Kontrol Object
     *
     * Definition of an abstract UI control
     *
     * Each concrete component must call this one.
     * <code>
     * k.o.call(this);
     * </code>
     */
  k.o = function () {
    var s = this;
    this.o = null;
    // array of options
    this.$ = null;
    // jQuery wrapped element
    this.i = null;
    // mixed HTMLInputElement or array of HTMLInputElement
    this.g = null;
    // deprecated 2D graphics context for 'pre-rendering'
    this.v = null;
    // value ; mixed array or integer
    this.cv = null;
    // change value ; not commited value
    this.x = 0;
    // canvas x position
    this.y = 0;
    // canvas y position
    this.w = 0;
    // canvas width
    this.h = 0;
    // canvas height
    this.$c = null;
    // jQuery canvas element
    this.c = null;
    // rendered canvas context
    this.t = 0;
    // touches index
    this.isInit = false;
    this.fgColor = null;
    // main color
    this.pColor = null;
    // previous color
    this.dH = null;
    // draw hook
    this.cH = null;
    // change hook
    this.eH = null;
    // cancel hook
    this.rH = null;
    // release hook
    this.scale = 1;
    // scale factor
    this.relative = false;
    this.relativeWidth = false;
    this.relativeHeight = false;
    this.$div = null;
    // component div
    this.run = function () {
      var cf = function (e, conf) {
        var k;
        for (k in conf) {
          s.o[k] = conf[k];
        }
        s._carve().init();
        s._configure()._draw();
      };
      if (this.$.data('kontroled'))
        return;
      this.$.data('kontroled', true);
      this.extend();
      this.o = $.extend({
        min: this.$.data('min') !== undefined ? this.$.data('min') : 0,
        max: this.$.data('max') !== undefined ? this.$.data('max') : 100,
        stopper: true,
        readOnly: this.$.data('readonly') || this.$.attr('readonly') === 'readonly',
        cursor: this.$.data('cursor') === true && 30 || this.$.data('cursor') || 0,
        thickness: this.$.data('thickness') && Math.max(Math.min(this.$.data('thickness'), 1), 0.01) || 0.35,
        lineCap: this.$.data('linecap') || 'butt',
        width: this.$.data('width') || 200,
        height: this.$.data('height') || 200,
        displayInput: this.$.data('displayinput') == null || this.$.data('displayinput'),
        displayPrevious: this.$.data('displayprevious'),
        fgColor: this.$.data('fgcolor') || '#87CEEB',
        inputColor: this.$.data('inputcolor'),
        font: this.$.data('font') || 'Arial',
        fontWeight: this.$.data('font-weight') || 'bold',
        inline: false,
        step: this.$.data('step') || 1,
        rotation: this.$.data('rotation'),
        draw: null,
        change: null,
        cancel: null,
        release: null,
        format: function (v) {
          return v;
        },
        parse: function (v) {
          return parseFloat(v);
        }
      }, this.o);
      // finalize options
      this.o.flip = this.o.rotation === 'anticlockwise' || this.o.rotation === 'acw';
      if (!this.o.inputColor) {
        this.o.inputColor = this.o.fgColor;
      }
      // routing value
      if (this.$.is('fieldset')) {
        // fieldset = array of integer
        this.v = {};
        this.i = this.$.find('input');
        this.i.each(function (k) {
          var $this = $(this);
          s.i[k] = $this;
          s.v[k] = s.o.parse($this.val());
          $this.bind('change blur', function () {
            var val = {};
            val[k] = $this.val();
            s.val(s._validate(val));
          });
        });
        this.$.find('legend').remove();
      } else {
        // input = integer
        this.i = this.$;
        this.v = this.o.parse(this.$.val());
        this.v === '' && (this.v = this.o.min);
        this.$.bind('change blur', function () {
          s.val(s._validate(s.o.parse(s.$.val())));
        });
      }
      !this.o.displayInput && this.$.hide();
      // adds needed DOM elements (canvas, div)
      this.$c = $(document.createElement('canvas')).attr({
        width: this.o.width,
        height: this.o.height
      });
      // wraps all elements in a div
      // add to DOM before Canvas init is triggered
      this.$div = $('<div style="' + (this.o.inline ? 'display:inline;' : '') + 'width:' + this.o.width + 'px;height:' + this.o.height + 'px;' + '"></div>');
      this.$.wrap(this.$div).before(this.$c);
      this.$div = this.$.parent();
      if (typeof G_vmlCanvasManager !== 'undefined') {
        G_vmlCanvasManager.initElement(this.$c[0]);
      }
      this.c = this.$c[0].getContext ? this.$c[0].getContext('2d') : null;
      if (!this.c) {
        throw {
          name: 'CanvasNotSupportedException',
          message: 'Canvas not supported. Please use excanvas on IE8.0.',
          toString: function () {
            return this.name + ': ' + this.message;
          }
        };
      }
      // hdpi support
      this.scale = (window.devicePixelRatio || 1) / (this.c.webkitBackingStorePixelRatio || this.c.mozBackingStorePixelRatio || this.c.msBackingStorePixelRatio || this.c.oBackingStorePixelRatio || this.c.backingStorePixelRatio || 1);
      // detects relative width / height
      this.relativeWidth = this.o.width % 1 !== 0 && this.o.width.indexOf('%');
      this.relativeHeight = this.o.height % 1 !== 0 && this.o.height.indexOf('%');
      this.relative = this.relativeWidth || this.relativeHeight;
      // computes size and carves the component
      this._carve();
      // prepares props for transaction
      if (this.v instanceof Object) {
        this.cv = {};
        this.copy(this.v, this.cv);
      } else {
        this.cv = this.v;
      }
      // binds configure event
      this.$.bind('configure', cf).parent().bind('configure', cf);
      // finalize init
      this._listen()._configure()._xy().init();
      this.isInit = true;
      this.$.val(this.o.format(this.v));
      this._draw();
      return this;
    };
    this._carve = function () {
      if (this.relative) {
        var w = this.relativeWidth ? this.$div.parent().width() * parseInt(this.o.width) / 100 : this.$div.parent().width(), h = this.relativeHeight ? this.$div.parent().height() * parseInt(this.o.height) / 100 : this.$div.parent().height();
        // apply relative
        this.w = this.h = Math.min(w, h);
      } else {
        this.w = this.o.width;
        this.h = this.o.height;
      }
      // finalize div
      this.$div.css({
        'width': this.w + 'px',
        'height': this.h + 'px'
      });
      // finalize canvas with computed width
      this.$c.attr({
        width: this.w,
        height: this.h
      });
      // scaling
      if (this.scale !== 1) {
        this.$c[0].width = this.$c[0].width * this.scale;
        this.$c[0].height = this.$c[0].height * this.scale;
        this.$c.width(this.w);
        this.$c.height(this.h);
      }
      return this;
    };
    this._draw = function () {
      // canvas pre-rendering
      var d = true;
      s.g = s.c;
      s.clear();
      s.dH && (d = s.dH());
      d !== false && s.draw();
    };
    this._touch = function (e) {
      var touchMove = function (e) {
        var v = s.xy2val(e.originalEvent.touches[s.t].pageX, e.originalEvent.touches[s.t].pageY);
        if (v == s.cv)
          return;
        if (s.cH && s.cH(v) === false)
          return;
        s.change(s._validate(v));
        s._draw();
      };
      // get touches index
      this.t = k.c.t(e);
      // First touch
      touchMove(e);
      // Touch events listeners
      k.c.d.bind('touchmove.k', touchMove).bind('touchend.k', function () {
        k.c.d.unbind('touchmove.k touchend.k');
        s.val(s.cv);
      });
      return this;
    };
    this._mouse = function (e) {
      var mouseMove = function (e) {
        var v = s.xy2val(e.pageX, e.pageY);
        if (v == s.cv)
          return;
        if (s.cH && s.cH(v) === false)
          return;
        s.change(s._validate(v));
        s._draw();
      };
      // First click
      mouseMove(e);
      // Mouse events listeners
      k.c.d.bind('mousemove.k', mouseMove).bind('keyup.k', function (e) {
        if (e.keyCode === 27) {
          k.c.d.unbind('mouseup.k mousemove.k keyup.k');
          if (s.eH && s.eH() === false)
            return;
          s.cancel();
        }
      }).bind('mouseup.k', function (e) {
        k.c.d.unbind('mousemove.k mouseup.k keyup.k');
        s.val(s.cv);
      });
      return this;
    };
    this._xy = function () {
      var o = this.$c.offset();
      this.x = o.left;
      this.y = o.top;
      return this;
    };
    this._listen = function () {
      if (!this.o.readOnly) {
        this.$c.bind('mousedown', function (e) {
          e.preventDefault();
          s._xy()._mouse(e);
        }).bind('touchstart', function (e) {
          e.preventDefault();
          s._xy()._touch(e);
        });
        this.listen();
      } else {
        this.$.attr('readonly', 'readonly');
      }
      if (this.relative) {
        $(window).resize(function () {
          s._carve().init();
          s._draw();
        });
      }
      return this;
    };
    this._configure = function () {
      // Hooks
      if (this.o.draw)
        this.dH = this.o.draw;
      if (this.o.change)
        this.cH = this.o.change;
      if (this.o.cancel)
        this.eH = this.o.cancel;
      if (this.o.release)
        this.rH = this.o.release;
      if (this.o.displayPrevious) {
        this.pColor = this.h2rgba(this.o.fgColor, '0.4');
        this.fgColor = this.h2rgba(this.o.fgColor, '0.6');
      } else {
        this.fgColor = this.o.fgColor;
      }
      return this;
    };
    this._clear = function () {
      this.$c[0].width = this.$c[0].width;
    };
    this._validate = function (v) {
      var val = ~~((v < 0 ? -0.5 : 0.5) + v / this.o.step) * this.o.step;
      return Math.round(val * 100) / 100;
    };
    // Abstract methods
    this.listen = function () {
    };
    // on start, one time
    this.extend = function () {
    };
    // each time configure triggered
    this.init = function () {
    };
    // each time configure triggered
    this.change = function (v) {
    };
    // on change
    this.val = function (v) {
    };
    // on release
    this.xy2val = function (x, y) {
    };
    //
    this.draw = function () {
    };
    // on change / on release
    this.clear = function () {
      this._clear();
    };
    // Utils
    this.h2rgba = function (h, a) {
      var rgb;
      h = h.substring(1, 7);
      rgb = [
        parseInt(h.substring(0, 2), 16),
        parseInt(h.substring(2, 4), 16),
        parseInt(h.substring(4, 6), 16)
      ];
      return 'rgba(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ',' + a + ')';
    };
    this.copy = function (f, t) {
      for (var i in f) {
        t[i] = f[i];
      }
    };
  };
  /**
     * k.Dial
     */
  k.Dial = function () {
    k.o.call(this);
    this.startAngle = null;
    this.xy = null;
    this.radius = null;
    this.lineWidth = null;
    this.cursorExt = null;
    this.w2 = null;
    this.PI2 = 2 * Math.PI;
    this.extend = function () {
      this.o = $.extend({
        bgColor: this.$.data('bgcolor') || '#EEEEEE',
        angleOffset: this.$.data('angleoffset') || 0,
        angleArc: this.$.data('anglearc') || 360,
        inline: true
      }, this.o);
    };
    this.val = function (v, triggerRelease) {
      if (null != v) {
        // reverse format
        v = this.o.parse(v);
        if (triggerRelease !== false && v != this.v && this.rH && this.rH(v) === false) {
          return;
        }
        this.cv = this.o.stopper ? max(min(v, this.o.max), this.o.min) : v;
        this.v = this.cv;
        this.$.val(this.o.format(this.v));
        this._draw();
      } else {
        return this.v;
      }
    };
    this.xy2val = function (x, y) {
      var a, ret;
      a = Math.atan2(x - (this.x + this.w2), -(y - this.y - this.w2)) - this.angleOffset;
      if (this.o.flip) {
        a = this.angleArc - a - this.PI2;
      }
      if (this.angleArc != this.PI2 && a < 0 && a > -0.5) {
        // if isset angleArc option, set to min if .5 under min
        a = 0;
      } else if (a < 0) {
        a += this.PI2;
      }
      ret = a * (this.o.max - this.o.min) / this.angleArc + this.o.min;
      this.o.stopper && (ret = max(min(ret, this.o.max), this.o.min));
      return ret;
    };
    this.listen = function () {
      // bind MouseWheel
      var s = this, mwTimerStop, mwTimerRelease, mw = function (e) {
          e.preventDefault();
          var ori = e.originalEvent, deltaX = ori.detail || ori.wheelDeltaX, deltaY = ori.detail || ori.wheelDeltaY, v = s._validate(s.o.parse(s.$.val())) + (deltaX > 0 || deltaY > 0 ? s.o.step : deltaX < 0 || deltaY < 0 ? -s.o.step : 0);
          v = max(min(v, s.o.max), s.o.min);
          s.val(v, false);
          if (s.rH) {
            // Handle mousewheel stop
            clearTimeout(mwTimerStop);
            mwTimerStop = setTimeout(function () {
              s.rH(v);
              mwTimerStop = null;
            }, 100);
            // Handle mousewheel releases
            if (!mwTimerRelease) {
              mwTimerRelease = setTimeout(function () {
                if (mwTimerStop)
                  s.rH(v);
                mwTimerRelease = null;
              }, 200);
            }
          }
        }, kval, to, m = 1, kv = {
          37: -s.o.step,
          38: s.o.step,
          39: s.o.step,
          40: -s.o.step
        };
      this.$.bind('keydown', function (e) {
        var kc = e.keyCode;
        // numpad support
        if (kc >= 96 && kc <= 105) {
          kc = e.keyCode = kc - 48;
        }
        kval = parseInt(String.fromCharCode(kc));
        if (isNaN(kval)) {
          kc !== 13 && kc !== 8 && kc !== 9 && kc !== 189 && (kc !== 190 || s.$.val().match(/\./)) && e.preventDefault();
          // arrows
          if ($.inArray(kc, [
              37,
              38,
              39,
              40
            ]) > -1) {
            e.preventDefault();
            var v = s.o.parse(s.$.val()) + kv[kc] * m;
            s.o.stopper && (v = max(min(v, s.o.max), s.o.min));
            s.change(s._validate(v));
            s._draw();
            // long time keydown speed-up
            to = window.setTimeout(function () {
              m *= 2;
            }, 30);
          }
        }
      }).bind('keyup', function (e) {
        if (isNaN(kval)) {
          if (to) {
            window.clearTimeout(to);
            to = null;
            m = 1;
            s.val(s.$.val());
          }
        } else {
          // kval postcond
          s.$.val() > s.o.max && s.$.val(s.o.max) || s.$.val() < s.o.min && s.$.val(s.o.min);
        }
      });
      this.$c.bind('mousewheel DOMMouseScroll', mw);
      this.$.bind('mousewheel DOMMouseScroll', mw);
    };
    this.init = function () {
      if (this.v < this.o.min || this.v > this.o.max) {
        this.v = this.o.min;
      }
      this.$.val(this.v);
      this.w2 = this.w / 2;
      this.cursorExt = this.o.cursor / 100;
      this.xy = this.w2 * this.scale;
      this.lineWidth = this.xy * this.o.thickness;
      this.lineCap = this.o.lineCap;
      this.radius = this.xy - this.lineWidth / 2;
      this.o.angleOffset && (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset);
      this.o.angleArc && (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc);
      // deg to rad
      this.angleOffset = this.o.angleOffset * Math.PI / 180;
      this.angleArc = this.o.angleArc * Math.PI / 180;
      // compute start and end angles
      this.startAngle = 1.5 * Math.PI + this.angleOffset;
      this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc;
      var s = max(String(Math.abs(this.o.max)).length, String(Math.abs(this.o.min)).length, 2) + 2;
      this.o.displayInput && this.i.css({
        'width': (this.w / 2 + 4 >> 0) + 'px',
        'height': (this.w / 3 >> 0) + 'px',
        'position': 'absolute',
        'vertical-align': 'middle',
        'margin-top': (this.w / 3 >> 0) + 'px',
        'margin-left': '-' + (this.w * 3 / 4 + 2 >> 0) + 'px',
        'border': 0,
        'background': 'none',
        'font': this.o.fontWeight + ' ' + (this.w / s >> 0) + 'px ' + this.o.font,
        'text-align': 'center',
        'color': this.o.inputColor || this.o.fgColor,
        'padding': '0px',
        '-webkit-appearance': 'none'
      }) || this.i.css({
        'width': '0px',
        'visibility': 'hidden'
      });
    };
    this.change = function (v) {
      this.cv = v;
      this.$.val(this.o.format(v));
    };
    this.angle = function (v) {
      return (v - this.o.min) * this.angleArc / (this.o.max - this.o.min);
    };
    this.arc = function (v) {
      var sa, ea;
      v = this.angle(v);
      if (this.o.flip) {
        sa = this.endAngle + 0.00001;
        ea = sa - v - 0.00001;
      } else {
        sa = this.startAngle - 0.00001;
        ea = sa + v + 0.00001;
      }
      this.o.cursor && (sa = ea - this.cursorExt) && (ea = ea + this.cursorExt);
      return {
        s: sa,
        e: ea,
        d: this.o.flip && !this.o.cursor
      };
    };
    this.draw = function () {
      var c = this.g,
        // context
        a = this.arc(this.cv),
        // Arc
        pa,
        // Previous arc
        r = 1;
      c.lineWidth = this.lineWidth;
      c.lineCap = this.lineCap;
      if (this.o.bgColor !== 'none') {
        c.beginPath();
        c.strokeStyle = this.o.bgColor;
        c.arc(this.xy, this.xy, this.radius, this.endAngle - 0.00001, this.startAngle + 0.00001, true);
        c.stroke();
      }
      if (this.o.displayPrevious) {
        pa = this.arc(this.v);
        c.beginPath();
        c.strokeStyle = this.pColor;
        c.arc(this.xy, this.xy, this.radius, pa.s, pa.e, pa.d);
        c.stroke();
        r = this.cv == this.v;
      }
      c.beginPath();
      c.strokeStyle = r ? this.o.fgColor : this.fgColor;
      c.arc(this.xy, this.xy, this.radius, a.s, a.e, a.d);
      c.stroke();
    };
    this.cancel = function () {
      this.val(this.v);
    };
  };
  $.fn.dial = $.fn.knob = function (o) {
    return this.each(function () {
      var d = new k.Dial();
      d.o = o;
      d.$ = $(this);
      d.run();
    }).parent();
  };
}));/*!
 * JavaScript Cookie v2.1.4
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;
(function (factory) {
  var registeredInModuleLoader = false;
  if (typeof define === 'function' && define.amd) {
    define(factory);
    registeredInModuleLoader = true;
  }
  if (typeof exports === 'object') {
    module.exports = factory();
    registeredInModuleLoader = true;
  }
  if (!registeredInModuleLoader) {
    var OldCookies = window.Cookies;
    var api = window.Cookies = factory();
    api.noConflict = function () {
      window.Cookies = OldCookies;
      return api;
    };
  }
}(function () {
  function extend() {
    var i = 0;
    var result = {};
    for (; i < arguments.length; i++) {
      var attributes = arguments[i];
      for (var key in attributes) {
        result[key] = attributes[key];
      }
    }
    return result;
  }
  function init(converter) {
    function api(key, value, attributes) {
      var result;
      if (typeof document === 'undefined') {
        return;
      }
      // Write
      if (arguments.length > 1) {
        attributes = extend({ path: '/' }, api.defaults, attributes);
        if (typeof attributes.expires === 'number') {
          var expires = new Date();
          expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 86400000);
          attributes.expires = expires;
        }
        // We're using "expires" because "max-age" is not supported by IE
        attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';
        try {
          result = JSON.stringify(value);
          if (/^[\{\[]/.test(result)) {
            value = result;
          }
        } catch (e) {
        }
        if (!converter.write) {
          value = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
        } else {
          value = converter.write(value, key);
        }
        key = encodeURIComponent(String(key));
        key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
        key = key.replace(/[\(\)]/g, escape);
        var stringifiedAttributes = '';
        for (var attributeName in attributes) {
          if (!attributes[attributeName]) {
            continue;
          }
          stringifiedAttributes += '; ' + attributeName;
          if (attributes[attributeName] === true) {
            continue;
          }
          stringifiedAttributes += '=' + attributes[attributeName];
        }
        return document.cookie = key + '=' + value + stringifiedAttributes;
      }
      // Read
      if (!key) {
        result = {};
      }
      // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all. Also prevents odd result when
      // calling "get()"
      var cookies = document.cookie ? document.cookie.split('; ') : [];
      var rdecode = /(%[0-9A-Z]{2})+/g;
      var i = 0;
      for (; i < cookies.length; i++) {
        var parts = cookies[i].split('=');
        var cookie = parts.slice(1).join('=');
        if (cookie.charAt(0) === '"') {
          cookie = cookie.slice(1, -1);
        }
        try {
          var name = parts[0].replace(rdecode, decodeURIComponent);
          cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);
          if (this.json) {
            try {
              cookie = JSON.parse(cookie);
            } catch (e) {
            }
          }
          if (key === name) {
            result = cookie;
            break;
          }
          if (!key) {
            result[name] = cookie;
          }
        } catch (e) {
        }
      }
      return result;
    }
    api.set = api;
    api.get = function (key) {
      return api.call(api, key);
    };
    api.getJSON = function () {
      return api.apply({ json: true }, [].slice.call(arguments));
    };
    api.defaults = {};
    api.remove = function (key, attributes) {
      api(key, '', extend(attributes, { expires: -1 }));
    };
    api.withConverter = init;
    return api;
  }
  return init(function () {
  });
}));//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function () {
  // Baseline setup
  // --------------
  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;
  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;
  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function () {
  };
  // Create a safe reference to the Underscore object for use below.
  var _ = function (obj) {
    if (obj instanceof _)
      return obj;
    if (!(this instanceof _))
      return new _(obj);
    this._wrapped = obj;
  };
  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  // Current version.
  _.VERSION = '1.8.3';
  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function (func, context, argCount) {
    if (context === void 0)
      return func;
    switch (argCount == null ? 3 : argCount) {
    case 1:
      return function (value) {
        return func.call(context, value);
      };
    case 2:
      return function (value, other) {
        return func.call(context, value, other);
      };
    case 3:
      return function (value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function (accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function () {
      return func.apply(context, arguments);
    };
  };
  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function (value, context, argCount) {
    if (value == null)
      return _.identity;
    if (_.isFunction(value))
      return optimizeCb(value, context, argCount);
    if (_.isObject(value))
      return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function (value, context) {
    return cb(value, context, Infinity);
  };
  // An internal function for creating assigner functions.
  var createAssigner = function (keysFunc, undefinedOnly) {
    return function (obj) {
      var length = arguments.length;
      if (length < 2 || obj == null)
        return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index], keys = keysFunc(source), l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0)
            obj[key] = source[key];
        }
      }
      return obj;
    };
  };
  // An internal function for creating a new object that inherits from another.
  var baseCreate = function (prototype) {
    if (!_.isObject(prototype))
      return {};
    if (nativeCreate)
      return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };
  var property = function (key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  };
  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function (collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };
  // Collection Functions
  // --------------------
  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };
  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };
  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }
    return function (obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }
  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);
  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);
  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function (obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1)
      return obj[key];
  };
  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function (value, index, list) {
      if (predicate(value, index, list))
        results.push(value);
    });
    return results;
  };
  // Return all the elements for which a truth test fails.
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };
  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj))
        return false;
    }
    return true;
  };
  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj))
        return true;
    }
    return false;
  };
  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj))
      obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard)
      fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };
  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };
  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };
  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };
  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };
  // Return the maximum element (or element-based computation).
  _.max = function (obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity, value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };
  // Return the minimum element (or element-based computation).
  _.min = function (obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity, value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };
  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function (obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index)
        shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };
  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj))
        obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };
  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0)
          return 1;
        if (a < b || b === void 0)
          return -1;
      }
      return left.index - right.index;
    }), 'value');
  };
  // An internal function used for aggregate "group by" operations.
  var group = function (behavior) {
    return function (obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };
  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function (result, value, key) {
    if (_.has(result, key))
      result[key].push(value);
    else
      result[key] = [value];
  });
  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function (result, value, key) {
    result[key] = value;
  });
  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function (result, value, key) {
    if (_.has(result, key))
      result[key]++;
    else
      result[key] = 1;
  });
  // Safely create a real, live array from anything iterable.
  _.toArray = function (obj) {
    if (!obj)
      return [];
    if (_.isArray(obj))
      return slice.call(obj);
    if (isArrayLike(obj))
      return _.map(obj, _.identity);
    return _.values(obj);
  };
  // Return the number of elements in an object.
  _.size = function (obj) {
    if (obj == null)
      return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };
  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function (value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [
      pass,
      fail
    ];
  };
  // Array Functions
  // ---------------
  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[0];
    return _.initial(array, array.length - n);
  };
  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };
  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };
  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };
  // Trim out all falsy values from an array.
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };
  // Internal implementation of a recursive `flatten` function.
  var flatten = function (input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow)
          value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };
  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  };
  // Return a version of the array that does not contain the specified value(s).
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };
  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null)
      iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed)
          result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };
  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function () {
    return _.uniq(flatten(arguments, true, true));
  };
  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function (array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item))
        continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item))
          break;
      }
      if (j === argsLength)
        result.push(item);
    }
    return result;
  };
  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function (array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };
  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function () {
    return _.unzip(arguments);
  };
  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function (array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);
    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };
  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function (list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };
  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array))
          return index;
      }
      return -1;
    };
  }
  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);
  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value)
        low = mid + 1;
      else
        high = mid;
    }
    return low;
  };
  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item)
          return idx;
      }
      return -1;
    };
  }
  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);
    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }
    return range;
  };
  // Function (ahem) Functions
  // ------------------
  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc))
      return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result))
      return result;
    return self;
  };
  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function (func, context) {
    if (nativeBind && func.bind === nativeBind)
      return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func))
      throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function () {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };
  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function () {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length)
        args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };
  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function (obj) {
    var i, length = arguments.length, key;
    if (length <= 1)
      throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };
  // Memoize an expensive function by storing its results.
  _.memoize = function (func, hasher) {
    var memoize = function (key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address))
        cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };
  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };
  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);
  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options)
      options = {};
    var later = function () {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout)
        context = args = null;
    };
    return function () {
      var now = _.now();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout)
          context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    var later = function () {
      var last = _.now() - timestamp;
      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout)
            context = args = null;
        }
      }
    };
    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout)
        timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
  };
  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };
  // Returns a negated version of the passed-in predicate.
  _.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  };
  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--)
        result = args[i].call(this, result);
      return result;
    };
  };
  // Returns a function that will only be executed on and after the Nth call.
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1)
        func = null;
      return memo;
    };
  };
  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);
  // Object Functions
  // ----------------
  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = [
      'valueOf',
      'isPrototypeOf',
      'toString',
      'propertyIsEnumerable',
      'hasOwnProperty',
      'toLocaleString'
    ];
  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop))
      keys.push(prop);
    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }
  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function (obj) {
    if (!_.isObject(obj))
      return [];
    if (nativeKeys)
      return nativeKeys(obj);
    var keys = [];
    for (var key in obj)
      if (_.has(obj, key))
        keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug)
      collectNonEnumProps(obj, keys);
    return keys;
  };
  // Retrieve all the property names of an object.
  _.allKeys = function (obj) {
    if (!_.isObject(obj))
      return [];
    var keys = [];
    for (var key in obj)
      keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug)
      collectNonEnumProps(obj, keys);
    return keys;
  };
  // Retrieve the values of an object's properties.
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };
  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };
  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [
        keys[i],
        obj[keys[i]]
      ];
    }
    return pairs;
  };
  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };
  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key]))
        names.push(key);
    }
    return names.sort();
  };
  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);
  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);
  // Returns the first key on an object that passes a predicate test
  _.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj))
        return key;
    }
  };
  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function (object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null)
      return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function (value, key, obj) {
        return key in obj;
      };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj))
        result[key] = value;
    }
    return result;
  };
  // Return a copy of the object without the blacklisted properties.
  _.omit = function (obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function (value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };
  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);
  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props)
      _.extendOwn(result, props);
    return result;
  };
  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function (obj) {
    if (!_.isObject(obj))
      return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };
  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };
  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function (object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null)
      return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj))
        return false;
    }
    return true;
  };
  // Internal recursive comparison function for `isEqual`.
  var eq = function (a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b)
      return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null)
      return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _)
      a = a._wrapped;
    if (b instanceof _)
      b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b))
      return false;
    switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case '[object RegExp]':
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN
      if (+a !== +a)
        return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    }
    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object')
        return false;
      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a)
        return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length)
        return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack))
          return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length)
        return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
          return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };
  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function (a, b) {
    return eq(a, b);
  };
  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function (obj) {
    if (obj == null)
      return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
      return obj.length === 0;
    return _.keys(obj).length === 0;
  };
  // Is a given value a DOM element?
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };
  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  };
  // Is a given variable an object?
  _.isObject = function (obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };
  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp',
    'Error'
  ], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });
  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return _.has(obj, 'callee');
    };
  }
  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  }
  // Is a given object a finite number?
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };
  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj !== +obj;
  };
  // Is a given value a boolean?
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };
  // Is a given value equal to null?
  _.isNull = function (obj) {
    return obj === null;
  };
  // Is a given variable undefined?
  _.isUndefined = function (obj) {
    return obj === void 0;
  };
  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function (obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };
  // Utility Functions
  // -----------------
  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };
  // Keep the identity function around for default iteratees.
  _.identity = function (value) {
    return value;
  };
  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function (value) {
    return function () {
      return value;
    };
  };
  _.noop = function () {
  };
  _.property = property;
  // Generates a function for a given object that returns a given property.
  _.propertyOf = function (obj) {
    return obj == null ? function () {
    } : function (key) {
      return obj[key];
    };
  };
  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
      return _.isMatch(obj, attrs);
    };
  };
  // Run a function **n** times.
  _.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++)
      accum[i] = iteratee(i);
    return accum;
  };
  // Return a random integer between min and max (inclusive).
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };
  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function () {
    return new Date().getTime();
  };
  // List of HTML entities for escaping.
  var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#x27;',
      '`': '&#x60;'
    };
  var unescapeMap = _.invert(escapeMap);
  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function (map) {
    var escaper = function (match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);
  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function (object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };
  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };
  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;
  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
  var escapeChar = function (match) {
    return '\\' + escapes[match];
  };
  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings)
      settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);
    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');
    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = '__p+=\'';
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;
      if (escape) {
        source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
      } else if (interpolate) {
        source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
      } else if (evaluate) {
        source += '\';\n' + evaluate + '\n__p+=\'';
      }
      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += '\';\n';
    // If a variable is not specified, place data values in local scope.
    if (!settings.variable)
      source = 'with(obj||{}){\n' + source + '}\n';
    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    var template = function (data) {
      return render.call(this, data, _);
    };
    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';
    return template;
  };
  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function (obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };
  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  // Helper function to continue chaining intermediate results.
  var result = function (instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };
  // Add your own custom functions to the Underscore object.
  _.mixin = function (obj) {
    _.each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };
  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);
  // Add all mutator Array functions to the wrapper.
  _.each([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0)
        delete obj[0];
      return result(this, obj);
    };
  });
  // Add all accessor Array functions to the wrapper.
  _.each([
    'concat',
    'join',
    'slice'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });
  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function () {
    return this._wrapped;
  };
  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  _.prototype.toString = function () {
    return '' + this._wrapped;
  };
  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function () {
      return _;
    });
  }
}.call(this));'use strict';
/*********************
//
// Various functions
//
*********************/
/*jshint browser: true */
/*globals jQuery */
;
(function (factory) {
  if (typeof exports === 'object') {
    factory(require('jquery'));
  } else if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else {
    factory(jQuery);
  }
}(function ($) {
  /**
     * Triggers the DOM changed event on the given element
     *
     * @private
     * @param   {Object}    element     the jQuery element that has been modified
     * @param   {String}    type        jQuery method used to trigger manipulation
     */
  function jQueryDOMChanged(element, type) {
    return $(element).trigger('DOMChanged', type);
  }
  /**
     * Wraps a given jQuery method and injects another function to be called
     *
     * @private
     * @param   {String}    method
     * @param   {Function}  caller
     */
  function jQueryHook(method, caller) {
    var definition = $.fn[method];
    if (definition) {
      $.fn[method] = function () {
        var args = Array.prototype.slice.apply(arguments);
        var result = definition.apply(this, args);
        caller.apply(this, args);
        return result;
      };
    }
  }
  jQueryHook('prepend', function () {
    return jQueryDOMChanged(this, 'prepend');
  });
  jQueryHook('append', function () {
    return jQueryDOMChanged(this, 'append');
  });
  jQueryHook('before', function () {
    return jQueryDOMChanged($(this).parent(), 'before');
  });
  jQueryHook('after', function () {
    return jQueryDOMChanged($(this).parent(), 'after');
  });
  jQueryHook('html', function (value) {
    // Internally jQuery will set strings using innerHTML
    // otherwise will use append to insert new elements
    // Only trigger on string types to avoid doubled events
    if (typeof value === 'string') {
      return jQueryDOMChanged(this, 'html');
    }
  });
}));/*!
 * Author: Abdullah A Almsaeed
 * Date: 4 Jan 2014
 * Description:
 *      This file should be included in all pages
 !**/
/*
 * Global variables. If you change any of these vars, don't forget 
 * to change the values in the less files!
 */
var left_side_width = 220;
//Sidebar width in pixels
$(function () {
  'use strict';
  //Enable sidebar toggle
  $('[data-toggle=\'offcanvas\']').click(function (e) {
    e.preventDefault();
    var sidebarl = $('.sidebar').offset().left;
    //If window is small enough, enable sidebar push menu
    if ($(window).width() <= 992) {
      if (sidebarl === 0)
        $('.sidebar').css('left', '-220px');
      else
        $('.sidebar').css('left', '0px');
      $('.row-offcanvas').toggleClass('active');
      $('.left-side').removeClass('collapse-left');
      $('.right-side').removeClass('strech');
      $('.row-offcanvas').toggleClass('relative');
    } else {
      //Else, enable content streching
      $('.left-side').toggleClass('collapse-left');
      $('.right-side').toggleClass('strech');
    }
  });
  //Add hover support for touch devices
  $('.btn').bind('touchstart', function () {
    $(this).addClass('hover');
  }).bind('touchend', function () {
    $(this).removeClass('hover');
  });
  //Activate tooltips
  $('[data-toggle=\'tooltip\']').tooltip();
  /*     
     * Add collapse and remove events to boxes
     */
  $('[data-widget=\'collapse\']').click(function () {
    //Find the box parent        
    var box = $(this).parents('.box').first();
    //Find the body and the footer
    var bf = box.find('.box-body, .box-footer');
    if (!box.hasClass('collapsed-box')) {
      box.addClass('collapsed-box');
      bf.slideUp();
      $.ajax({
        url: _baseUrl + '/app/api?command=box_status&status=0&id=' + box.attr('id'),
        dataType: 'json'
      });
    } else {
      box.removeClass('collapsed-box');
      bf.slideDown();
      $.ajax({
        url: _baseUrl + '/app/api?command=box_status&status=1&id=' + box.attr('id'),
        dataType: 'json'
      });
    }
  });
  $('.box').each(function () {
    var box = $(this);
    //Find the body and the footer
    var bf = box.find('.box-body, .box-footer');
    if (box.hasClass('collapsed-box')) {
      bf.slideUp();
    }
  });
  /*
     * ADD SLIMSCROLL TO THE TOP NAV DROPDOWNS
     * ---------------------------------------
     */
  $('.navbar .menu').slimscroll({
    height: '200px',
    alwaysVisible: false,
    size: '3px'
  }).css('width', '100%');
  $('.sidebar').slimscroll({
    height: '100%',
    alwaysVisible: false,
    size: '3px'
  }).css('width', '220px');
  /*
     * INITIALIZE BUTTON TOGGLE
     * ------------------------
     */
  $('.btn-group[data-toggle="btn-toggle"]').each(function () {
    var group = $(this);
    $(this).find('.btn').click(function (e) {
      group.find('.btn.active').removeClass('active');
      $(this).addClass('active');
      e.preventDefault();
    });
  });
  $('[data-widget=\'remove\']').click(function () {
    //Find the box parent        
    var box = $(this).parents('.box').first();
    box.slideUp();
  });
  /* Sidebar tree view */
  $('.sidebar .treeview').tree();
  /* 
     * Make sure that the sidebar is streched full height
     * ---------------------------------------------
     * We are gonna assign a min-height value every time the
     * wrapper gets resized and upon page load. We will use
     * Ben Alman's method for detecting the resize event.
     * 
     **/
  function _fix() {
    //Get window height and the wrapper height
    var height = $(window).height() - $('body > .header').height();
    $('.wrapper').css('min-height', height + 'px');
    var content = $('.wrapper').height();
    //If the wrapper height is greater than the window
    if (content > height)
      //then set sidebar height to the wrapper
      $('.left-side, html, body').css('min-height', content + 'px');
    else {
      //Otherwise, set the sidebar to the height of the window
      $('.left-side, html, body').css('min-height', height + 'px');
    }
  }
  //Fire upon load
  _fix();
  //Fire when wrapper is resized
  $('.wrapper').resize(function () {
    _fix();
    fix_sidebar();
  });
  //Fix the fixed layout sidebar scroll bug
  fix_sidebar();
  /*
     * We are gonna initialize all checkbox and radio inputs to 
     * iCheck plugin in.
     * You can find the documentation at http://fronteed.com/iCheck/
     */
  $('input[type=\'checkbox\']').bootstrapSwitch({
    size: 'small',
    onColor: 'success'
  });
  $('input[type=\'radio\']').iCheck({ radioClass: 'iradio_minimal' });
});
function fix_sidebar() {
  //Make sure the body tag has the .fixed class
  if (!$('body').hasClass('fixed')) {
    return;
  }
  //Add slimscroll
  $('.sidebar').slimscroll({
    height: $(window).height() - $('.header').height() + 'px',
    color: 'rgba(0,0,0,0.2)'
  });
}
function change_layout() {
  $('body').toggleClass('fixed');
  fix_sidebar();
}
function change_skin(cls) {
  $('body').removeClass('skin-blue skin-black');
  $('body').addClass(cls);
}
/* 
 * BOX REFRESH BUTTON 
 * ------------------
 * This is a custom plugin to use with the compenet BOX. It allows you to add
 * a refresh button to the box. It converts the box's state to a loading state.
 * 
 * USAGE:
 *  $("#box-widget").boxRefresh( options );
 * */
(function ($) {
  'use strict';
  $.fn.boxRefresh = function (options) {
    // Render options
    var settings = $.extend({
        trigger: '.refresh-btn',
        source: '',
        onLoadStart: function (box) {
        },
        onLoadDone: function (box) {
        }  //When the source has been loaded
      }, options);
    //The overlay
    var overlay = $('<div class="overlay"></div><div class="loading-img"></div>');
    return this.each(function () {
      //if a source is specified
      if (settings.source === '') {
        if (console) {
          console.log('Please specify a source first - boxRefresh()');
        }
        return;
      }
      //the box
      var box = $(this);
      //the button
      var rBtn = box.find(settings.trigger).first();
      //On trigger click
      rBtn.click(function (e) {
        e.preventDefault();
        //Add loading overlay
        start(box);
        //Perform ajax call
        box.find('.box-body').load(settings.source, function () {
          done(box);
        });
      });
    });
    function start(box) {
      //Add overlay and loading img
      box.append(overlay);
      settings.onLoadStart.call(box);
    }
    function done(box) {
      //Remove overlay and loading img
      box.find(overlay).remove();
      settings.onLoadDone.call(box);
    }
  };
}(jQuery));
/*
 * SIDEBAR MENU
 * ------------
 * This is a custom plugin for the sidebar menu. It provides a tree view.
 * 
 * Usage:
 * $(".sidebar).tree();
 * 
 * Note: This plugin does not accept any options. Instead, it only requires a class
 *       added to the element that contains a sub-menu.
 *       
 * When used with the sidebar, for example, it would look something like this:
 * <ul class='sidebar-menu'>
 *      <li class="treeview active">
 *          <a href="#>Menu</a>
 *          <ul class='treeview-menu'>
 *              <li class='active'><a href=#>Level 1</a></li>
 *          </ul>
 *      </li>
 * </ul>
 * 
 * Add .active class to <li> elements if you want the menu to be open automatically
 * on page load. See above for an example.
 */
(function ($) {
  'use strict';
  $.fn.tree = function () {
    return this.each(function () {
      var btn = $(this).children('a').first();
      var menu = $(this).children('.treeview-menu').first();
      var isActive = $(this).hasClass('active');
      //initialize already active menus
      if (isActive) {
        menu.show();
        btn.children('.fa-angle-left').first().removeClass('fa-angle-left').addClass('fa-angle-down');
      }
      //Slide open or close the menu on link click
      btn.click(function (e) {
        e.preventDefault();
        if (isActive) {
          //Slide up to close menu
          menu.slideUp();
          isActive = false;
          btn.children('.fa-angle-down').first().removeClass('fa-angle-down').addClass('fa-angle-left');  //btn.parent("li").removeClass("active");
        } else {
          //Slide down to open menu
          menu.slideDown();
          isActive = true;
          btn.children('.fa-angle-left').first().removeClass('fa-angle-left').addClass('fa-angle-down');  //btn.parent("li").addClass("active");
        }
      });
      /* Add margins to submenu elements to give it a tree look */
      menu.find('li > a').each(function () {
        var pad = parseInt($(this).css('margin-left')) + 10;
        $(this).css({ 'margin-left': pad + 'px' });
      });
    });
  };
}(jQuery));
/*
 * TODO LIST CUSTOM PLUGIN
 * -----------------------
 * This plugin depends on iCheck plugin for checkbox and radio inputs
 */
(function ($) {
  'use strict';
  $.fn.todolist = function (options) {
    // Render options
    var settings = $.extend({
        onCheck: function (ele) {
        },
        onUncheck: function (ele) {
        }
      }, options);
    return this.each(function () {
      $('input', this).on('ifChecked', function (event) {
        var ele = $(this).parents('li').first();
        ele.toggleClass('done');
        settings.onCheck.call(ele);
      });
      $('input', this).on('ifUnchecked', function (event) {
        var ele = $(this).parents('li').first();
        ele.toggleClass('done');
        settings.onUncheck.call(ele);
      });
    });
  };
}(jQuery));
/* CENTER ELEMENTS */
(function ($) {
  'use strict';
  jQuery.fn.center = function (parent) {
    if (parent) {
      parent = this.parent();
    } else {
      parent = window;
    }
    this.css({
      'position': 'absolute',
      'top': ($(parent).height() - this.outerHeight()) / 2 + $(parent).scrollTop() + 'px',
      'left': ($(parent).width() - this.outerWidth()) / 2 + $(parent).scrollLeft() + 'px'
    });
    return this;
  };
}(jQuery));
/*
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function ($, h, c) {
  var a = $([]), e = $.resize = $.extend($.resize, {}), i, k = 'setTimeout', j = 'resize', d = j + '-special-event', b = 'delay', f = 'throttleWindow';
  e[b] = 250;
  e[f] = true;
  $.event.special[j] = {
    setup: function () {
      if (!e[f] && this[k]) {
        return false;
      }
      var l = $(this);
      a = a.add(l);
      $.data(this, d, {
        w: l.width(),
        h: l.height()
      });
      if (a.length === 1) {
        g();
      }
    },
    teardown: function () {
      if (!e[f] && this[k]) {
        return false;
      }
      var l = $(this);
      a = a.not(l);
      l.removeData(d);
      if (!a.length) {
        clearTimeout(i);
      }
    },
    add: function (l) {
      if (!e[f] && this[k]) {
        return false;
      }
      var n;
      function m(s, o, p) {
        var q = $(this), r = $.data(this, d);
        r.w = o !== c ? o : q.width();
        r.h = p !== c ? p : q.height();
        n.apply(this, arguments);
      }
      if ($.isFunction(l)) {
        n = l;
        return m;
      } else {
        n = l.handler;
        l.handler = m;
      }
    }
  };
  function g() {
    i = h[k](function () {
      a.each(function () {
        var n = $(this), m = n.width(), l = n.height(), o = $.data(this, d);
        if (m !== o.w || l !== o.h) {
          n.trigger(j, [
            o.w = m,
            o.h = l
          ]);
        }
      });
      g();
    }, e[b]);
  }
}(jQuery, this));
/*! iCheck v1.0.1 by Damir Sultanov, http://git.io/arlzeA, MIT Licensed */
(function (h) {
  function F(a, b, d) {
    var c = a[0], e = /er/.test(d) ? m : /bl/.test(d) ? s : l, f = d == H ? {
        checked: c[l],
        disabled: c[s],
        indeterminate: 'true' == a.attr(m) || 'false' == a.attr(w)
      } : c[e];
    if (/^(ch|di|in)/.test(d) && !f)
      D(a, e);
    else if (/^(un|en|de)/.test(d) && f)
      t(a, e);
    else if (d == H)
      for (e in f)
        f[e] ? D(a, e, !0) : t(a, e, !0);
    else if (!b || 'toggle' == d) {
      if (!b)
        a[p]('ifClicked');
      f ? c[n] !== u && t(a, e) : D(a, e);
    }
  }
  function D(a, b, d) {
    var c = a[0], e = a.parent(), f = b == l, A = b == m, B = b == s, K = A ? w : f ? E : 'enabled', p = k(a, K + x(c[n])), N = k(a, b + x(c[n]));
    if (!0 !== c[b]) {
      if (!d && b == l && c[n] == u && c.name) {
        var C = a.closest('form'), r = 'input[name="' + c.name + '"]', r = C.length ? C.find(r) : h(r);
        r.each(function () {
          this !== c && h(this).data(q) && t(h(this), b);
        });
      }
      A ? (c[b] = !0, c[l] && t(a, l, 'force')) : (d || (c[b] = !0), f && c[m] && t(a, m, !1));
      L(a, f, b, d);
    }
    c[s] && k(a, y, !0) && e.find('.' + I).css(y, 'default');
    e[v](N || k(a, b) || '');
    B ? e.attr('aria-disabled', 'true') : e.attr('aria-checked', A ? 'mixed' : 'true');
    e[z](p || k(a, K) || '');
  }
  function t(a, b, d) {
    var c = a[0], e = a.parent(), f = b == l, h = b == m, q = b == s, p = h ? w : f ? E : 'enabled', t = k(a, p + x(c[n])), u = k(a, b + x(c[n]));
    if (!1 !== c[b]) {
      if (h || !d || 'force' == d)
        c[b] = !1;
      L(a, f, p, d);
    }
    !c[s] && k(a, y, !0) && e.find('.' + I).css(y, 'pointer');
    e[z](u || k(a, b) || '');
    q ? e.attr('aria-disabled', 'false') : e.attr('aria-checked', 'false');
    e[v](t || k(a, p) || '');
  }
  function M(a, b) {
    if (a.data(q)) {
      a.parent().html(a.attr('style', a.data(q).s || ''));
      if (b)
        a[p](b);
      a.off('.i').unwrap();
      h(G + '[for="' + a[0].id + '"]').add(a.closest(G)).off('.i');
    }
  }
  function k(a, b, d) {
    if (a.data(q))
      return a.data(q).o[b + (d ? '' : 'Class')];
  }
  function x(a) {
    return a.charAt(0).toUpperCase() + a.slice(1);
  }
  function L(a, b, d, c) {
    if (!c) {
      if (b)
        a[p]('ifToggled');
      a[p]('ifChanged')[p]('if' + x(d));
    }
  }
  var q = 'iCheck', I = q + '-helper', u = 'radio', l = 'checked', E = 'un' + l, s = 'disabled', w = 'determinate', m = 'in' + w, H = 'update', n = 'type', v = 'addClass', z = 'removeClass', p = 'trigger', G = 'label', y = 'cursor', J = /ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);
  h.fn[q] = function (a, b) {
    var d = 'input[type="checkbox"], input[type="' + u + '"]', c = h(), e = function (a) {
        a.each(function () {
          var a = h(this);
          c = a.is(d) ? c.add(a) : c.add(a.find(d));
        });
      };
    if (/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(a))
      return a = a.toLowerCase(), e(this), c.each(function () {
        var c = h(this);
        'destroy' == a ? M(c, 'ifDestroyed') : F(c, !0, a);
        h.isFunction(b) && b();
      });
    if ('object' != typeof a && a)
      return this;
    var f = h.extend({
        checkedClass: l,
        disabledClass: s,
        indeterminateClass: m,
        labelHover: !0,
        aria: !1
      }, a), k = f.handle, B = f.hoverClass || 'hover', x = f.focusClass || 'focus', w = f.activeClass || 'active', y = !!f.labelHover, C = f.labelHoverClass || 'hover', r = ('' + f.increaseArea).replace('%', '') | 0;
    if ('checkbox' == k || k == u)
      d = 'input[type="' + k + '"]';
    -50 > r && (r = -50);
    e(this);
    return c.each(function () {
      var a = h(this);
      M(a);
      var c = this, b = c.id, e = -r + '%', d = 100 + 2 * r + '%', d = {
          position: 'absolute',
          top: e,
          left: e,
          display: 'block',
          width: d,
          height: d,
          margin: 0,
          padding: 0,
          background: '#fff',
          border: 0,
          opacity: 0
        }, e = J ? {
          position: 'absolute',
          visibility: 'hidden'
        } : r ? d : {
          position: 'absolute',
          opacity: 0
        }, k = 'checkbox' == c[n] ? f.checkboxClass || 'icheckbox' : f.radioClass || 'i' + u, m = h(G + '[for="' + b + '"]').add(a.closest(G)), A = !!f.aria, E = q + '-' + Math.random().toString(36).replace('0.', ''), g = '<div class="' + k + '" ' + (A ? 'role="' + c[n] + '" ' : '');
      m.length && A && m.each(function () {
        g += 'aria-labelledby="';
        this.id ? g += this.id : (this.id = E, g += E);
        g += '"';
      });
      g = a.wrap(g + '/>')[p]('ifCreated').parent().append(f.insert);
      d = h('<ins class="' + I + '"/>').css(d).appendTo(g);
      a.data(q, {
        o: f,
        s: a.attr('style')
      }).css(e);
      f.inheritClass && g[v](c.className || '');
      f.inheritID && b && g.attr('id', q + '-' + b);
      'static' == g.css('position') && g.css('position', 'relative');
      F(a, !0, H);
      if (m.length)
        m.on('click.i mouseover.i mouseout.i touchbegin.i touchend.i', function (b) {
          var d = b[n], e = h(this);
          if (!c[s]) {
            if ('click' == d) {
              if (h(b.target).is('a'))
                return;
              F(a, !1, !0);
            } else
              y && (/ut|nd/.test(d) ? (g[z](B), e[z](C)) : (g[v](B), e[v](C)));
            if (J)
              b.stopPropagation();
            else
              return !1;
          }
        });
      a.on('click.i focus.i blur.i keyup.i keydown.i keypress.i', function (b) {
        var d = b[n];
        b = b.keyCode;
        if ('click' == d)
          return !1;
        if ('keydown' == d && 32 == b)
          return c[n] == u && c[l] || (c[l] ? t(a, l) : D(a, l)), !1;
        if ('keyup' == d && c[n] == u)
          !c[l] && D(a, l);
        else if (/us|ur/.test(d))
          g['blur' == d ? z : v](x);
      });
      d.on('click mousedown mouseup mouseover mouseout touchbegin.i touchend.i', function (b) {
        var d = b[n], e = /wn|up/.test(d) ? w : B;
        if (!c[s]) {
          if ('click' == d)
            F(a, !1, !0);
          else {
            if (/wn|er|in/.test(d))
              g[v](e);
            else
              g[z](e + ' ' + w);
            if (m.length && y && e == B)
              m[/ut|nd/.test(d) ? z : v](C);
          }
          if (J)
            b.stopPropagation();
          else
            return !1;
        }
      });
    });
  };
}(window.jQuery || window.Zepto));'use strict';
var _baseUrl = window._baseUrl;
function loadScript(url, callback) {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  if (script.readyState) {
    //IE
    script.onreadystatechange = function () {
      if (script.readyState === 'loaded' || script.readyState === 'complete') {
        script.onreadystatechange = null;
        callback();
      }
    };
  } else {
    //Others
    script.onload = function () {
      callback();
    };
  }
  script.src = url;
  document.getElementsByTagName('head')[0].appendChild(script);
}
function convertHashrate(hash) {
  if (!hash)
    return;
  hash = parseInt(hash);
  if (hash > 900000000000)
    return (hash / 1000000000000).toFixed(2) + 'Ph/s';
  if (hash > 900000000)
    return (hash / 1000000000).toFixed(2) + 'Th/s';
  else if (hash > 900000)
    return (hash / 1000000).toFixed(2) + 'Gh/s';
  else if (hash > 900)
    return (hash / 1000).toFixed(2) + 'Mh/s';
  else
    return hash.toFixed(0) + 'Kh/s';
}
function convertMS(ms) {
  var d, h, m, s;
  s = Math.floor(ms / 1000);
  m = Math.floor(s / 60);
  s = s % 60;
  h = Math.floor(m / 60);
  m = m % 60;
  d = Math.floor(h / 24);
  h = h % 24;
  return {
    d: d,
    h: h,
    m: m,
    s: s
  };
}
function getExaColor(color) {
  if (color === 'green')
    return '#00a65a';
  else if (color === 'yellow')
    return '#f39c12';
  else if (color === 'red')
    return '#f56954';
  else
    return '#999';
}
function callUpdate() {
  //$('.center').append('<div class="form-box" style="width:90%"><div class="header" id="msglog-box" style="font-size:16px;"></div></div>');
  $.ajax({
    url: _baseUrl + '/app/api?command=update_minera',
    dataType: 'json',
    success: function (data) {
      if (data) {
        console.log(data);  //$('#msglog-box').html('<p>'+data+'</p>');
      }
    }
  });
}
function timer(counter) {
  var count = counter ? counter - 1 : $('body').data('count') - 1;
  if (count < 0) {
    clearInterval(counter);
    //counter ended, do something here
    return;
  }
  if (count === 0) {
    $('.lockscreen-name').hide();
    $('#time').html($('body').data('count-message'));
    $('body').data('count', 0);
    return true;
  } else
    $('#time').html(count);
  setTimeout(function () {
    timer(count);
  }, 1000);
}
function saveSettings(hide, saveonly) {
  if (saveonly === false) {
    $('#modal-saving-label').html('Saving data, please wait...');
    $('#modal-saving').modal('show');
  }
  var saveUrl = _baseUrl + '/app/save_settings';
  var formData = $('#minersettings').serialize();
  $.ajax({
    type: 'POST',
    url: saveUrl,
    data: formData,
    cache: false,
    success: function (resp) {
      if (hide && !saveonly) {
        $('#modal-saving').modal('hide');
        window.location.reload();
      }
    }
  });
}
function changeDonationWorth(profitability, value) {
  var amount = profitability / 24 / 60 * value, string = value > 0 ? 'about' : 'exactly', h = 0, new_value = 0, period = 0;
  if (value >= 60) {
    h = Math.floor(value / 60);
    new_value = value % 60;
    period = h + ' hour(s) ' + (new_value > 0 ? ' and ' + new_value + ' minute(s)' : '');
  } else {
    period = value + ' minutes';
  }
  $('.donation-worth').html('<small>Mining for ' + period + ' in a day your donation per MH/s worths ' + string + ':</small> <span class="label label-success"><i class="fa fa-btc"></i>&nbsp;' + amount.toFixed(8) + '</span>');
  if (value > 0 && value < 90) {
    $('.donation-mood').html('<i class="fa fa-smile-o"></i> Your support is much appreciate. Thank you!').removeClass().addClass('donation-mood badge bg-blue');
  } else if (value >= 90 && value < 180) {
    $('.donation-mood').html('<i class="fa fa-sun-o"></i> WOW that\'s really cool! Thank you!').removeClass().addClass('donation-mood badge bg-green');
  } else if (value >= 180 && value < 270) {
    $('.donation-mood').html('<i class="fa fa-star"></i> That\'s amazing! You are a star! Thank you!').removeClass().addClass('donation-mood badge bg-yellow');
  } else if (value >= 270 && value <= 360) {
    $('.donation-mood').html('<i class="fa fa-heart"></i> You are my hero! You really rock! Thank you so much!').removeClass().addClass('donation-mood badge bg-red');
  } else {
    $('.donation-mood').html('<i class="fa fa-frown-o"></i> Time donation is disabled').removeClass().addClass('donation-mood badge');
  }
}
// Show or Hide the options related to the selected miner software
function showHideMinerOptions(change) {
  var sel = $('#minerd-software option:selected').text().match(/\[Custom Miner\]/);
  if ($('#minerd-software').val() !== 'cpuminer' && sel === null) {
    $('.options-selection').show();
    $('.legend-option-autodetect').html('(--scan=all)');
    $('.legend-option-log').html('(--log-file)');
    $('#minerd-autotune').hide();
    $('input[name="minerd_autotune"]').prop('disabled', true);
    $('#minerd-startfreq').hide();
    $('input[name="minerd_startfreq"]').prop('disabled', true);
    $('#minerd-scrypt').show();
    $('#minerd-api-allow').show();
    $('input[name="minerd_scrypt"]').prop('disabled', false);
  } else if (sel !== null) {
    $('.options-selection').hide();
    $('.guided-options').fadeOut();
    $('.manual-options').fadeIn();
    $('.btn-manual-options').addClass('disabled');
    $('.btn-guided-options').removeClass('disabled');
    $('#manual_options').val(1);
    $('#guided_options').val(0);
  } else {
    $('.options-selection').show();
    $('.legend-option-autodetect').html('(--gc3355-detect)');
    $('.legend-option-log').html('(--log)');
    $('#minerd-log').show();
    $('input[name="minerd_log"]').prop('disabled', false);
    $('#minerd-autotune').show();
    $('input[name="minerd_autotune"]').prop('disabled', false);
    $('#minerd-startfreq').show();
    $('input[name="minerd_startfreq"]').prop('disabled', false);
    $('#minerd-scrypt').hide();
    $('#minerd-api-allow').hide();
    $('input[name="minerd_scrypt"]').prop('disabled', true);
  }
  $('.detail-minerdsoftware').remove();
  $('.note-minerdsoftware').remove();
  if (change) {
    if ($('#minerd-software').val() === 'cpuminer') {
      $('.group-minerdsoftware').append('<h6 class="detail-minerdsoftware"><a href="https://github.com/siklon/cpuminer-gc3355" target="_blank"><small class="badge bg-red">CPUminer-GC3355</small></a> is a fork of Cpuminer and is the best software for gridseed devices like Minis and Blades. It is fully optimised and supports autotune, autodetection, frequency and it\'s really stable. <a href="https://github.com/siklon/cpuminer-gc3355" target="_blank">More info</a>.</h6>');
    } else if ($('#minerd-software').val() === 'bfgminer') {
      $('.group-minerdsoftware').append('<h6 class="detail-minerdsoftware"><a href="https://github.com/luke-jr/bfgminer" target="_blank"><small class="badge bg-red">BFGminer</small></a> has a really large amount of devices supported, it has also a lot of features you can use to get the best from your devices. It\'s a stable software. <a href="https://github.com/luke-jr/bfgminer" target="_blank">More info</a>.</h6>');
    } else if ($('#minerd-software').val() === 'cgminer') {
      $('.group-minerdsoftware').append('<h6 class="detail-minerdsoftware"><a href="https://github.com/ckolivas/cgminer" target="_blank"><small class="badge bg-red">CGminer</small></a> is similar to bfgminer, supports a large amount of devices but probably is less updated than bfg. It\'s a stable software. <a href="https://github.com/ckolivas/cgminer" target="_blank">More info</a>.</h6>');
    } else if ($('#minerd-software').val() === 'cgdmaxlzeus') {
      $('.group-minerdsoftware').append('<h6 class="detail-minerdsoftware"><a href="https://github.com/dmaxl/cgminer/" target="_blank"><small class="badge bg-red">CGminer Dmaxl Zeus</small></a> is a Cgminer 4.3.5 fork with GridSeed and Zeus scrypt ASIC support, it has some issues with Minera. Stability is unknown. <a href="https://github.com/dmaxl/cgminer/" target="_blank">More info</a>.</h6>');
    } else {
      $('.group-minerdsoftware').append('<h6 class="detail-minerdsoftware"><small class="badge bg-red">Custom Miner</small> is a miner you uploaded, it\'s up to you, but it\'s recommended to use "manual" options below, cause Minera can\'t know the "guided" options for your custom miner.</h6>');
    }
    $('.group-minerdsoftware').append('<h5 class="note-minerdsoftware"><strong>NOTE:</strong> <i>remember to review your settings below if you change the miner software because they haven\'t the same config options and the miner process could not start.</i></5>');
  }
}
function createChart(period, text_period) {
  function redrawGraphs() {
    areaHash.redraw();
    areaRej.redraw();
    return false;
  }
  function updateGraphs(data) {
    areaHash.setData(data);
    areaRej.setData(data);
    return false;
  }
  /* Morris.js Charts */
  // get Json data from stored_stats url (redis) and create the graphs
  $.getJSON(_baseUrl + '/app/api?command=history_stats&type=' + period, function (data) {
    var refresh = false, areaHash = {}, areaRej = {}, dataChart = Object.keys(data).map(function (key) {
        data[key].timestamp = data[key].timestamp * 1000;
        data[key].hashrate = (data[key].hashrate / 1000 / 1000).toFixed(2);
        data[key].pool_hashrate = (data[key].pool_hashrate / 1000 / 1000).toFixed(2);
        return data[key];
      });
    if (dataChart.length > 0) {
      if (refresh === false) {
        // Hashrate history graph
        areaHash = new Morris.Area({
          element: 'hashrate-chart-' + period,
          resize: true,
          data: dataChart,
          xkey: 'timestamp',
          ykeys: [
            'hashrate',
            'pool_hashrate'
          ],
          ymax: 'auto',
          postUnits: 'Mh/s',
          labels: [
            'Devices',
            'Pool'
          ],
          lineColors: [
            '#3c8dbc',
            '#00c0ef'
          ],
          lineWidth: 2,
          pointSize: 3,
          hideHover: 'auto',
          behaveLikeLine: true
        });
        // Rejected/Errors graph
        areaRej = new Morris.Area({
          element: 'rehw-chart-' + period,
          resize: true,
          data: dataChart,
          xkey: 'timestamp',
          ykeys: [
            'accepted',
            'rejected',
            'errors'
          ],
          ymax: 'auto',
          labels: [
            'Accepted',
            'Rejected',
            'Errors'
          ],
          lineColors: [
            '#00a65a',
            '#f39c12',
            '#f56954'
          ],
          lineWidth: 2,
          pointSize: 3,
          hideHover: 'auto',
          behaveLikeLine: true
        });
      } else {
        updateGraphs(dataChart);
      }
      $(window).resize(function () {
        redrawGraphs();
      });
      $('.sidebar-toggle').click(function () {
        redrawGraphs();
      });
    } else {
      $('#hashrate-chart-' + period).css({
        'height': '100%',
        'overflow': 'visible',
        'margin-top': '20px'
      }).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><b>Ops!</b> <small>No data collected, wait at least ' + text_period + ' to see the chart.</small></div>');
      $('#rehw-chart-' + period).css({
        'height': '100%',
        'overflow': 'visible',
        'margin-top': '20px'
      }).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><b>Ops!</b> <small>No data collected, wait at least ' + text_period + ' to see the chart.</small></div>');
    }
    $('.overlay').hide();
    $('.loading-img').hide();
  });
}
//End get stored stats
function createMon(key, hash, totalhash, maxHashrate, ac, re, hw, sh, freq, color) {
  var col, toAppend, size, skin, thickness, fontsize, name, max;
  if (key === 'total') {
    col = 12;
    toAppend = '#devs-total';
    color = '#f56954';
    size = 140;
    skin = 'tron';
    thickness = '.2';
    fontsize = '10pt';
  } else {
    col = 4;
    toAppend = '#devs';
    color = getExaColor(color);
    size = 80;
    skin = 'basic';
    thickness = '.2';
    fontsize = '8pt';
  }
  if (freq)
    name = key + ' @ ' + freq + 'Mhz';
  else
    name = key;
  // Add per device knob graph
  var devBox = '<div class="col-xs-' + col + ' text-center" id="master-' + key + '"><input type="text" class="' + key + '" /><div class="knob-label"><p><strong>' + name + '</strong></p><p>A: ' + ac + ' - R: ' + re + ' - H: ' + hw + '</p></div></div>';
  $('#master-' + key).remove();
  $(toAppend).append(devBox);
  $('.' + key).data('hashrate', hash);
  $('.' + key).knob({
    'readOnly': true,
    'fgColor': color,
    'inputColor': '#434343',
    'thickness': thickness,
    'skin': skin,
    'displayPrevious': true,
    'ticks': 16,
    'width': size,
    'height': size,
    'draw': function () {
      // 'tron' case
      if (this.o.skin === 'tron') {
        var a = this.angle(this.cv),
          // Angle
          sa = this.startAngle,
          // Previous start angle
          sat = this.startAngle,
          // Start angle
          ea,
          // Previous end angle
          eat = sat + a,
          // End angle
          r = true;
        this.g.lineWidth = this.lineWidth;
        this.o.cursor && (sat = eat - 0.3) && (eat = eat + 0.3);
        if (this.o.displayPrevious) {
          ea = this.startAngle + this.angle(this.value);
          this.o.cursor && (sa = ea - 0.3) && (ea = ea + 0.3);
          this.g.beginPath();
          this.g.strokeStyle = this.previousColor;
          this.g.arc(this.xy, this.xy, this.radius - this.lineWidth, sa, ea, false);
          this.g.stroke();
        }
        this.g.beginPath();
        this.g.strokeStyle = r ? this.o.fgColor : this.fgColor;
        this.g.arc(this.xy, this.xy, this.radius - this.lineWidth, sat, eat, false);
        this.g.stroke();
        this.g.lineWidth = 2;
        this.g.beginPath();
        this.g.strokeStyle = this.o.fgColor;
        this.g.arc(this.xy, this.xy, this.radius - this.lineWidth + 1 + this.lineWidth * 2 / 3, 0, 2 * Math.PI, false);
        this.g.stroke();
        this.i.val(convertHashrate(this.cv));
        return false;
      } else {
        this.i.val(convertHashrate(this.cv));
      }
    }
  });
  if (key === 'total')
    max = totalhash;
  else
    max = maxHashrate;
  $('.' + key).trigger('configure', {
    'min': 0,
    'max': max,
    'step': 1
  });
  $({ value: 0 }).animate({ value: hash }, {
    duration: 1000,
    easing: 'swing',
    step: function () {
      $('.' + key).val(Math.ceil(this.value)).trigger('change');
    }
  });
  $('.' + key).css('font-size', fontsize);
}
function changeEarnings(value) {
  var hashrate = $('.widget-total-hashrate').data('pool-hashrate');
  var amount = value * hashrate / 1000;
  $('.profitability-results').html('<span class="label bg-blue">' + convertHashrate(hashrate) + '</span>&nbsp;x&nbsp;<span class="label bg-green">' + value.toFixed(5) + '</span> = <small>Day: </small><span class="badge bg-red">' + amount.toFixed(8) + '</span> <small>Week: </small><span class="badge bg-light">' + (amount * 7).toFixed(8) + '</span> <small>Month: </small><span class="badge bg-light">' + (amount * 30).toFixed(8) + '</span>');
}
// Errors
function triggerError(msg) {
  $('.widgets-section').hide();
  $('.top-section').attr('style', 'display: none !important');
  $('.right-section').hide();
  $('.left-section').hide();
  $('.messages-avg').hide();
  $('.warning-message').html(msg);
  $('.warning-section').fadeIn();
  return false;
}
Number.prototype.noExponents = function () {
  var data = String(this).split(/[eE]/);
  if (data.length === 1)
    return data[0];
  var z = '', sign = this < 0 ? '-' : '', str = data[0].replace('.', ''), mag = Number(data[1]) + 1;
  if (mag < 0) {
    z = sign + '0.';
    while (mag++)
      z += '0';
    return z + str.replace(/^\-/, '');
  }
  mag -= str.length;
  while (mag--)
    z += '0';
  return str + z;
};
/*
// Main startup function //
*/
$(function () {
  var thisSection = $('.header').data('this-section');
  /*
	if (thisSection === 'settings') {
		jQuery.ajax({
			url: 'https://www.coinbase.com/assets/button.js',
			dataType: 'script',
			cache: true
		}).done(function() {
			console.log('Coinbase loaded');
		});
	}
	*/
  $('body').tooltip({
    selector: '[data-toggle="tooltip"]',
    trigger: 'hover'
  });
  $('body').popover({
    selector: '[data-toggle="popover"]',
    trigger: 'hover'
  });
  var timeNow = new Date().getTime(), promoInterval = 3600000, theInterval = null, adsFree = $('.app_data').data('ads-free');
  if (!adsFree) {
    var setPromoInterval = function () {
      if (theInterval) {
        //console.log('Clear');
        clearInterval(theInterval);
      }
      Cookies.remove('promoClicked');
      if (!Cookies.get('timestamp') || new Date().getTime() >= parseInt(Cookies.get('timestamp')) && !Cookies.get('promoModal')) {
        //console.log('Set');
        Cookies.set('timestamp', new Date().getTime() + promoInterval);
      }
      if (!Cookies.get('promoModal')) {
        theInterval = setInterval(function () {
          //console.log('Start');
          $('#modal-promo').modal('show');
          Cookies.set('promoModal', true);
          setPromoInterval();
        }, Cookies.get('timestamp') - new Date().getTime());
      }
    };
    // Promo ads
    if (new Date().getTime() >= parseInt(Cookies.get('timestamp')) && !Cookies.get('promoClicked')) {
      //console.log('Go');
      $('#modal-promo').modal('show');
    } else {
      setPromoInterval();
    }
    $('.modal-promo-hide').click(function (e) {
      e.preventDefault();
      $('#modal-promo').modal('hide');
      Cookies.set('promoClicked', true);
      Cookies.remove('promoModal');
      setPromoInterval();
    });  /*
		var overiFrame = -1;
	    $('.promo-iframe').hover( function() {
	        overiFrame = $(this).closest('.banner').attr('bannerid');
	    }, function() {
	        overiFrame = -1;
	    });

	    $(window).blur( function() {
	        if( overiFrame !== -1 ) {
				$('#modal-promo').modal('hide');
				Cookies.set('promoClicked', true);
				Cookies.remove('promoModal');
		  		setPromoInterval();
			}
	    });
	    */
  } else {
    Cookies.remove('promoModal');
    Cookies.remove('promoClicked');
    Cookies.remove('timestamp');
  }
  // Scroll ad
  if (thisSection !== 'lockscreen') {
    if ($(document).scrollTop() > 64) {
      $('.scroll-ad').fadeIn();
    }
    $(document).scroll(function () {
      var y = $(this).scrollTop();
      if (y > 64) {
        $('.scroll-ad').fadeIn();
      } else {
        $('.scroll-ad').fadeOut();
      }
    });
  }
  // Add responsive class to datatables
  $('.responsive-datatable-minera').on('DOMChanged', function () {
    $(this).parent().addClass('table-responsive');
  });
  // Smmoth scroll
  $('a[href*=#]:not([href=#])').click(function () {
    if (location.pathname.replace(/^\//, '') === this.pathname.replace(/^\//, '') && location.hostname === this.hostname) {
      var target = $(this.hash);
      target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
      if (target.length) {
        $('html,body').animate({ scrollTop: target.offset().top - 60 }, 1000);
        return false;
      }
    }
  });
  function startTime() {
    var today = new Date();
    var h = today.getHours();
    var m = today.getMinutes();
    var s = today.getSeconds();
    // add a zero in front of numbers<10
    m = checkTime(m);
    s = checkTime(s);
    //Check for PM and AM
    var dayOrNight = h > 11 ? 'PM' : 'AM';
    //Convert to 12 hours system
    if (h > 12) {
      h -= 12;
    }
    //Add time to the headline and update every 500 milliseconds
    $('.toptime').html(h + ':' + m + ':' + s + ' ' + dayOrNight);
    setTimeout(function () {
      startTime();
    }, 500);
  }
  function checkTime(i) {
    if (i < 10) {
      i = '0' + i;
    }
    return i;
  }
  startTime();
  $('.miner-action').click(function (e) {
    e.preventDefault();
    var action = $(this).data('miner-action');
    $('#modal-saving-label').html('Sending action: ' + action + ' , please wait...');
    $('#modal-saving').modal('show');
    saveSettings(false, false);
    var apiUrl = _baseUrl + '/app/api?command=miner_action&action=' + action;
    $.ajax({
      type: 'GET',
      url: apiUrl,
      cache: false,
      success: function (resp) {
        setTimeout(function () {
          $('#modal-saving').modal('hide');
          window.location.reload();
        }, 5000);
      }
    });
  });
  $('.reset-action').click(function (e) {
    e.preventDefault();
    var action = $(this).data('reset-action');
    $('#modal-saving-label').html('Resetting: ' + action + ' , please wait...');
    $('#modal-saving').modal('show');
    var apiUrl = _baseUrl + '/app/api?command=reset_action&action=' + action;
    $.ajax({
      type: 'GET',
      url: apiUrl,
      cache: false,
      success: function (resp) {
        $('#modal-saving').modal('hide');
        window.location.reload();
      }
    });
  });
  $('.reset-factory-action').click(function (e) {
    e.preventDefault();
    $('#modal-saving-label').html('Resetting Minera please wait...');
    $('#modal-saving').modal('show');
    var apiUrl = _baseUrl + '/app/api?command=factory_reset_action';
    $.ajax({
      type: 'GET',
      url: apiUrl,
      cache: false,
      success: function (resp) {
        setTimeout(function () {
          $('#modal-saving').modal('hide');
          window.location.reload();
        }, 1500);
      }
    });
  });
  $('.system-open-terminal').click(function (e) {
    e.preventDefault();
    var a = document.createElement('a');
    a.href = _baseUrl;
    if (!$('#terminal-iframe').attr('src')) {
      $('#terminal-iframe').attr('src', 'http://' + a.host + ':4200/');
    }
    $('#modal-terminal').modal('show');
  });
  $('.modal-hide').click(function (e) {
    e.preventDefault();
    $('#modal-terminal').modal('hide');
  });
  if (thisSection === 'charts') {
    // Chart Scripts
    createChart('hourly', '5 minutes');
    createChart('daily', '15 minutes');
    createChart('monthly', '1 hour');
    createChart('yearly', '1 day');
  } else if (thisSection === 'lockscreen') {
    $('.pass-form').trigger('focus');
    startTime();
    $('.copyright').addClass('copyright-lockscreen');
    if ($('body').data('timer')) {
      timer();
    }  /* CENTER ELEMENTS IN THE SCREEN */
       /*
		$('.center').center();
        $(window).resize(function() {
            $('.center').center();
        });
		jQuery.fn.center = function() {
            this.css('position', 'absolute');
            this.css('top', Math.max(0, (($(window).height() - $(this).outerHeight()) / 2) +
                    $(window).scrollTop()) - 30 + 'px');
            this.css('left', Math.max(0, (($(window).width() - $(this).outerWidth()) / 2) +
                    $(window).scrollLeft()) + 'px');
            return this;
        }*/
  } else if (thisSection === 'settings') {
    // Settings Scripts
    $('.box-tools').click(function (e) {
      e.preventDefault();
    });
    if ($(document).scrollTop() > 64) {
      $('.save-toolbox').fadeIn();
    }
    $(document).scroll(function () {
      var y = $(this).scrollTop();
      if (y > 64) {
        $('.save-toolbox').fadeIn();
      } else {
        $('.save-toolbox').fadeOut();
      }
    });
    $('.toggle-save-toolbox').click(function (e) {
      e.preventDefault();
      var nextIcon = $(this).find('.fa');
      if (nextIcon.hasClass('fa-close')) {
        nextIcon.addClass('fa-arrow-left');
        nextIcon.removeClass('fa-close');
        $('.save-toolbox').css('right', '-324px');
      } else {
        nextIcon.addClass('fa-close');
        nextIcon.removeClass('fa-arrow-left');
        $('.save-toolbox').css('right', '0');
      }
    });
    if (window.location.href.match(/settings/g)) {
      $('.treeview-menu-settings-icon').removeClass('fa-angle-left').addClass('fa-angle-down');
      $('.treeview-menu-settings-icon').parent('a').first().addClass('activeTree');
      $('.treeview-menu-settings').fadeIn();
    }
    $('#progress').hide();
    $('.save-minera-settings').click(function (e) {
      e.preventDefault();
      saveSettings(true, false);
    });
    $('.save-minera-settings-restart').click(function (e) {
      e.preventDefault();
      var input = $('<input>').attr('type', 'hidden').attr('name', 'save_restart').val(true);
      $('#minersettings').append($(input));
      saveSettings(true, false);
    });
    $('.import-file').fileupload({
      url: _baseUrl + '/app/api?command=import_file',
      dataType: 'json',
      done: function (e, data) {
        console.log(data.result);
        if (data.result.error) {
          $('#files').fadeOut();
          $('#files').html('<div class="callout callout-danger">' + data.result.error + '</div>').fadeIn();
        } else {
          $('#files').html('<div class="callout callout-grey"><p class="margin-bottom">File seems good, click the button to start trying import.</p><p><button class="btn btn-primary import-file-action" name="import-system" value="1">Import System</button></p></div>');
        }
      },
      progressall: function (e, data) {
        //$('#progress').show();
        var progress = parseInt(data.loaded / data.total * 100, 10);
        $('#progress .progress-bar').css('width', progress + '%');
      }
    }).prop('disabled', !$.support.fileInput).parent().addClass($.support.fileInput ? undefined : 'disabled');
    $(document).on('click', '.import-file-action', function (e) {
      e.preventDefault();
      $('#modal-saving-label').html('Cloning the system, please wait...');
      $('#modal-saving').modal('show');
      var saveUrl = _baseUrl + '/app/api?command=clone_system';
      $.ajax({
        type: 'GET',
        url: saveUrl,
        cache: false,
        success: function (resp) {
          $('#modal-saving').modal('hide');
          window.location.reload();
        }
      });
    });
    $('.export-action').click(function (e) {
      e.preventDefault();
      $('#modal-saving-label').html('Generating export file, please wait...');
      $('#modal-saving').modal('show');
      var saveUrl = _baseUrl + '/app/save_settings';
      var formData = $('#minersettings').serialize();
      $.ajax({
        type: 'POST',
        url: saveUrl,
        data: formData,
        cache: false,
        success: function (resp) {
          $('#modal-saving').modal('hide');
          window.location = _baseUrl + '/app/export';
        }
      });
    });
    $('.save-config-action').click(function (e) {
      e.preventDefault();
      $('#modal-saving-label').html('Saving current config, please wait...');
      $('#modal-saving').modal('show');
      var saveUrl = _baseUrl + '/app/save_settings?save_config=1';
      var formData = $('#minersettings').serialize();
      $.ajax({
        type: 'POST',
        url: saveUrl,
        data: formData,
        cache: false,
        success: function (resp) {
          var date = moment(resp.timestamp * 1000);
          var pools = '';
          for (var key in resp.pools) {
            pools += resp.pools[key].url + ' <i class="fa fa-angle-double-right"></i> ' + resp.pools[key].username + '<br />';
          }
          var htmlRow = '<tr class="config-' + resp.timestamp + '">' + '<td><small class="label label-info">' + date.format('MM/DD/YY h:mm a') + '</small></td>' + '<td><small class="label bg-blue">' + resp.software + '</small></td>' + '<td><small class="font-bold">' + resp.settings + '</small></td>' + '<td><small>' + pools + '</small></td>' + '<td class="text-center">' + '<a href="#" class="share-config-open" data-config-id="' + resp.timestamp + '" data-toggle="tooltip" data-title="Share saved config"><i class="fa fa-share-square-o"></i></a>' + '<a href="#" class="load-config-action" style="margin-left:10px;" data-config-id="' + resp.timestamp + '" data-toggle="tooltip" data-title="Load saved config"><i class="fa fa-upload"></i></a>' + '<a href="#" class="delete-config-action" style="margin-left:10px;" data-config-id="' + resp.timestamp + '" data-toggle="tooltip" data-title="Delete saved config"><i class="fa fa-times"></i></a>' + '</td>' + '</tr>';
          $('#saved-configs-table tbody').append(htmlRow);
          $('.saved-configs').show();
          $('#modal-saving').modal('hide');
        }
      });
    });
    $(document).on('click', '.share-config-open', function (e) {
      e.preventDefault();
      $('input[name="config_id"]').val($(this).data('config-id'));
      $('#modal-sharing').modal('show');
    });
    $(document).on('click', '.share-config-action', function (e) {
      e.preventDefault();
      $('.share-error').fadeOut();
      var descr = $('textarea[name="config_description"]').val();
      if (!descr || 0 === descr.length) {
        $('#formsharingconfig').append('<h6 class="callout bg-red share-error">Description can\'t be empty');
        return;
      }
      var saveUrl = _baseUrl + '/app/api/?command=share_config';
      var formData = $('#formsharingconfig').serialize();
      $.ajax({
        type: 'POST',
        url: saveUrl,
        data: formData,
        cache: false,
        success: function (resp) {
          console.log(resp);
          $('#modal-saving').modal('hide');
          window.location.reload();
        }
      });
    });
    $(document).on('click', '.delete-config-action', function (e) {
      e.preventDefault();
      var id = $(this).data('config-id');
      var saveUrl = _baseUrl + '/app/api/?command=delete_config&id=' + id;
      $('.config-' + id).fadeOut();
      $.ajax({
        type: 'GET',
        url: saveUrl,
        cache: false,
        success: function (resp) {
          //console.log(resp);
          $('.config-' + id).remove();
        }
      });
    });
    $(document).on('click', '.load-config-action', function (e) {
      e.preventDefault();
      $('#modal-saving-label').html('Loading config, please wait...');
      $('#modal-saving').modal('show');
      var id = $(this).data('config-id');
      var saveUrl = _baseUrl + '/app/api/?command=load_config&id=' + id;
      $('.config-' + id).fadeOut('fast').fadeIn('slow');
      $.ajax({
        type: 'GET',
        url: saveUrl,
        cache: false,
        success: function (resp) {
          $('#modal-saving').modal('hide');
          window.location.reload();
        }
      });
    });
    // Network miners
    $(document).on('click', '.scan-network', function (e) {
      e.preventDefault();
      $('#modal-saving-label').html('Scanning the network, please wait...');
      $('#modal-saving').modal('show');
      var scanUrl = _baseUrl + '/app/api?command=scan_network';
      $.ajax({
        type: 'GET',
        url: scanUrl,
        cache: false,
        success: function (resp) {
          $('#modal-saving').modal('hide');
          if (resp.length > 0) {
            $('.net-group-master').first().clone().prependTo('.netSortable');
            $('.net-group-master').first().css('display', 'block').removeClass('net-group-master');
            $.each(resp, function (index, value) {
              $('.net-group:first .net-row .net_miner_status').html('<i class="fa fa-circle text-success"></i> Online');
              $('.net-group:first .net-row .net_miner_name').val(value.name);
              $('.net-group:first .net-row .net_miner_ip').val(value.ip);
              $('.net-group:first .net-row .net_miner_port').val('4028');
              $('.net-group:first .net-row .net_miner_status').removeClass('label-primary').addClass('label-success');
            });
            setTimeout(function () {
              saveSettings(true, true);
            }, 2000);
          } else {
            $('.alert-no-net-devices').fadeIn();
            setTimeout(function () {
              $('.alert-no-net-devices').fadeOut();
            }, 5000);
          }
        }
      });
    });    
    $(document).on('click', '.net_miner_status', function (e) {
      e.preventDefault();
    });
    $(document).on('click', '.del-net-row', function (e) {
      e.preventDefault();
      $(this).closest('.form-group').remove();
      saveSettings(false, true);
    });
    $(document).on('click', '.add-net-row', function (e) {
      e.preventDefault();
      $('.net-group-master').first().clone().appendTo('.netSortable');
      $('.net-group-master').last().css('display', 'block').removeClass('net-group-master');
    });
        
    $('.netSortable').sortable({
      placeholder: 'sort-highlight',
      connectWith: '.sort-attach',
      handle: '.sort-attach',
      forcePlaceholderSize: true,
      zIndex: 999999
    });

    // GPU Network miners
    $(document).on('click', '.scan-gpu-network', function (e) {
      e.preventDefault();
      $('#modal-saving-label').html('Scanning the gpu network, please wait...');
      $('#modal-saving').modal('show');
      var scanUrl = _baseUrl + '/app/api?command=scan_gpu_network';
      $.ajax({
        type: 'GET',
        url: scanUrl,
        cache: false,
        success: function (resp) {
          $('#modal-saving').modal('hide');
          if (resp.length > 0) {
            $('.gpu-net-group-master').first().clone().prependTo('.gpuNetSortable');
            $('.gpu-net-group-master').first().css('display', 'block').removeClass('gpu-net-group-master');
            $.each(resp, function (index, value) {
              $('.gpu-net-group:first .net-row .net_miner_status').html('<i class="fa fa-circle text-success"></i> Online');
              $('.gpu-net-group:first .net-row .gpu_net_miner_name').val(value.name);
              $('.gpu-net-group:first .net-row .gpu_net_miner_ip').val(value.ip);
              $('.gpu-net-group:first .net-row .gpu_net_miner_port').val('3333');
              $('.gpu-net-group:first .net-row .net_miner_status').removeClass('label-primary').addClass('label-success');
            });
            setTimeout(function () {
              saveSettings(true, true);
            }, 2000);
          } else {
            $('.alert-no-gpu-net-devices').fadeIn();
            setTimeout(function () {
              $('.alert-no-gpu-net-devices').fadeOut();
            }, 5000);
          }
        }
      });
    });    
    $(document).on('click', '.del-gpu-net-row', function (e) {
      e.preventDefault();
      $(this).closest('.form-group').remove();
      saveSettings(false, true);
    });
    $(document).on('click', '.add-gpu-net-row', function (e) {
      e.preventDefault();
      $('.gpu-net-group-master').first().clone().appendTo('.gpuNetSortable');
      $('.gpu-net-group-master').last().css('display', 'block').removeClass('gpu-net-group-master');
    });  

    $('.gpuNetSortable').sortable({
      placeholder: 'sort-highlight',
      connectWith: '.sort-attach',
      handle: '.sort-attach',
      forcePlaceholderSize: true,
      zIndex: 999999
    });    

    $('.sort-attach').css('cursor', 'move');
    //Make the dashboard widgets sortable Using jquery UI
    $('.poolSortable').sortable({
      placeholder: 'sort-highlight',
      connectWith: '.sort-attach',
      handle: '.sort-attach',
      forcePlaceholderSize: true,
      zIndex: 999999
    });
    $('.sort-attach').css('cursor', 'move');    

    // Initialize options sliders
    $('.open-readme-donation').click(function (e) {
      e.preventDefault();
      $('.readme-donation').fadeToggle();
    });
    $('.view-stored-donations').click(function (e) {
      e.preventDefault();
      $('#stored-donation-table_wrapper').toggle();
      $('#stored-donation-table').fadeToggle();
    });
    $('#stored-donation-table').dataTable({
      bFilter: false,
      bInfo: false,
      bPaginate: true,
      'dom': '<"top"i>rt<"bottom"flp><"clear">'
    });
    $('#stored-donation-table_wrapper').hide();
    var donationProfitability = $('#option-minera-donation-time').data('donation-profitability'), savedDonationTime = $('#option-minera-donation-time').data('saved-donation-time');
    $('#option-minera-donation-time').ionRangeSlider({
      min: 0,
      max: 360,
      from: savedDonationTime ? savedDonationTime : 0,
      type: 'single',
      step: 10,
      postfix: ' Mins',
      grid: true,
      onStart: function (obj) {
        changeDonationWorth(donationProfitability, obj.from);
      },
      onChange: function (obj) {
        if (obj.from > 0) {
          $('#option-minera-donation-time').ionRangeSlider('update', { to: 0 });
        }
        changeDonationWorth(donationProfitability, obj.from);
      }
    });
    $('#ion-startfreq').ionRangeSlider({
      min: 600,
      max: 1400,
      from: $('#ion-startfreq').data('saved-startfreq'),
      type: 'single',
      step: 1,
      postfix: ' Mhz',
      grid: true
    });
    $('#option-dashboard-refresh-time').ionRangeSlider({
      min: 0,
      max: 600,
      from: $('#option-dashboard-refresh-time').data('saved-refresh-time'),
      type: 'single',
      step: 5,
      postfix: ' Secs',
      grid: true,
      onChange: function (obj) {
        if (obj.from > 0) {
          $('#option-dashboard-refresh-time').ionRangeSlider('update', { from: 0 });
        }
        if (obj.to < 5) {
          $('#option-dashboard-refresh-time').ionRangeSlider('update', { to: 5 });
        }
      }
    });
    $(document).on('click', '.help-pool-row', function (e) {
      e.preventDefault();
      $('.minera-pool-help').fadeToggle();
    });
    $(document).on('click', '.del-pool-row', function (e) {
      e.preventDefault();
      $(this).closest('.form-group').remove();
    });
    $(document).on('click', '.add-pool-row', function (e) {
      e.preventDefault();
      if ($(this).data('network')) {
        $('.pool-' + $(this).data('networkminer')).first().clone().appendTo('.net-' + $(this).data('networkminer'));
        $('.pool-' + $(this).data('networkminer')).last().css('display', 'block').removeClass('.pool-' + $(this).data('networkminer'));
      } else {
        $('.pool-group-master').first().clone().appendTo('.poolSortable');
        $('.pool-group-master').last().css('display', 'block').removeClass('pool-group-master');
      }
    });
    $('.form-donation').prop('disabled', true);
    $(document).on('click', '.add-donation-pool-row', function (e) {
      e.preventDefault();
      if ($(this).data('network')) {
        $('.form-donation').prop('readonly', true).prop('disabled', false);
        $('.pool-net-donation-' + $(this).data('networkminer')).css('display', 'block').removeClass('.pool-net-donation-' + $(this).data('networkminer'));
      } else {
        $('.form-donation').prop('readonly', true).prop('disabled', false);
        $('.pool-donation-group').css('display', 'block').removeClass('pool-donation-group');
      }
      $(this).fadeOut();
    });
    // Custom miners
    // Initialize options sliders
    $('.open-readme-custom-miners').click(function (e) {
      e.preventDefault();
      $('.readme-custom-miners').fadeToggle();
    });
    $('#minerd-software').on('change', function () {
      showHideMinerOptions(true);
      $('#miners-conf').val('');
      $('.miners-conf-box').fadeOut();
    });
    $('#miners-conf').on('change', function () {
      $('#minerd-software').val($(this).find(':selected').data('miner-id'));
      $('.miners-conf-box').html('<code>' + $(this).val() + '</code>').fadeIn();
      showHideMinerOptions(true);
      $('.guided-options').fadeOut();
      $('.manual-options').fadeIn();
      $('.btn-manual-options').addClass('disabled');
      $('.btn-guided-options').removeClass('disabled');
      $('#manual_options').val(1);
      $('#guided_options').val(0);
      $('.manual-settings').val($(this).val());
    });
    $(document).on('click', '.del-custom-miner', function (e) {
      e.preventDefault();
      var d = $(this).closest('.input-group');
      $.ajax(_baseUrl + '/app/api?command=delete_custom_miner&custom=' + $(this).data('custom-miner'), {
        success: function (data) {
          if (data) {
            console.log(data);
            d.fadeOut().remove();
          }
        }
      });
    });
    showHideMinerOptions(false);
    if ($('#manual_options').val() === '1') {
      $('.guided-options').hide();
    }
    if ($('#guided_options').val() === '1') {
      $('.manual-options').hide();
    }
    $('.btn-manual-options').click(function () {
      $('.guided-options').fadeOut();
      $('.manual-options').fadeIn();
      $('.btn-manual-options').addClass('disabled');
      $('.btn-guided-options').removeClass('disabled');
      $('#manual_options').val(1);
      $('#guided_options').val(0);
      return false;
    });
    $('.btn-guided-options').click(function () {
      $('.manual-options').fadeOut();
      $('.guided-options').fadeIn();
      $('.btn-guided-options').addClass('disabled');
      $('.btn-manual-options').removeClass('disabled');
      $('#manual_options').val(0);
      $('#guided_options').val(1);
      return false;
    });
    // validate signup form on keyup and submit
    $.validator.addMethod('check_multiple_select', function (value, element) {
      if (value && value.length > 0 && value.length <= 5) {
        return true;
      }
      return false;
    }, 'Select at least 1 rate (max 5)');
    $.validator.addMethod('no_quote', function (value, element) {
      if (!value.match(/\'/)) {
        return true;
      }
      return false;
    }, 'You can use any symbol but single quote');
    jQuery.validator.addMethod('validIP', function (value) {
      var split = value.split('.');
      if (split.length !== 4) {
        return false;
      }
      for (var i = 0; i < split.length; i++) {
        var s = split[i];
        if (s.length === 0 || isNaN(s) || s < 0 || s > 255) {
          return false;
        }
      }
      return true;
    }, ' Invalid IP Address');
    var validator = $('#minersettings').validate({
        rules: {
          minerd_manual_settings: 'required',
          mobileminer_system_name: {
            required: {
              depends: function () {
                return $('.mobileminer-checkbox').is(':checked');
              }
            }
          },
          mobileminer_email: {
            required: {
              depends: function () {
                return $('.mobileminer-checkbox').is(':checked');
              }
            },
            email: true
          },
          mobileminer_appkey: {
            required: {
              depends: function () {
                return $('.mobileminer-checkbox').is(':checked');
              }
            }
          },
          minerd_autorestart_devices: {
            required: {
              depends: function () {
                return $('.minerd-autorestart').is(':checked');
              }
            }
          },
          scheduled_event_action: {
            required: {
              depends: function () {
                return $('.scheduled-event-time').val();
              }
            }
          },
          scheduled_event_time: { number: true },
          system_password: {
            minlength: 6,
            no_quote: true
          },
          system_password2: { equalTo: '#system_password' }
        },
        errorPlacement: function (error, element) {
          error.appendTo($(element).closest('.input-group').parent().after());
        },
        submitHandler: function () {
          saveSettings(true, false);
        },
        unhighlight: function (element) {
          $(element).closest('.input-group').removeClass('has-error').addClass('has-success');
        },
        highlight: function (element, errorClass) {
          $(element).closest('.input-group').removeClass('has-success').addClass('has-error');
        }
      });
    if ($('.dashboard-coin-rates').length) {
      $('.dashboard-coin-rates').rules('add', { check_multiple_select: true });
    }
    $('.pool_url').each(function () {
      if ($(this).data('ismain')) {
        $(this).rules('add', 'required');
      } else {
        $(this).rules('add', {
          required: {
            depends: function (element) {
              return $(element).parent().parent().parent().find('.pool_username').val() !== '' || $(element).parent().parent().parent().find('.pool_password').val() !== '';
            }
          }
        });
      }
    });
    $('.pool_username').each(function () {
      if ($(this).data('ismain')) {
        $(this).rules('add', 'required');
      } else {
        $(this).rules('add', {
          required: {
            depends: function (element) {
              return $(element).parent().parent().parent().find('.pool_url').val() !== '' || $(element).parent().parent().parent().find('.pool_password').val() !== '';
            }
          }
        });
      }
    });
    $('.pool_password').each(function () {
      if ($(this).data('ismain')) {
        $(this).rules('add', 'required');
      } else {
        $(this).rules('add', {
          required: {
            depends: function (element) {
              return $(element).parent().parent().parent().find('.pool_username').val() !== '' || $(element).parent().parent().parent().find('.pool_url').val() !== '';
            }
          }
        });
      }
    });
    $('.net_miner_name').each(function () {
      $(this).rules('add', {
        required: {
          depends: function (element) {
            return $(element).parent().parent().parent().find('.net_miner_ip').val() !== '' || $(element).parent().parent().parent().find('.net_miner_port').val() !== '';
          }
        }
      });
    });
    $('.net_miner_ip').each(function () {
      $(this).rules('add', {
        required: {
          depends: function (element) {
            return $(element).parent().parent().parent().find('.net_miner_name').val() !== '' || $(element).parent().parent().parent().find('.net_miner_port').val() !== '';
          }
        },
        validIP: true
      });
    });
    $('.net_miner_port').each(function () {
      $(this).rules('add', {
        required: {
          depends: function (element) {
            return $(element).parent().parent().parent().find('.net_miner_ip').val() !== '' || $(element).parent().parent().parent().find('.net_miner_name').val() !== '';
          }
        },
        number: true
      });
    });
  } else if (thisSection === 'dashboard') {
    // Dashboard Scripts
    if (window.location.href.match(/dashboard/g)) {
      $('.treeview-menu-dashboard-icon').removeClass('fa-angle-left').addClass('fa-angle-down');
      $('.treeview-menu-dashboard-icon').parent('a').first().addClass('activeTree');
      $('.treeview-menu-dashboard').fadeIn();
    }
    // Refresh stats when you come back in Minera tab
    window.onblur = function () {
      window.onfocus = function () {
        getStats(true);
        target_date = new Date().getTime();
      };
    };
    var refresh_time = $('.app_data').data('refresh-time');
    // set the date we're counting down to
    var target_date = new Date().getTime();
    // variables for time units
    var days, hours, minutes, seconds;
    // update the tag with id 'countdown' every 1 second
    setInterval(function () {
      // find the amount of 'seconds' between now and target
      var current_date = new Date().getTime();
      var seconds_left = (target_date + (refresh_time * 1000 + 1000) - current_date) / 1000;
      //console.log(parseInt(seconds_left));
      if (parseInt(seconds_left) !== 0) {
        // do some time calculations
        minutes = parseInt(seconds_left / 60);
        seconds = parseInt(seconds_left % 60);
        // format countdown string + set tag value
        $('.auto-refresh-time').html(minutes + 'm : ' + seconds + 's ');
      } else {
        target_date = new Date().getTime();
        getStats(true);
      }
    }, 1000);
    // Refresh button
    $(document).on('click', '.refresh-btn', function (e) {
      e.preventDefault();
      getStats(true);
      target_date = new Date().getTime();
    });
    // Save frequency table button
    $('.btn-saved-freq').click(function () {
      $('.freq-box').fadeToggle();
    });
    $('.save-freq').click(function () {
      $('.freq-box').fadeOut();
      $.ajax(_baseUrl + '/app/api?command=save_current_freq', {
        dataType: 'text',
        success: function (data) {
          if (data) {
            $('#miner-freq').html('--gc3355-freq=' + data);
            $.scrollTo($('.freq-box').fadeIn());
          }
        }
      });
    });
    // Raw stats click
    $('.view-raw-stats').click(function () {
      $('.section-raw-stats').fadeIn();
    });
    $('.close-stats').click(function () {
      $('.section-raw-stats').fadeOut();
    });
    //Make the dashboard widgets sortable Using jquery UI
    $('.connectedSortable').sortable({
      placeholder: 'sort-highlight',
      connectWith: '.connectedSortable',
      handle: '.box-header, .nav-tabs',
      forcePlaceholderSize: true,
      zIndex: 999999
    });
    $('.box-header, .nav-tabs').css('cursor', 'move');
    /*
		// Start logviewer
		*/
    var dataelem = '#real-time-log-data';
    var pausetoggle = '#pause';
    var scrollelems = ['.real-time-log-data'];
    var log_url = $('.app_data').data('minerd-log');
    var fix_rn = true;
    var load_log = 1 * 1024;
    /* 30KB */
    var poll = 1000;
    /* 1s */
    var kill = false;
    var loading = false;
    var reverse = false;
    var log_data = '';
    var log_size = 0;
    var pause_log = false;
    // Logs
    var get_log = function () {
      if (kill | loading)
        return;
      loading = true;
      var range;
      if (log_size === 0)
        /* Get the last 'load' bytes */
        range = '-' + load_log.toString();
      else
        /* Get the (log_size - 1)th byte, onwards. */
        range = (log_size - 1).toString() + '-';
      /* The 'log_size - 1' deliberately reloads the last byte, which we already
		     * have. This is to prevent a 416 'Range unsatisfiable' error: a response
		     * of length 1 tells us that the file hasn't changed yet. A 416 shows that
		     * the file has been trucnated */
      $.ajax(log_url, {
        dataType: 'text',
        cache: false,
        headers: { Range: 'bytes=' + range },
        success: function (data, s, xhr) {
          loading = false;
          var size;
          if (xhr.status === 206) {
            //if (data.length > load_log)
            //throw 'Expected 206 Partial Content';
            var c_r = xhr.getResponseHeader('Content-Range');
            if (!c_r)
              throw 'Server did not respond with a Content-Range';
            size = parseInt(c_r.split('/')[1]);
            if (isNaN(size))
              throw 'Invalid Content-Range size';
          } else if (xhr.status === 200) {
            if (log_size > 1)
              throw 'Expected 206 Partial Content';
            size = data.length;
          }
          var added = false, start = 0;
          if (log_size === 0) {
            /* Clip leading part-line if not the whole file */
            if (data.length < size) {
              start = data.indexOf('\n');
              log_data = data.substring(start + 1);
            } else {
              log_data = data;
            }
            added = true;
          } else {
            /* Drop the first byte (see above) */
            log_data += data.substring(1);
            if (log_data.length > load_log) {
              start = log_data.indexOf('\n', log_data.length - load_log);
              log_data = log_data.substring(start + 1);
            }
            if (data.length > 1)
              added = true;
          }
          log_size = size;
          if (added)
            show_log(added);
          setTimeout(get_log, poll);
        },
        error: function (xhr, s, t) {
          loading = false;
          if (xhr.status === 416 || xhr.status === 404) {
            /* 416: Requested range not satisfiable: log was truncated. */
            /* 404: Retry soon, I guess */
            log_size = 0;
            log_data = '';
            show_log();
            setTimeout(get_log, poll);
          } else {
            if (s === 'error')
              console.log(xhr.statusText);
            else
              console.log('AJAX Error: ' + s);
          }
        }
      });
    };
    var scroll_log = function (where) {
      for (var i = 0; i < scrollelems.length; i++) {
        var s = $(scrollelems[i]);
        if (where === -1)
          s.scrollTop(s.height());
        else
          s.scrollTop(where);
      }
    };
    var show_log = function () {
      if (pause_log)
        return;
      var t = log_data;
      if (reverse) {
        var t_a = t.split(/\n/g);
        t_a.reverse();
        if (t_a[0] === '')
          t_a.shift();
        t = t_a.join('\n');
      }
      if (fix_rn)
        t = t.replace(/\n/g, '\r\n');
      $(dataelem).text(t);
      if (!reverse)
        scroll_log(-1);
    };
    /* Add pause toggle */
    $('.pause-log').click(function (e) {
      pause_log = !pause_log;
      if (pause_log) {
        kill = true;
        $(this).html('<i class="fa fa-play"></i>');
        $(this).attr('data-original-title', 'Play log');
      } else {
        kill = false;
        get_log();
        $(this).html('<i class="fa fa-pause"></i>');
        $(this).attr('data-original-title', 'Pause log');
      }
      show_log();
      e.preventDefault();
    });
    get_log();
    $('.pause-log').click();
    /*
		// End logviewer
		*/
    $('.profitability-question').click(function (e) {
      e.preventDefault();
      $('.profitability-help').fadeToggle();
    });
    $('#profitability-slider').ionRangeSlider({
      min: 0,
      max: 0.001,
      to: 0,
      type: 'single',
      step: 0.00001,
      postfix: ' <i class="fa fa-btc"></i>',
      grid: true,
      onChange: function (obj) {
        changeEarnings(obj.from);
      }
    });
  }
});
// ****************************** //
// NETWORK miners pools functions //
// ****************************** //
// Select Pool on the fly
$(document).on('click', '.select-net-pool', function (e) {
  e.preventDefault();
  $('.overlay').show();
  var poolId = $(this).data('pool-id'), netConfig = $(this).data('pool-config'), netMiner = $(this).data('netminer');
  $.ajax(_baseUrl + '/app/api?command=select_pool&poolId=' + poolId + '&network=' + netConfig, {
    dataType: 'text',
    success: function (dataP) {
      if (dataP) {
        var dataJ = $.parseJSON(dataP);
        setTimeout(function () {
          getStats(true);
        }, 2000);
        $('.net-pool-alert-' + netMiner).html('Miner could take some minutes to complete the switching process, try to <a href="#" class="refresh-btn">refresh the dashboard</a>. <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>');
        setTimeout(function () {
          $('.net-pool-alert-' + netMiner).html('');
        }, 30000);
      }
    }
  });
});
// Remove Pool on the fly
$(document).on('click', '.remove-net-pool', function (e) {
  e.preventDefault();
  $('.overlay').show();
  var poolId = $(this).data('pool-id'), netConfig = $(this).data('pool-config'), netMiner = $(this).data('netminer');
  $.ajax(_baseUrl + '/app/api?command=remove_pool&poolId=' + poolId + '&network=' + netConfig, {
    dataType: 'text',
    success: function (dataP) {
      if (dataP) {
        var dataJ = $.parseJSON(dataP);
        setTimeout(function () {
          getStats(true);
        }, 2000);
        if (dataJ) {
          $('.net-pool-alert-' + netMiner).html('Miner response: <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>');
          setTimeout(function () {
            $('.net-pool-alert-' + netMiner).html('');
          }, 30000);
        }
      }
    }
  });
});
// Add network Pool on the fly
$(document).on('click', '.toggle-add-net-pool', function (e) {
  e.preventDefault();
  //$('.overlay').show();
  if ($(this).data('open')) {
    $(this).nextAll('.form-group').fadeOut();
    $(this).data('open', false);
  } else {
    $(this).nextAll('.form-group').fadeIn();
    $(this).data('open', true);
  }
});
$(document).on('click', '.add-net-pool', function (e) {
  e.preventDefault();
  $('.overlay').show();
  var netMiner = $(this).data('netminer');
  if ($('.pool_url_' + $(this).data('netminer')).val() && $('.pool_username_' + $(this).data('netminer')).val() && $('.pool_password_' + $(this).data('netminer')).val()) {
    $('.net-pool-error-' + $(this).data('netminer')).html('').fadeOut();
    var params = {
        command: 'add_pool',
        url: $('.pool_url_' + $(this).data('netminer')).val(),
        user: $('.pool_username_' + $(this).data('netminer')).val(),
        pass: $('.pool_password_' + $(this).data('netminer')).val(),
        network: $(this).data('network')
      }, query = $.param(params);
    $.ajax(_baseUrl + '/app/api?' + query, {
      dataType: 'text',
      success: function (dataP) {
        if (dataP) {
          var dataJ = $.parseJSON(dataP);
          //console.log(dataJ);
          getStats(true);
          if (dataJ) {
            $('.net-pool-alert-' + netMiner).html('Miner response: <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>');
            setTimeout(function () {
              $('.net-pool-alert-' + netMiner).html('');
            }, 30000);
          }
          $('.pool_url_' + netMiner).val('').addClass('error');
          $('.pool_username_' + netMiner).val('').addClass('error');
          $('.pool_password_' + netMiner).val('').addClass('error');
        }
      }
    });
  } else {
    $('.net-pool-error-' + netMiner).html('<i class="fa fa-warning"></i> Each field is required').fadeIn();
  }
});
$(document).on('click', '.add-net-donation-pool', function (e) {
  e.preventDefault();
  $('.overlay').show();
  var netMiner = $(this).data('netminer'), donationUrl = $(this).data('netcoin') === 'SHA-256' ? $('.app_data').data('minera-pool-url-sha256') : $('.app_data').data('minera-pool-url-scrypt'), params = {
      command: 'add_pool',
      url: donationUrl,
      user: $('.app_data').data('minera-pool-username'),
      pass: 'x',
      network: $(this).data('network')
    }, query = $.param(params);
  $.ajax(_baseUrl + '/app/api?' + query, {
    dataType: 'text',
    success: function (dataP) {
      if (dataP) {
        var dataJ = $.parseJSON(dataP);
        //console.log(dataJ);
        getStats(true);
        if (dataJ) {
          $('.net-pool-alert-' + netMiner).html('Miner response: <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>');
          setTimeout(function () {
            $('.net-pool-alert-' + netMiner).html('');
          }, 30000);
        }
        $('.pool_url_' + netMiner).val('').addClass('error');
        $('.pool_username_' + netMiner).val('').addClass('error');
        $('.pool_password_' + netMiner).val('').addClass('error');
      }
    }
  });
});
// ****************************** //
//  LOCAL miners pools functions  //
// ****************************** //
// Select Pool on the fly
$(document).on('click', '.select-pool', function (e) {
  e.preventDefault();
  $('.overlay').show();
  var poolId = $(this).data('pool-id');
  $.ajax(_baseUrl + '/app/api?command=select_pool&poolId=' + poolId, {
    dataType: 'text',
    success: function (dataP) {
      if (dataP) {
        var dataJ = $.parseJSON(dataP);
        getStats(true);
        if (dataJ) {
          $('.pool-alert').html('CG/BFGminer could take some minutes to complete the switching process, try to <a href="#" class="refresh-btn">refresh the dashboard</a>.. <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>').fadeIn();
          setTimeout(function () {
            $('.pool-alert').html('');
          }, 30000);
        }
      }
    }
  });
});
// Toggle local pool on the fly
$(document).on('click', '.toggle-add-pool', function (e) {
  e.preventDefault();
  //$('.overlay').show();
  if ($(this).data('open')) {
    $(this).nextAll('.form-group').fadeOut();
    $(this).data('open', false);
  } else {
    $(this).nextAll('.form-group').fadeIn();
    $(this).data('open', true);
  }
});
$(document).on('click', '.add-pool', function (e) {
  e.preventDefault();
  $('.overlay').show();
  if ($('.local_pool_url').val() && $('.local_pool_username').val() && $('.local_pool_password').val()) {
    $('.pool-alert').html('').fadeOut();
    var params = {
        command: 'add_pool',
        url: $('.local_pool_url').val(),
        user: $('.local_pool_username').val(),
        pass: $('.local_pool_password').val()
      }, query = $.param(params);
    $.ajax(_baseUrl + '/app/api?' + query, {
      dataType: 'text',
      success: function (dataP) {
        if (dataP) {
          var dataJ = $.parseJSON(dataP);
          //console.log(dataJ);
          getStats(true);
          if (dataJ) {
            $('.pool-alert').html('Miner response: <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>').fadeIn();
            setTimeout(function () {
              $('.pool-alert').html('');
            }, 30000);
          }
          $('.local_pool_url').val('').addClass('error');
          $('.local_pool_username').val('').addClass('error');
          $('.local_pool_password').val('').addClass('error');
        }
      }
    });
  } else {
    $('.pool-alert').html('<i class="fa fa-warning"></i> Each field is required').fadeIn();
  }
});
// Remove local pool on the fly
$(document).on('click', '.remove-pool', function (e) {
  e.preventDefault();
  if ($('.app_data').data('miner-running') !== 'cpuminer' && $('.app_data').data('miner-running') !== undefined) {
    $('.overlay').show();
    var poolId = $(this).data('pool-id');
    $.ajax(_baseUrl + '/app/api?command=remove_pool&poolId=' + poolId, {
      dataType: 'text',
      success: function (dataP) {
        if (dataP) {
          var dataJ = $.parseJSON(dataP);
          setTimeout(function () {
            getStats(true);
          }, 2000);
          if (dataJ) {
            $('.pool-alert').html('Miner response: <pre style="font-size:10px;margin-top:10px;">' + dataP + '</pre>').fadeIn();
            setTimeout(function () {
              $('.pool-alert').html('');
            }, 30000);
          }
        }
      }
    });
  } else {
    $('.pool-alert').html('<pre style="font-size:10px;margin-top:10px;">Sorry, but CPUMiner doesn\'t support remove pool on the fly</pre>').fadeIn();
  }
});
$(document).on('click', '.cron-unlock', function (e) {
  e.preventDefault();
  $('#modal-saving-label').html('Unlocking cron...');
  $('#modal-saving').modal('show');
  var apiUrl = _baseUrl + '/app/api?command=cron_unlock';
  $.ajax({
    type: 'GET',
    url: apiUrl,
    cache: false,
    success: function (resp) {
      $('#modal-saving').modal('hide');
      getStats(true);
    }
  });
});
// Define underscore variable template
if ($('.header').data('this-section') !== 'lockscreen') {
  _.templateSettings.variable = 'rc';
  var btcRatesTemplate = _.template($('script.btc-rates-template').html()), avgStatsTemplate = _.template($('script.avg-stats-template').html());
}
// Stats scripts
function getStats(refresh) {
  var now = new Date().getTime();
  var d = 0, totalhash = 0, totalac = 0, totalre = 0, totalhw = 0, totalsh = 0, totalfr = 0, totalpoolhash = 0, poolHash = 0, errorTriggered = false, pool_shares_seconds, log_file = $('.app_data').data('minerd-log').replace(/^.*[\\\/]/, ''), miner_status = $('.app_data').data('miner-status'),
    // Raw stats
    boxStats = $('.section-raw-stats'), thisSection = $('.header').data('this-section');
  boxStats.hide();
  $('.overlay').show();
  $('.refresh-icon').addClass('fa-spin');
  // Show loaders
  //$('.loading-img').show();
  /* Knob, Table, Sysload */
  // get Json data from minerd and create Knob, table and sysload
  $.getJSON(_baseUrl + '/app/stats', function (data) {
    // console.log(data);
    if (data.notloggedin) {
      errorTriggered = true;
      triggerError('It seems your session expired.');
      window.location.reload();
    } else {
      var items = [];
      var hashrates = [];
      var lastTotalShares = [];
      var miner_starttime = data.start_time;
      var startdate = new Date(data.start_time * 1000);
      $('body').data('stats-loop', 0);
      if (data.notrunning) {
        $('.disable-if-not-running').fadeOut();
        $('.enable-if-not-running').fadeIn();
        $('.local-widget').removeClass('col-lg-4 col-sm-4').addClass('col-lg-6 col-sm-6');
        if (miner_status) {
          errorTriggered = true;
          $('.warning-message').html('Your local miner is offline. Click here to check last logs.');
          $('.widget-warning').html('Not running');
          $.ajax(_baseUrl + '/app/api?command=tail_log&file=' + log_file, {
            dataType: 'text',
            success: function (dataP) {
              if (dataP) {
                var dataJ = $.parseJSON(dataP);
                $('#modal-log-label').html('Check the logs');
                $('#modal-log .modal-log-lines').html(dataJ.join('<br />'));
              }
            }
          });
          $('.warning-message').click(function (e) {
            e.preventDefault();
            $('#modal-log').modal('show');
          });
        } else {
          $('.disable-if-stopped').fadeOut();
        }
      } else if (data.error) {
        errorTriggered = true;
        $('.disable-if-not-running').fadeOut();
        $('.enable-if-not-running').fadeIn();
        $('.warning-message').html(data.msg);
        $('.widget-warning').html('Error');
        $('.local-widget').removeClass('col-lg-4 col-sm-4').addClass('col-lg-6 col-sm-6');
        $.ajax(_baseUrl + '/app/api?command=tail_log&file=' + log_file, {
          dataType: 'text',
          success: function (dataP) {
            if (dataP) {
              var dataJ = $.parseJSON(dataP);
              $('#modal-log-label').html('Check the logs');
              $('#modal-log .modal-log-lines').html(dataJ.join('<br />'));
            }
          }
        });
        $('.warning-message').click(function (e) {
          e.preventDefault();
          $('#modal-log').modal('show');
        });
      }
      if (refresh) {
        // Destroy and clear the data tables before you can re-initialize it
        if ($.fn.dataTable.isDataTable('#miner-table-details')) {
          $('#miner-table-details').dataTable().fnClearTable();
          $('#miner-table-details').dataTable().fnDestroy();
        }
        if ($.fn.dataTable.isDataTable('#network-miner-table-details')) {
          $('#network-miner-table-details').dataTable().fnClearTable();
          $('#network-miner-table-details').dataTable().fnDestroy();
        }
        if ($.fn.dataTable.isDataTable('#gpu-network-miner-table-details')) {
          $('#gpu-network-miner-table-details').dataTable().fnClearTable();
          $('#gpu-network-miner-table-details').dataTable().fnDestroy();
        }        
        if ($.fn.dataTable.isDataTable('#pools-table-details')) {
          $('#pools-table-details').dataTable().fnClearTable();
          $('#pools-table-details').dataTable().fnDestroy();
        }
        if ($.fn.dataTable.isDataTable('#profit-table-details')) {
          $('#profit-table-details').dataTable().fnClearTable();
          $('#profit-table-details').dataTable().fnDestroy();
        }
        $('.net-pools-table').each(function (key, obj) {
          if ($.fn.dataTable.isDataTable($(this))) {
            $(this).dataTable().fnClearTable();
            $(this).dataTable().fnDestroy();
          }
        });
      }
      // Cron status
      if (data.cron) {
        $('.cron-status').fadeIn();
      } else {
        $('.cron-status').fadeOut();
      }
      // Add raw stats box
      boxStats.find('span').html('<pre style="height:350px; overflow: scroll; font-size:10px;">' + JSON.stringify(data, undefined, 2) + '</pre>');
      // Add BTC rates
      if (data.btc_rates) {
        var btcRatesData = {};
        btcRatesData.btc_rates = data.btc_rates;
        $('.messages-btc-rates').html(btcRatesTemplate(btcRatesData));
      }
      if (data.avg) {
        var avgStats = [], avgStatsData = {};
        _.each(data.avg, function (aval, akey) {
          var avgs = {};
          avgs.hrCurrentText = '-';
          avgs.hrCurrent = 0;
          avgs.hrPast = 0;
          if (aval[0]) {
            avgs.hrCurrent = parseInt(aval[0].pool_hashrate / 1000);
            avgs.hrCurrentText = convertHashrate(avgs.hrCurrent);
          }
          if (aval[1]) {
            avgs.hrPast = parseInt(aval[1].pool_hashrate / 1000);
          }
          if (avgs.hrPast > avgs.hrCurrent) {
            avgs.arrow = 'fa-chevron-down';
            avgs.color = '#f56954';
          } else if (avgs.hrPast < avgs.hrCurrent) {
            avgs.arrow = 'fa-chevron-up';
            avgs.color = '#00a65a';
          } else {
            avgs.arrow = 'fa-arrows-h';
            avgs.color = '#dddddd';
          }
          if (akey === '1min') {
            avgStatsData = {
              avgonemin: akey + ': ' + avgs.hrCurrentText,
              arrow: avgs.arrow,
              color: avgs.color
            };
          } else {
            avgStats.push({
              arrow: avgs.arrow,
              color: avgs.color,
              hrCurrentText: avgs.hrCurrentText,
              key: akey
            });
          }
        });
        avgStatsData.avgs = avgStats;
        $('.messages-avg').html(avgStatsTemplate(avgStatsData));
      }
      $('.navbar .menu').slimscroll({
        height: '200px',
        alwaysVisible: false,
        size: '3px'
      }).css('width', '100%');
      if (data.pools) {
        if (!$.fn.dataTable.isDataTable('#pools-table-details')) {
          // Initialize the pools datatable	
          $('#pools-table-details').dataTable({
            'lengthMenu': [
              5,
              10,
              25,
              50
            ],
            'pageLength': $('.app_data').data('records-per-page'),
            'stateSave': true,
            'stateSaveCallback': function (settings, data) {
            },
            'bAutoWidth': false,
            'order': [[
                3,
                'asc'
              ]],
            'fnRowCallback': function (nRow, aData, iDisplayIndex) {
              //if(iDisplayIndex === 0)
              //	nRow.className = 'bg-dark';
              return nRow;
            },
            'aoColumnDefs': [
              {
                'aTargets': [5],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash) + '</small>';
                  }
                  return data.hash;
                }
              },
              {
                'aTargets': [
                  7,
                  9,
                  11
                ],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small class="text-muted">' + data + '</small>';
                  }
                  return data;
                }
              }
            ]
          });
        }
        // Get main/active pool data
        if (data.pool) {
          var poolhashrate = data.pool.hashrate ? data.pool.hashrate : 0;
        }
        // Add pools data
        $.each(data.pools, function (pkey, pval) {
          var parser = document.createElement('a'), picon = 'download', ptype = 'failover', pclass = 'bg-light', plabel = 'light', pactivelabclass = '', paliveclass = '', palivelabel = '', puserlabel = '', pactivelab = 'Select This', purlicon = '', purl = pval.url, pshorturl = purl, pool_shares = 0;
          parser.href = pval.url;
          if (parser.hostname) {
            pshorturl = parser.hostname;
          } else {
            pshorturl = pval.url.replace('stratum+tcp://', '').split(':')[0];
          }
          if (pval.alive) {
            paliveclass = 'success';
            palivelabel = 'Alive';
          } else {
            paliveclass = 'danger';
            palivelabel = 'Dead';
          }
          puserlabel = 'blue';
          purlicon = '<i class="fa fa-flash"></i>&nbsp;';
          if (pval.user === $('.app_data').data('minera-pool-username')) {
            puserlabel = 'navy';
            purlicon = '<i class="fa fa-gift"></i>&nbsp;';
          }
          // Main pool
          if (pval.active === true || pval.active === 1) {
            pool_shares_seconds = parseFloat(now / 1000 - pval.start_time);
            pool_shares = pval.shares;
            picon = 'upload';
            ptype = 'active';
            pclass = 'bg-dark';
            plabel = 'primary';
            pactivelabclass = 'disabled';
            pactivelab = 'Selected';
            pshorturl = '<strong>' + pshorturl + '</strong>';
          }
          var pstatsId = pval.stats_id;
          var pshares = 0;
          var paccepted = 0;
          var prejected = 0;
          var psharesPrev = 0;
          var pacceptedPrev = 0;
          var prejectedPrev = 0;
          var phashData = {};
          phashData.hash = 0;
          phashData.label = 'muted';
          phashData.pstart_time = 'Never started';
          // Get the pool stats
          for (var p = 0; p < pval.stats.length; p++) {
            var pstats = pval.stats[p];
            if (pstatsId === pstats.stats_id) {
              phashData.pstart_time = new Date(pstats.start_time * 1000);
              phashData.pstart_time = phashData.pstart_time.toUTCString();
              pshares = pstats.shares;
              paccepted = pstats.accepted;
              prejected = pstats.rejected;
              // Calculate the real pool hashrate
              if (pval.active === true || pval.active === 1) {
                phashData.hash = parseInt(poolhashrate / 1000);
                //parseInt((65536.0 * (pshares/(now/1000-pstats.start_time)))/1000);
                phashData.label = 'red';
                //Add Main pool widget
                $('.widget-total-hashrate').html(convertHashrate(phashData.hash));
                $('.widget-total-hashrate').data('pool-hashrate', phashData.hash);
                $('.widget-main-pool').html(palivelabel);
                $('.widget-main-pool').next('p').html(pval.url);
                // Changing title page according to hashrate
                $(document).attr('title', 'Local: ' + convertHashrate(phashData.hash));
              }
            } else {
              psharesPrev = psharesPrev + pstats.shares;
              pacceptedPrev = pacceptedPrev + pstats.accepted;
              prejectedPrev = prejectedPrev + pstats.rejected;
            }
          }
          if ($.fn.dataTable.isDataTable('#pools-table-details')) {
            // Add Pool rows via datatable
            $('#pools-table-details').dataTable().fnAddData([
              '<button class="btn btn-xs btn-danger ' + pactivelabclass + ' remove-pool" data-pool-id="' + pkey + '"><i class="fa fa-close"></i></button>',
              '<button style="width:90px;" class="btn btn-sm btn-default ' + pactivelabclass + ' select-pool" data-pool-id="' + pkey + '"><i class="fa fa-cloud-' + picon + '"></i> ' + pactivelab + '</button>',
              purlicon + '<small data-toggle="popover" data-html="true" data-title="Priority: ' + pval.priority + '" data-content="<small>' + purl + '</small>">' + pshorturl + '</small>',
              '<span class="label label-' + plabel + '">' + ptype + '</span>',
              '<span class="label label-' + paliveclass + '">' + palivelabel + '</span>',
              phashData,
              pshares,
              psharesPrev,
              paccepted,
              pacceptedPrev,
              prejected,
              prejectedPrev,
              '<span class="badge bg-' + puserlabel + '">' + pval.user + '</span>'
            ]);
          }
        });
      } else {
        $('#pools-table-details').html('<div class="alert alert-warning"><i class="fa fa-warning"></i><strong>No active pools</strong> data available.</div>');
      }
      if (data.devices) {
        if (!$.fn.dataTable.isDataTable('#miner-table-details')) {
          // Initialize the miner datatable	
          $('#miner-table-details').dataTable({
            'lengthMenu': [
              5,
              10,
              25,
              50
            ],
            'pageLength': $('.app_data').data('records-per-page'),
            'stateSave': true,
            'bAutoWidth': false,
            'aoColumnDefs': [
              {
                'aTargets': [1],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    if (data)
                      return '<small class="label bg-blue">' + data + '&deg;</small>';
                    else
                      return '<small class="label label-muted">n.a.</small>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [2],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    if (data)
                      return '<small class="label label-light">' + data + ' MHz</small>';
                    else
                      return '<small class="label label-light">not available</small>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [3],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash) + '</small>';
                  }
                  return data.hash;
                }
              },
              {
                'aTargets': [11],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return data + ' secs ago';
                  }
                  return data;
                }
              },
              {
                'aTargets': [
                  6,
                  8,
                  10
                ],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small class="text-muted">' + data + '%</small>';
                  }
                  return data;
                }
              }
            ]
          });
        }
        // Add per device stats
        $.each(data.devices, function (key, val) {
          // these are the single devices stats
          var hashrate = Math.round(val.hashrate / 1000);
          items[key] = {
            'temp': val.temperature,
            'serial': val.serial,
            'hash': hashrate,
            'ac': val.accepted,
            're': val.rejected,
            'hw': val.hw_errors,
            'fr': val.frequency,
            'sh': val.shares,
            'ls': val.last_share
          };
          hashrates.push(hashrate);
        });
        var maxHashrate = Math.max.apply(Math, hashrates);
        var avgFr = data.totals.frequency ? data.totals.frequency : 'n.a.';
        var totTemp = data.totals.temperature ? data.totals.temperature : 'n.a.';
        totalhash = Math.round(data.totals.hashrate / 1000);
        // this is the global stats
        items.total = {
          'temp': totTemp,
          'serial': '',
          'hash': totalhash,
          'ac': data.totals.accepted,
          're': data.totals.rejected,
          'hw': data.totals.hw_errors,
          'fr': avgFr,
          'sh': data.totals.shares,
          'ls': data.totals.last_share
        };
        for (var index in items) {
          // Add per device rows in system table
          var devData = {};
          devData.hash = items[index].hash;
          var share_date = new Date(items[index].ls * 1000);
          var rightnow = new Date().getTime();
          var last_share_secs = items[index].ls > 0 ? (rightnow - share_date.getTime()) / 1000 : 0;
          if (last_share_secs < 0)
            last_share_secs = 0;
          var totalWorkedShares = parseFloat(items[index].ac) + parseFloat(items[index].re) + parseFloat(items[index].hw);
          var percentageAc = parseFloat(100 * items[index].ac / totalWorkedShares);
          var percentageRe = parseFloat(100 * items[index].re / totalWorkedShares);
          var percentageHw = parseFloat(100 * items[index].hw / totalWorkedShares);
          if (isNaN(percentageAc))
            percentageAc = 0;
          if (isNaN(percentageRe))
            percentageRe = 0;
          if (isNaN(percentageHw))
            percentageHw = 0;
          // Add colored hashrates
          if (last_share_secs >= 120 && last_share_secs < 240)
            devData.label = 'yellow';
          else if (last_share_secs >= 240 && last_share_secs < 480)
            devData.label = 'red';
          else if (last_share_secs >= 480)
            devData.label = 'muted';
          else
            devData.label = 'green';
          var dev_serial = 'serial not available';
          if (index !== 'total' && items[index].serial) {
            dev_serial = 'serial: ' + items[index].serial;
          } else {
            // Widgets
            $('.widget-last-share').html(parseInt(last_share_secs) + ' secs');
            $('.widget-hwre-rates').html(parseFloat(percentageHw).toFixed(2) + '<sup style="font-size: 20px">%</sup> / ' + parseFloat(percentageRe).toFixed(2) + '<sup style="font-size: 20px">%</sup>');
            dev_serial = '';  //Sidebar hashrate
                              //$('.sidebar-hashrate').html("@ "+convertHashrate(items[index].hash));
          }
          var devRow = '<tr class="dev-' + index + '"><td class="devs_table_name"><i class="glyphicon glyphicon-hdd"></i>&nbsp;&nbsp;' + index + dev_serial + '</td><td class="devs_table_temp">' + items[index].temp + '</td><td class="devs_table_freq">' + items[index].fr + 'MHz</td><td class="devs_table_hash"><strong>' + convertHashrate(items[index].hash) + '</strong></td><td class="devs_table_sh">' + items[index].sh + '</td><td class="devs_table_ac">' + items[index].ac + '</td><td><small class="text-muted">' + parseFloat(percentageAc).toFixed(2) + '%</small></td><td class="devs_table_re">' + items[index].re + '</td><td><small class="text-muted">' + parseFloat(percentageRe).toFixed(2) + '%</small></td><td class="devs_table_hw">' + items[index].hw + '</td><td><small class="text-muted">' + parseFloat(percentageHw).toFixed(2) + '%</small></td><td class="devs_table_ls">' + parseInt(last_share_secs) + ' secs ago</td><td><small class="text-muted">' + share_date.toUTCString() + '</small></td></tr>';
          if (index === 'total') {
            // TODO add row total via datatable
            $('.devs_table_foot').html(devRow);
          } else {
            if ($.fn.dataTable.isDataTable('#miner-table-details')) {
              // New add rows via datatable
              $('#miner-table-details').dataTable().fnAddData([
                '<span data-toggle="tooltip" title="' + dev_serial + '" data-placement="top"><i class="glyphicon glyphicon-hdd"></i>&nbsp;&nbsp;' + index + '</span>',
                items[index].temp,
                items[index].fr,
                devData,
                items[index].sh,
                items[index].ac,
                parseFloat(percentageAc).toFixed(2),
                items[index].re,
                parseFloat(percentageRe).toFixed(2),
                items[index].hw,
                parseFloat(percentageHw).toFixed(2),
                parseInt(last_share_secs),
                '<small class="text-muted">' + share_date.toUTCString() + '</small>'
              ]);
            }
          }
          if ($('.app_data').data('device-tree')) {
            // Crete Knob graph for devices and total
            createMon(index, items[index].hash, totalhash, maxHashrate, items[index].ac, items[index].re, items[index].hw, items[index].sh, items[index].fr, devData.label);
          }
        }
        $('[data-toggle="tooltip"]').tooltip();
      } else {
        var nodevsMsg = '<div class="alert alert-warning"><i class="fa fa-warning"></i>No active local devices found</div>';
        $('#miner-table-details').html(nodevsMsg);
        $('#devs').html(nodevsMsg).removeClass('row');
      }
      //******************//
      //					//
      //  Network miners  //
      //					//
      //******************//
      if (data.network_miners) {
        $('.local-miners-title').show();
        $('.network-miners-widget-section').show();
        $('.network-miner-details').show();
        var netHashrates = 0, netPoolHashrates = 0, networkMiners = [], tLastShares = [], tAc = 0, tRe = 0, tHw = 0, tSh = 0;
        //console.log(data.network_miners);
        if (Object.keys(data.network_miners).length > 0) {
          if (!$.fn.dataTable.isDataTable('#network-miner-table-details')) {
            // Initialize the miner datatable	
            $('#network-miner-table-details').dataTable({
              'lengthMenu': [
                5,
                10,
                25,
                50
              ],
              'pageLength': $('.app_data').data('records-per-page'),
              'stateSave': true,
              'bAutoWidth': false,
              'aoColumnDefs': [
                {
                  'aTargets': [1],
                  'mRender': function (data, type, full) {
                    if (type === 'display') {
                      if (data)
                        return '<small class="label bg-blue">' + data + '&deg;</small>';
                      else
                        return '<small class="label label-muted">n.a.</small>';
                    }
                    return data;
                  }
                },
                {
                  'aTargets': [2],
                  'mRender': function (data, type, full) {
                    if (type === 'display') {
                      if (data)
                        return '<small class="label label-light">' + data + ' MHz</small>';
                      else
                        return '<small class="label label-light">not available</small>';
                    }
                    return data;
                  }
                },
                {
                  'aTargets': [3],
                  'mRender': function (data, type, full) {
                    if (type === 'display') {
                      return '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash) + '</small>';
                    }
                    return data.hash;
                  }
                },
                {
                  'aTargets': [11],
                  'mRender': function (data, type, full) {
                    if (type === 'display') {
                      return data + ' secs ago';
                    }
                    return data;
                  }
                },
                {
                  'aTargets': [
                    6,
                    8,
                    10
                  ],
                  'mRender': function (data, type, full) {
                    if (type === 'display') {
                      return '<small class="text-muted">' + data + '%</small>';
                    }
                    return data;
                  }
                }
              ]
            });
          }
          $.each(data.network_miners, function (netKey, networkMinerData) {
            if (networkMinerData.devices) {
              networkMiners[netKey] = networkMinerData.devices;
              // Add per network device stats
              $.each(networkMinerData.devices, function (key, val) {
                // these are the single devices stats
                var hashrate = Math.round(val.hashrate / 1000);
                networkMiners[netKey][key] = {
                  'temp': val.temperature,
                  'serial': val.serial,
                  'hash': hashrate,
                  'ac': val.accepted,
                  're': val.rejected,
                  'hw': val.hw_errors,
                  'fr': val.frequency,
                  'sh': val.shares,
                  'ls': val.last_share
                };
                netHashrates += hashrate;
                tAc += val.accepted;
                tRe += val.rejected;
                tHw += val.hw_errors;
                tSh += val.shares;
                tLastShares.push(val.last_share);
                // this is the global stats
                networkMiners.total = {
                  'ac': tAc,
                  're': tRe,
                  'hw': tHw,
                  'sh': tSh
                };
              });
              for (var index in networkMiners[netKey]) {
                // Add per device rows in system table
                var devData = {};
                devData.hash = networkMiners[netKey][index].hash;
                var share_date = new Date(networkMiners[netKey][index].ls * 1000);
                var rightnow = new Date().getTime();
                var last_share_secs = networkMiners[netKey][index].ls > 0 ? (rightnow - share_date.getTime()) / 1000 : 0;
                if (last_share_secs < 0)
                  last_share_secs = 0;
                var totalWorkedShares = networkMiners[netKey][index].ac + networkMiners[netKey][index].re + networkMiners[netKey][index].hw;
                var percentageAc = 100 * networkMiners[netKey][index].ac / totalWorkedShares;
                var percentageRe = 100 * networkMiners[netKey][index].re / totalWorkedShares;
                var percentageHw = 100 * networkMiners[netKey][index].hw / totalWorkedShares;
                // Add colored hashrates
                if (last_share_secs >= 120 && last_share_secs < 240)
                  devData.label = 'yellow';
                else if (last_share_secs >= 240 && last_share_secs < 480)
                  devData.label = 'red';
                else if (last_share_secs >= 480)
                  devData.label = 'muted';
                else
                  devData.label = 'green';
                var dev_serial = 'serial not available';
                if (networkMiners[netKey][index].serial) {
                  dev_serial = 'serial: ' + networkMiners[netKey][index].serial;
                }
                /*
								// Widgets
								$('.widget-last-share').html(parseInt(last_share_secs) + ' secs');
								$('.widget-hwre-rates').html(parseFloat(percentageHw).toFixed(2) + '<sup style="font-size: 20px">%</sup> / ' + parseFloat(percentageRe).toFixed(2) + '<sup style="font-size: 20px">%</sup>');
								dev_serial = '';
								//Sidebar hashrate
								//$('.sidebar-hashrate').html('@ '+convertHashrate(items[index].hash));
								*/
                if ($.fn.dataTable.isDataTable('#network-miner-table-details')) {
                  // New add rows via datatable
                  $('#network-miner-table-details').dataTable().fnAddData([
                    '<span><i class="gi gi-server"></i>&nbsp;&nbsp;' + index + '<br /><span class="label label-success" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
                      networkMinerData.config.ip,
                      networkMinerData.config.port
                    ].join(':') + '">' + netKey + '</span></span>',
                    networkMiners[netKey][index].temp,
                    networkMiners[netKey][index].fr,
                    devData,
                    networkMiners[netKey][index].sh,
                    networkMiners[netKey][index].ac,
                    parseFloat(percentageAc).toFixed(2),
                    networkMiners[netKey][index].re,
                    parseFloat(percentageRe).toFixed(2),
                    networkMiners[netKey][index].hw,
                    parseFloat(percentageHw).toFixed(2),
                    parseInt(last_share_secs),
                    '<small class="text-muted">' + share_date.toUTCString() + '</small>'
                  ]);
                }
              }
              // Add network pools table
              $('.net-pools-label-' + md5(netKey)).html('<h4><span class="label label-success" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
                networkMinerData.config.ip,
                networkMinerData.config.port
              ].join(':') + '">Online</span> ' + netKey + '</h4>');
              // Get main/active network pool data
              if (networkMinerData.pool) {
                var netpoolhashrate = networkMinerData.pool.hashrate ? networkMinerData.pool.hashrate : 0;
              }
              if (networkMinerData.pools) {
                if (!$.fn.dataTable.isDataTable('#net-pools-table-details-' + md5(netKey))) {
                  // Initialize the pools datatable	
                  $('#net-pools-table-details-' + md5(netKey)).dataTable({
                    'lengthMenu': [
                      5,
                      10,
                      25,
                      50
                    ],
                    'pageLength': $('.app_data').data('records-per-page'),
                    'stateSave': true,
                    'bAutoWidth': false,
                    'order': [[
                        4,
                        'asc'
                      ]],
                    'fnRowCallback': function (nRow, aData, iDisplayIndex) {
                      //if(iDisplayIndex === 0)
                      //	nRow.className = 'bg-dark';
                      return nRow;
                    },
                    'aoColumnDefs': [
                      {
                        'aTargets': [5],
                        'mRender': function (data, type, full) {
                          if (type === 'display') {
                            return '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash) + '</small>';
                          }
                          return data.hash;
                        }
                      },
                      {
                        'aTargets': [
                          7,
                          9,
                          11
                        ],
                        'mRender': function (data, type, full) {
                          if (type === 'display') {
                            return '<small class="text-muted">' + data + '</small>';
                          }
                          return data;
                        }
                      }
                    ]
                  });
                }
                // Add pools data
                var pdonationUrl = false;
                $.each(networkMinerData.pools, function (pkey, pval) {
                  var parser = document.createElement('a'), picon = 'download', ptype = 'failover', pclass = 'bg-light', plabel = 'light', pactivelabclass = '', paliveclass = '', palivelabel = '', puserlabel = '', pactivelab = 'Select This', purlicon = '', purl = pval.url, pshorturl = purl, pool_shares = 0;
                  parser.href = pval.url;
                  if (parser.hostname) {
                    pshorturl = parser.hostname;
                  } else {
                    pshorturl = pval.url.replace('stratum+tcp://', '').split(':')[0];
                  }
                  if (pval.alive) {
                    paliveclass = 'success';
                    palivelabel = 'Alive';
                  } else {
                    paliveclass = 'danger';
                    palivelabel = 'Dead';
                  }
                  puserlabel = 'blue';
                  purlicon = '<i class="fa fa-flash"></i>&nbsp;';
                  if (pval.user === $('.app_data').data('minera-pool-username')) {
                    puserlabel = 'navy';
                    purlicon = '<i class="fa fa-gift"></i>&nbsp;';
                    pdonationUrl = true;
                    $('.net-pools-addbox-' + md5(netKey) + ' .add-net-donation-pool').fadeOut();
                  }
                  // Main pool
                  if (pval.active === true || pval.active === 1) {
                    pool_shares_seconds = parseFloat(now / 1000 - pval.start_time);
                    pool_shares = pval.shares;
                    picon = 'upload';
                    ptype = 'active';
                    pclass = 'bg-dark';
                    plabel = 'primary';
                    pactivelabclass = 'disabled';
                    pactivelab = 'Selected';
                    pshorturl = '<strong>' + pshorturl + '</strong>';
                  }
                  var pstatsId = pval.stats_id;
                  var pshares = 0;
                  var paccepted = 0;
                  var prejected = 0;
                  var psharesPrev = 0;
                  var pacceptedPrev = 0;
                  var prejectedPrev = 0;
                  var phashData = {};
                  phashData.hash = 0;
                  phashData.label = 'muted';
                  phashData.pstart_time = 'Never started';
                  // Get the pool stats
                  for (var p = 0; p < pval.stats.length; p++) {
                    var pstats = pval.stats[p];
                    if (pstatsId === pstats.stats_id) {
                      phashData.pstart_time = new Date(pstats.start_time * 1000);
                      phashData.pstart_time = phashData.pstart_time.toUTCString();
                      pshares = pstats.shares;
                      paccepted = pstats.accepted;
                      prejected = pstats.rejected;
                      // Calculate the real pool hashrate
                      if (pval.active === true || pval.active === 1) {
                        phashData.hash = parseInt(netpoolhashrate / 1000);
                        //parseInt((65536.0 * (pshares/(now/1000-pstats.start_time)))/1000);
                        phashData.label = 'red';
                        netPoolHashrates += phashData.hash;
                      }
                    } else {
                      psharesPrev = psharesPrev + pstats.shares;
                      pacceptedPrev = pacceptedPrev + pstats.accepted;
                      prejectedPrev = prejectedPrev + pstats.rejected;
                    }
                  }
                  if ($.fn.dataTable.isDataTable('#net-pools-table-details-' + md5(netKey))) {
                    pval.usershort = pval.user.length > 15 ? pval.user.substring(0, 15) + '...' : pval.user;
                    // Add Pool rows via datatable
                    $('#net-pools-table-details-' + md5(netKey)).dataTable().fnAddData([
                      '<button class="btn btn-xs btn-danger ' + pactivelabclass + ' remove-net-pool" data-pool-id="' + pkey + '" data-pool-config="' + [
                        networkMinerData.config.ip,
                        networkMinerData.config.port
                      ].join(':') + '" data-netminer="' + md5(netKey) + '"><i class="fa fa-close"></i></button>',
                      '<button style="width:90px;" class="btn btn-sm btn-default ' + pactivelabclass + ' select-net-pool" data-pool-id="' + pkey + '" data-pool-config="' + [
                        networkMinerData.config.ip,
                        networkMinerData.config.port
                      ].join(':') + '" data-netminer="' + md5(netKey) + '"><i class="fa fa-cloud-' + picon + '"></i> ' + pactivelab + '</button>',
                      purlicon + '<small data-toggle="popover" data-html="true" data-title="Priority: ' + pval.priority + '" data-content="<small>' + purl + '</small>">' + pshorturl + '</small>',
                      '<span class="label label-' + plabel + '">' + ptype + '</span>',
                      '<span class="label label-' + paliveclass + '">' + palivelabel + '</span>',
                      phashData,
                      pshares,
                      psharesPrev,
                      paccepted,
                      pacceptedPrev,
                      prejected,
                      prejectedPrev,
                      '<span class="badge bg-' + puserlabel + '" data-toggle="tooltip" title="' + pval.user + '">' + pval.usershort + '</span>'
                    ]);
                  }
                });
                if (pdonationUrl === false) {
                  $('.net-pools-addbox-' + md5(netKey) + ' .add-net-donation-pool').fadeIn();
                }
              } else {
                $('#net-pools-table-details-' + md5(netKey)).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><strong>No active pools</strong> data available.</div>');
              }
            } else {
              if ($.fn.dataTable.isDataTable('#network-miner-table-details')) {
                // New add rows via datatable
                $('#network-miner-table-details').dataTable().fnAddData([
                  '<span><i class="gi gi-server_ban"></i>&nbsp;&nbsp;Offline<br /><span class="label label-danger" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
                    networkMinerData.config.ip,
                    networkMinerData.config.port
                  ].join(':') + '">' + netKey + '</span></span>',
                  0,
                  0,
                  {
                    hash: 0,
                    label: 'muted'
                  },
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                ]);
              }
              // Add empty network pools table
              $('.net-pools-label-' + md5(netKey)).html('<h4><span class="label label-danger" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
                networkMinerData.config.ip,
                networkMinerData.config.port
              ].join(':') + '">Offline</span> ' + netKey + '</h4>');
              $('#net-pools-table-details-' + md5(netKey)).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><strong>No active pools</strong> data available.</div>');
              $('.net-pools-addbox-' + md5(netKey)).fadeOut();
            }
          });
          var tPercentageRe = 0, tPercentageHw = 0, tot_last_share_secs = 0, netDevRow;
          if (networkMiners.total !== undefined) {
            var totalShares = networkMiners.total.ac + networkMiners.total.re + networkMiners.total.hw, tPercentageAc = 100 * networkMiners.total.ac / totalShares, tot_last_share_date = Math.min.apply(Math, tLastShares) * 1000;
            tPercentageRe = 100 * networkMiners.total.re / totalShares;
            tPercentageHw = 100 * networkMiners.total.hw / totalShares;
            tot_last_share_secs = tot_last_share_date > 0 ? (new Date().getTime() - tot_last_share_date) / 1000 : 0;
            if (tot_last_share_secs < 0)
              tot_last_share_secs = 0;
            netDevRow = '<tr class="dev-total"><td class="devs_table_name"><i class="gi gi-server"></i>&nbsp;&nbsp;Total</td><td class="devs_table_temp">-</td><td class="devs_table_freq">-</td><td class="devs_table_hash"><strong>' + convertHashrate(netHashrates) + '</strong></td><td class="devs_table_sh">' + networkMiners.total.sh + '</td><td class="devs_table_ac">' + networkMiners.total.ac + '</td><td><small class="text-muted">' + parseFloat(tPercentageAc).toFixed(2) + '%</small></td><td class="devs_table_re">' + networkMiners.total.re + '</td><td><small class="text-muted">' + parseFloat(tPercentageRe).toFixed(2) + '%</small></td><td class="devs_table_hw">' + networkMiners.total.hw + '</td><td><small class="text-muted">' + parseFloat(tPercentageHw).toFixed(2) + '%</small></td><td class="devs_table_ls">' + parseInt(tot_last_share_secs) + ' secs ago</td><td><small class="text-muted">' + new Date(tot_last_share_date).toUTCString() + '</small></td></tr>';
            // Network Widgets
            $('.network-widget-last-share').html(parseInt(tot_last_share_secs) + ' secs');
            $('.network-widget-hwre-rates').html(parseFloat(tPercentageHw).toFixed(2) + '<sup style="font-size: 20px">%</sup> / ' + parseFloat(tPercentageRe).toFixed(2) + '<sup style="font-size: 20px">%</sup>');
          } else {
            netDevRow = '<tr class="dev-total"><td class="devs_table_name"><i class="gi gi-server"></i>&nbsp;&nbsp;Total</td><td class="devs_table_temp">-</td><td class="devs_table_freq">-</td><td class="devs_table_hash"><strong>-</strong></td><td class="devs_table_sh">-</td><td class="devs_table_ac">-</td><td><small class="text-muted">-</small></td><td class="devs_table_re">-</td><td><small class="text-muted">-</small></td><td class="devs_table_hw">-</td><td><small class="text-muted">-</small></td><td class="devs_table_ls">-</td><td><small class="text-muted">-</small></td></tr>';
            // Network Widgets
            $('.network-widget-last-share').html('&infin; secs');
            $('.network-widget-hwre-rates').html('Not available');
          }
          $('.network_devs_table_foot').html(netDevRow);
          //Add Network Main pool widget
          $('.network-widget-total-hashrate').html(convertHashrate(netPoolHashrates));
          $('.network-widget-total-hashrate').data('pool-hashrate', netPoolHashrates);
          // Changing title page according to hashrate
          $(document).attr('title', $(document).attr('title') + ' | Network: ' + convertHashrate(netPoolHashrates));
        } else {
          var nonetdevsMsg = '<div class="alert alert-warning"><i class="fa fa-warning"></i>No network devices found</div>';
          $('#network-miner-table-details').html(nonetdevsMsg);
          $('.network-miners-widget-section').hide();
        }
      }
      // End network miner details

			//******************    //
			//					   	//
			// GPU Network miners  //
			//					  //
			//******************//
			if (data.gpu_network_miners) {
				//$('.local-miners-title').show();
				$('.gpu-network-miners-widget-section').show();
				$('.gpu-network-miner-details').show();
				var netHashrates = 0, netPoolHashrates = 0, networkMiners = [], tLastShares = [], tAc = 0, tRe = 0, tHw = 0, tSh = 0;
				var netHashrates_2nd = 0, netPoolHashrates_2nd = 0, networkMiners_2nd = [], tLastShares_2nd = [], tAc_2nd = 0, tRe_2nd = 0, tHw_2nd = 0, tSh_2nd = 0;

				//console.log(data.gpu_network_miners);
				if (Object.keys(data.gpu_network_miners).length > 0) {
					if (!$.fn.dataTable.isDataTable('#gpu-network-miner-table-details')) {
						// Initialize the miner datatable	
						$('#gpu-network-miner-table-details').dataTable({
							'lengthMenu': [
								5,
								10,
								25,
								50
							],
							'pageLength': $('.app_data').data('records-per-page'),
							'stateSave': true,
							'bAutoWidth': false,
							'aoColumnDefs': [
								{
									'aTargets': [1],
									'mRender': function (data, type, full) {
										if (type === 'display') {
											if (data)
												return '<small class="label bg-blue">' + data + '&deg;</small>';
											else
												return '<small class="label label-muted">n.a.</small>';
										}
										return data;
									}
								},
								{
									'aTargets': [2],
									'mRender': function (data, type, full) {
										if (type === 'display') {
											var render = '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash) + '</small>';
											if (data.has_2nd) {
												render += ' / ' + '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash_2nd) + '</small>';
											}
											return render;
										}
										return data.hash;
									}
								},
								{
									'aTargets': [10],
									'mRender': function (data, type, full) {
										if (type === 'display') {
											return data + ' secs ago';
										}
										return data;
									}
								},
								{
									'aTargets': [
										5,
										7,
										9
									],
									'mRender': function (data, type, full) {
										if (type === 'display') {
											return '<small class="text-muted">' + data + '%</small>';
										}
										return data;
									}
								}
							]
						});
					}
					$.each(data.gpu_network_miners, function (netKey, networkMinerData) {
						if (networkMinerData.totals) {
							networkMiners[netKey] = networkMinerData.totals;
							// Add per network device stats
							var hashrate = Math.round(networkMinerData.totals.hashrate / 1000);
							var hashrate_2nd = Math.round(networkMinerData.totals.hashrate_2nd / 1000);
							networkMiners[netKey].hash = hashrate;
							networkMiners[netKey].hash_2nd = hashrate_2nd;


							netHashrates += hashrate;
							tAc += networkMinerData.totals.accepted;
							tRe += networkMinerData.totals.rejected;
							tHw += networkMinerData.totals.hw_errors;
							tSh += networkMinerData.totals.shares;
							netHashrates_2nd += hashrate_2nd;
							tAc_2nd += networkMinerData.totals.accepted_2nd;
							tRe_2nd += networkMinerData.totals.rejected_2nd;
							tHw_2nd += networkMinerData.totals.hw_errors_2nd;
							tLastShares.push(networkMinerData.totals.last_share);
							// this is the global stats
							networkMiners.total = {
								'ac': tAc,
								're': tRe,
								'hw': tHw,
								'sh': tSh,
								'ac_2nd': tAc_2nd,
								're_2nd': tRe_2nd,
								'hw_2nd': tHw_2nd
							};
							// Add per device rows in system table
							var totalData = {};
							totalData.hash = networkMiners[netKey].hash;
							totalData.hash_2nd = networkMiners[netKey].hash_2nd;
							totalData.has_2nd = networkMiners[netKey].has_2nd;
							var share_date = new Date(networkMiners[netKey].last_share * 1000);
							var rightnow = new Date().getTime();
							var last_share_secs = networkMiners[netKey].last_share > 0 ? (rightnow - share_date.getTime()) / 1000 : 0;
							if (last_share_secs < 0)
								last_share_secs = 0;
							var totalWorkedShares = networkMiners[netKey].accepted + networkMiners[netKey].rejected + networkMiners[netKey].hw_errors;
							var percentageAc = 100 * networkMiners[netKey].accepted / totalWorkedShares;
							var percentageRe = 100 * networkMiners[netKey].rejected / totalWorkedShares;
							var percentageHw = 100 * networkMiners[netKey].hw_errors / totalWorkedShares;
							var totalWorkedShares_2nd = networkMiners[netKey].accepted_2nd + networkMiners[netKey].rejected_2nd + networkMiners[netKey].hw_errors_2nd;
							var percentageAc_2nd = 100 * networkMiners[netKey].accepted_2nd / totalWorkedShares_2nd;
							var percentageRe_2nd = 100 * networkMiners[netKey].rejected_2nd / totalWorkedShares_2nd;
							var percentageHw_2nd = 100 * networkMiners[netKey].hw_errors_2nd / totalWorkedShares_2nd;
							var dualMining = networkMiners[netKey].has_2nd;
							// Add colored hashrates
							if (last_share_secs >= 120 && last_share_secs < 240)
								totalData.label = 'yellow';
							else if (last_share_secs >= 240 && last_share_secs < 480)
								totalData.label = 'red';
							else if (last_share_secs >= 480)
								totalData.label = 'muted';
							else
								totalData.label = 'green';
							
								console.log(networkMiners[netKey]);
							if ($.fn.dataTable.isDataTable('#gpu-network-miner-table-details')) {
								// New add rows via datatable
								$('#gpu-network-miner-table-details').dataTable().fnAddData([
									'<span><i class="gi gi-server"></i><span class="label label-success" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
										networkMinerData.config.ip,
										networkMinerData.config.port
									].join(':') + '">' + netKey + (dualMining ? ' (Dual)' : '') + '</span></span>',
									networkMiners[netKey].temperature,
									totalData,
									networkMiners[netKey].shares,
									[networkMiners[netKey].accepted, networkMiners[netKey].accepted_2nd].join(' / '),
									[parseFloat(percentageAc).toFixed(2), parseFloat(percentageAc_2nd).toFixed(2)].join(' / '),
									[networkMiners[netKey].rejected, networkMiners[netKey].rejected_2nd].join(' / '),
									[parseFloat(percentageRe).toFixed(2), parseFloat(percentageRe_2nd).toFixed(2)].join(' / '),
									[networkMiners[netKey].hw_errors, networkMiners[netKey].hw_errors_2nd].join(' / '),
									[parseFloat(percentageHw).toFixed(2), parseFloat(percentageHw_2nd).toFixed(2)].join(' / '),
									parseInt(last_share_secs),
									'<small class="text-muted">' + share_date.toUTCString() + '</small>'
								]);
							}

							// Add network pools table
							$('.gpu-net-pools-label-' + md5(netKey)).html('<h4><span class="label label-success" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
								networkMinerData.config.ip,
								networkMinerData.config.port
							].join(':') + '">Online</span> ' + netKey + '</h4>');
							// Get main/active network pool data
							if (networkMinerData.pool) {
								var netpoolhashrate = networkMinerData.pool.hashrate ? networkMinerData.pool.hashrate : 0;
								var netpoolhashrate_2nd = networkMinerData.pool.hashrate_2nd ? networkMinerData.pool.hashrate_2nd : 0;
							}
							if (networkMinerData.pools) {
								if (!$.fn.dataTable.isDataTable('#gpu-net-pools-table-details-' + md5(netKey))) {
									// Initialize the pools datatable	
									$('#gpu-net-pools-table-details-' + md5(netKey)).dataTable({
										'lengthMenu': [
											5,
											10,
											25,
											50
										],
										'pageLength': $('.app_data').data('records-per-page'),
										'stateSave': true,
										'bAutoWidth': false,
										'order': [[
											4,
											'asc'
										]],
										'fnRowCallback': function (nRow, aData, iDisplayIndex) {
											//if(iDisplayIndex === 0)
											//	nRow.className = 'bg-dark';
											return nRow;
										},
										'aoColumnDefs': [
											{
												'aTargets': [5],
												'mRender': function (data, type, full) {
													if (type === 'display') {
														return '<small class="badge bg-' + data.label + '">' + convertHashrate(data.hash) + '</small>';
													}
													return data.hash;
												}
											},
											{
												'aTargets': [
													7,
													9,
													11
												],
												'mRender': function (data, type, full) {
													if (type === 'display') {
														return '<small class="text-muted">' + data + '</small>';
													}
													return data;
												}
											}
										]
									});
								}
								// Add pools data
								var pdonationUrl = false;
								$.each(networkMinerData.pools, function (pkey, pval) {
									var parser = document.createElement('a'), picon = 'download', ptype = 'failover', pclass = 'bg-light', plabel = 'light', pactivelabclass = '', paliveclass = '', palivelabel = '', puserlabel = '', pactivelab = 'Select This', purlicon = '', purl = pval.url, pshorturl = purl, pool_shares = 0;
									parser.href = pval.url;
									if (parser.hostname) {
										pshorturl = parser.hostname;
									} else {
										pshorturl = pval.url.replace('stratum+tcp://', '').split(':')[0];
									}
									if (pval.alive) {
										paliveclass = 'success';
										palivelabel = 'Alive';
									} else {
										paliveclass = 'danger';
										palivelabel = 'Dead';
									}
									puserlabel = 'blue';
									purlicon = '<i class="fa fa-flash"></i>&nbsp;';
									if (pval.user === $('.app_data').data('minera-pool-username')) {
										puserlabel = 'navy';
										purlicon = '<i class="fa fa-gift"></i>&nbsp;';
										pdonationUrl = true;
										$('.gpu-net-pools-addbox-' + md5(netKey) + ' .add-net-donation-pool').fadeOut();
									}
									// Main pool
									if (pval.active === true || pval.active === 1) {
										pool_shares_seconds = parseFloat(now / 1000 - pval.start_time);
										pool_shares = pval.shares;
										picon = 'upload';
										ptype = 'active';
										pclass = 'bg-dark';
										plabel = 'primary';
										pactivelabclass = 'disabled';
										pactivelab = 'Selected';
										pshorturl = '<strong>' + pshorturl + '</strong>';
									}
									var pstatsId = pval.stats_id;
									var pshares = 0;
									var paccepted = 0;
									var prejected = 0;
									var psharesPrev = 0;
									var pacceptedPrev = 0;
									var prejectedPrev = 0;
									var phashData = {};
									phashData.hash = 0;
									phashData.label = 'muted';
									phashData.pstart_time = 'Never started';
									// Get the pool stats
									for (var p = 0; p < pval.stats.length; p++) {
										var pstats = pval.stats[p];
										if (pstatsId === pstats.stats_id) {
											phashData.pstart_time = new Date(pstats.start_time * 1000);
											phashData.pstart_time = phashData.pstart_time.toUTCString();
											pshares = pstats.shares;
											paccepted = pstats.accepted;
											prejected = pstats.rejected;
											// Calculate the real pool hashrate
											if (pval.active === true || pval.active === 1) {
												phashData.hash = parseInt(netpoolhashrate / 1000); //parseInt((65536.0 * (pshares/(now/1000-pstats.start_time)))/1000);
												phashData.hash_2nd = parseInt(netpoolhashrate_2nd / 1000);
												phashData.label = 'red';
												netPoolHashrates += phashData.hash;
												netPoolHashrates_2nd += phashData.hash_2nd;
											}
										} else {
											psharesPrev = psharesPrev + pstats.shares;
											pacceptedPrev = pacceptedPrev + pstats.accepted;
											prejectedPrev = prejectedPrev + pstats.rejected;
										}
									}
									if ($.fn.dataTable.isDataTable('#gpu-net-pools-table-details-' + md5(netKey))) {
										pval.usershort = pval.user.length > 15 ? pval.user.substring(0, 15) + '...' : pval.user;
										// Add Pool rows via datatable
										$('#gpu-net-pools-table-details-' + md5(netKey)).dataTable().fnAddData([
											'<button class="btn btn-xs btn-danger ' + pactivelabclass + ' remove-gpu-net-pool" data-pool-id="' + pkey + '" data-pool-config="' + [
												networkMinerData.config.ip,
												networkMinerData.config.port
											].join(':') + '" data-netminer="' + md5(netKey) + '"><i class="fa fa-close"></i></button>',
											'<button style="width:90px;" class="btn btn-sm btn-default ' + pactivelabclass + ' select-net-pool" data-pool-id="' + pkey + '" data-pool-config="' + [
												networkMinerData.config.ip,
												networkMinerData.config.port
											].join(':') + '" data-netminer="' + md5(netKey) + '"><i class="fa fa-cloud-' + picon + '"></i> ' + pactivelab + '</button>',
											purlicon + '<small data-toggle="popover" data-html="true" data-title="Priority: ' + pval.priority + '" data-content="<small>' + purl + '</small>">' + pshorturl + '</small>',
											'<span class="label label-' + plabel + '">' + ptype + '</span>',
											'<span class="label label-' + paliveclass + '">' + palivelabel + '</span>',
											phashData,
											pshares,
											psharesPrev,
											paccepted,
											pacceptedPrev,
											prejected,
											prejectedPrev,
											'<span class="badge bg-' + puserlabel + '" data-toggle="tooltip" title="' + pval.user + '">' + pval.usershort + '</span>'
										]);
									}
								});
								if (pdonationUrl === false) {
									// $('.net-pools-addbox-' + md5(netKey) + ' .add-net-donation-pool').fadeIn();
								}
							} else {
								$('#gpu-net-pools-table-details-' + md5(netKey)).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><strong>No active pools</strong> data available.</div>');
							}
						} else {
							if ($.fn.dataTable.isDataTable('#gpu-network-miner-table-details')) {
								// New add rows via datatable
								$('#gpu-network-miner-table-details').dataTable().fnAddData([
									'<span><i class="gi gi-server_ban"></i>&nbsp;&nbsp;Offline<br /><span class="label label-danger" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
										networkMinerData.config.ip,
										networkMinerData.config.port
									].join(':') + '">' + netKey + '</span></span>',
									0,
									{
										hash: 0,
										label: 'muted'
									},
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									0
								]);
							}
							// Add empty network pools table
							$('.gpu-net-pools-label-' + md5(netKey)).html('<h4><span class="label label-danger" data-toggle="popover" data-title="' + netKey + '" data-content="' + [
								networkMinerData.config.ip,
								networkMinerData.config.port
							].join(':') + '">Offline</span> ' + netKey + '</h4>');
							$('#gpu-net-pools-table-details-' + md5(netKey)).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><strong>No active pools</strong> data available.</div>');
							$('.gpu-net-pools-addbox-' + md5(netKey)).fadeOut();
						}
					});
					var tPercentageRe = 0, tPercentageHw = 0, tot_last_share_secs = 0, netTotalRow;
					var tPercentageRe_2nd = 0, tPercentageHw_2nd = 0;
					if (networkMiners.total !== undefined) {
						var totalShares = networkMiners.total.ac + networkMiners.total.re + networkMiners.total.hw, tPercentageAc = 100 * networkMiners.total.ac / totalShares, tot_last_share_date = Math.min.apply(Math, tLastShares) * 1000;
						var totalShares_2nd = networkMiners.total.ac_2nd + networkMiners.total.re_2nd + networkMiners.total.hw_2nd, tPercentageAc_2nd = 100 * networkMiners.total.ac_2nd / totalShares;
						tPercentageRe = 100 * networkMiners.total.re / totalShares;
						tPercentageHw = 100 * networkMiners.total.hw / totalShares;
						tPercentageRe_2nd = 100 * networkMiners.total.re_2nd / totalShares_2nd;
						tPercentageHw_2nd = 100 * networkMiners.total.hw_2nd / totalShares_2nd;
						tot_last_share_secs = tot_last_share_date > 0 ? (new Date().getTime() - tot_last_share_date) / 1000 : 0;
						if (tot_last_share_secs < 0)
							tot_last_share_secs = 0;
						netTotalRow = '<tr class="dev-total"><td class="devs_table_name"><i class="gi gi-server"></i>&nbsp;&nbsp;Total</td><td class="devs_table_temp">-</td><td class="devs_table_hash"><strong>' + convertHashrate(netHashrates) + ' / ' + convertHashrate(netHashrates_2nd) + '</strong></td><td class="devs_table_sh">' + networkMiners.total.sh + '</td><td class="devs_table_ac">' + networkMiners.total.ac + ' / ' + networkMiners.total.ac_2nd + '</td><td><small class="text-muted">' + parseFloat(tPercentageAc).toFixed(2) + ' / ' + parseFloat(tPercentageAc_2nd).toFixed(2) + '%</small></td><td class="devs_table_re">' + networkMiners.total.re + ' / ' + networkMiners.total.re_2nd + '</td><td><small class="text-muted">' + parseFloat(tPercentageRe).toFixed(2) + ' / ' + parseFloat(tPercentageRe_2nd).toFixed(2) + '%</small></td><td class="devs_table_hw">' + networkMiners.total.hw + ' / ' + networkMiners.total.hw_2nd + '</td><td><small class="text-muted">' + parseFloat(tPercentageHw).toFixed(2) + ' / ' + parseFloat(tPercentageHw_2nd).toFixed(2) + '%</small></td><td class="devs_table_ls">' + parseInt(tot_last_share_secs) + ' secs ago</td><td><small class="text-muted">' + new Date(tot_last_share_date).toUTCString() + '</small></td></tr>';
						// Network Widgets
						$('.gpu-network-widget-last-share').html(parseInt(tot_last_share_secs) + ' secs');
						$('.gpu-network-widget-hwre-rates').html(parseFloat(tPercentageHw).toFixed(2) + '<sup style="font-size: 20px">%</sup> / ' + parseFloat(tPercentageRe).toFixed(2) + '<sup style="font-size: 20px">%</sup>' + ' | ' + parseFloat(tPercentageHw_2nd).toFixed(2) + '<sup style="font-size: 20px">%</sup> / ' + parseFloat(tPercentageRe_2nd).toFixed(2) + '<sup style="font-size: 20px">%</sup>');
					} else {
						netTotalRow = '<tr class="dev-total"><td class="devs_table_name"><i class="gi gi-server"></i>&nbsp;&nbsp;Total</td><td class="devs_table_temp">-</td><td class="devs_table_hash"><strong>-</strong></td><td class="devs_table_sh">-</td><td class="devs_table_ac">-</td><td><small class="text-muted">-</small></td><td class="devs_table_re">-</td><td><small class="text-muted">-</small></td><td class="devs_table_hw">-</td><td><small class="text-muted">-</small></td><td class="devs_table_ls">-</td><td><small class="text-muted">-</small></td></tr>';
						// Network Widgets
						$('.gpu-network-widget-last-share').html('&infin; secs');
						$('.gpu-network-widget-hwre-rates').html('Not available');
					}
					$('.gpu_network_devs_table_foot').html(netTotalRow);
					//Add Network Main pool widget
					$('.gpu-network-widget-total-hashrate').html(convertHashrate(netPoolHashrates) + ' / ' + convertHashrate(netPoolHashrates_2nd));
					$('.gpu-network-widget-total-hashrate').data('pool-hashrate', netPoolHashrates);
					$('.gpu-network-widget-total-hashrate').data('pool-hashrate-2nd', netPoolHashrates_2nd);
					// Changing title page according to hashrate
					$(document).attr('title', $(document).attr('title') + ' | Network: ' + convertHashrate(netPoolHashrates));
				} else {
					var nonetdevsMsg = '<div class="alert alert-warning"><i class="fa fa-warning"></i>No network devices found</div>';
					$('#gpu-network-miner-table-details').html(nonetdevsMsg);
					$('.gpu-network-miners-widget-section').hide();
				}
			}
			// End gpu network miner details  			

      // Add controller temperature
      if (data.temp) {
        var temp_bar = 'bg-blue', temp_text = 'It\'s cool here', sys_temp = parseFloat(data.temp.value), tempthres1, tempthres2, tempthres3, sys_temp_box;
        if (data.temp.scale === 'c') {
          tempthres1 = 40;
          tempthres2 = 60;
          tempthres3 = 75;
        } else {
          tempthres1 = 104;
          tempthres2 = 140;
          tempthres3 = 167;
        }
        if (sys_temp > tempthres1 && sys_temp < tempthres2) {
          temp_bar = 'bg-green';
          temp_text = 'I\'m warm and fine';
        } else if (sys_temp >= tempthres2 && sys_temp < tempthres3) {
          temp_bar = 'bg-yellow';
          temp_text = 'Well, it\'s going to be hot here...';
        } else if (sys_temp > tempthres3) {
          temp_bar = 'bg-red';
          temp_text = 'HEY MAN! I\'m burning! Blow blow!';
        }
        sys_temp_box = parseFloat(sys_temp).toFixed(2) + '&deg;' + $('.app_data').data('dashboard-temp');
        //<div class="progress xs progress-striped active"><div class="progress-bar progress-bar-'+temp_bar+'" role="progressbar" aria-valuenow="'+parseInt(sys_temp)+'" aria-valuemin="0" aria-valuemax="100" style="width: '+parseInt(sys_temp)+'%"></div></div>';
        $('.sys-temp-box').addClass(temp_bar);
        $('.sys-temp-footer').html(temp_text + ' <i class="fa fa-arrow-circle-right">');
        $('.widget-sys-temp').html(sys_temp_box);
      } else {
        $('.widget-sys-temp').html('N.a.');
        $('.sys-temp-footer').html('Temperature not available <i class="fa fa-arrow-circle-right">');
      }
      // Get profitability stats
      if (data.profits) {
        var btcPrice = data.btc_rates && data.btc_rates.last ? data.btc_rates.last : 0, btcEurPrice = data.btc_rates && data.btc_rates.last_eur ? data.btc_rates.last_eur : 0;
        if (!$.fn.dataTable.isDataTable('#profit-table-details')) {
          // Initialize the profit datatable	
          $('#profit-table-details').dataTable({
            'bAutoWidth': false,
            'lengthChange': false,
            'paging': false,
            'searching': false,
            'info': false,
            'stateSave': true,
            'order': [[
                6,
                'desc'
              ]],
            'aoColumnDefs': [
              {
                'aTargets': [3],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small>' + data.blocks + '</span>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [4],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return data > 0 ? '<span class="badge bg-light-blue">' + convertHashrate(data) + '</span>' : '<span class="badge badge-muted">n.a.</span>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [5],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    if (full[3].coin === 'btc') {
                      return btcPrice && btcEurPrice ? btcPrice + ' <i class="fa fa-dollar"></i> <span class="small">(' + btcEurPrice + ' <i class="fa fa-eur"></i>)' : data;
                    } else
                      return '<i class="fa fa-btc"></i> ' + data;
                  }
                  return data;
                }
              },
              {
                'aTargets': [6],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<i class="fa fa-btc"></i> <strong>' + data + '</strong>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [7],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<i class="fa fa-btc"></i> ' + data;
                  }
                  return data;
                }
              },
              {
                'aTargets': [1],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small>' + data + '</small>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [8],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small>' + data + '</small>';
                  }
                  return data;
                }
              },
              {
                'aTargets': [9],
                'mRender': function (data, type, full) {
                  if (type === 'display') {
                    return '<small class="label label-primary">' + data.toUpperCase() + '</small>';
                  }
                  return data;
                }
              }
            ]
          });
        }
        // Update datatable profit function
        var updateProfitDataTable = function (data, currentProfitData) {
          // Add profit data
          $('#profit-table-details').dataTable().fnClearTable();
          var thisHash = data.totals && data.totals.hashrate ? data.totals.hashrate / 1000 : 0;
          $('.profit_local_hashrate').html($('.profit_hashrate').val() > 0 ? $('.profit_hashrate').val() + $('.profit_unit').find('option:selected').data('profit-unit') : convertHashrate(thisHash));
          $('.profit_local_period').html($('.profit_period').find('option:selected').data('profit-period'));
          $('.profit_local_algo').html($('.profit_algo').data('profit-algo'));
          $.each(data.profits, function (coin, profit) {
            if ($.fn.dataTable.isDataTable('#profit-table-details') && !profit.error) {
              // Add profit rows via datatable
              $('#profit-table-details').dataTable().fnAddData([
                '<span class="label label-dark" data-toggle="tooltip" data-title="' + profit.coin.charAt(0).toUpperCase() + profit.coin.slice(1) + '">' + profit.symbol.toUpperCase() + '</span>',
                profit.difficulty.toFixed(2),
                profit.reward.toFixed(2),
                {
                  blocks: profit.blocks.toFixed(0),
                  max: maxProfit.symbol,
                  coin: profit.symbol
                },
                profit.networkhashps ? profit.networkhashps / 1000 : 0,
                profit.price ? profit.price.toFixed(8) : 0,
                (currentProfitData.hash * profit.btc_profitability).toFixed(8),
                profit.algo === 'scrypt' ? profit.btc_profitability.toFixed(8) : (profit.btc_profitability * 1000).toFixed(8),
                profit.algo === 'scrypt' ? profit.coin_profitability.toFixed(8) : (profit.coin_profitability * 1000).toFixed(8),
                profit.algo
              ]);
            }
          });
          maxProfit = _.max(data.profits, function (v) {
            return currentProfitData.hash * v.btc_profitability;
          });
        };
        var btc = _.filter(data.profits, function (v) {
            return v.symbol === 'btc';
          });
        btc = btc[0] ? btc[0] : 0;
        var totalHash = data.totals && data.totals.hashrate ? data.totals.hashrate : 0, selHashrate = $('.profit_hashrate').val() > 0 ? $('.profit_hashrate').val() : 0, selUnit = $('.profit_unit').val(), selPeriod = $('.profit_period').val(), currentProfitData = { hash: selHashrate > 0 ? selUnit * selHashrate * selPeriod : totalHash / 1000000 }, maxProfit = _.max(data.profits, function (v) {
            return currentProfitData.hash * v.btc_profitability;
          });
        currentProfitData.hash = data.totals && data.totals.hashrate ? data.totals.hashrate / 1000000 : currentProfitData.hash;
        if (!selHashrate)
          selHashrate = 1000000;
        updateProfitDataTable(data, currentProfitData);
        // Recalculate value when user change input elements
        $('.profit_data').change(function (e) {
          selHashrate = $('.profit_hashrate').val() > 0 ? $('.profit_hashrate').val() : 0;
          selUnit = $('.profit_unit').val();
          selPeriod = $('.profit_period').val();
          currentProfitData.hash = selHashrate > 0 ? selUnit * selHashrate * selPeriod : totalHash / 1000000;
          updateProfitDataTable(data, currentProfitData);
        });
        $('.profit_hashrate').change(function (e) {
          selHashrate = $('.profit_hashrate').val() > 0 ? $('.profit_hashrate').val() : 0;
          selUnit = $('.profit_unit').val();
          selPeriod = $('.profit_period').val();
          currentProfitData.hash = selHashrate > 0 ? selUnit * selHashrate * selPeriod : totalHash / 1000000;
          updateProfitDataTable(data, currentProfitData);
        });
        $('.profit-table-details-error').html('');
      } else {
        $('.profit-table-details-error').html('<div class="alert alert-warning"><i class="fa fa-warning"></i><strong>No coins</strong> data available, please wait and try to refresh.</div>');
      }
      // Add Miner Uptime widget
      var uptime = convertMS(now - data.start_time * 1000);
      var human_uptime = '';
      for (var ukey in uptime) {
        human_uptime = human_uptime + '' + uptime[ukey] + ukey + ' ';
      }
      $('.widget-uptime').html(human_uptime);
      $('.uptime-footer').html('Started on <strong>' + startdate.toUTCString() + '</strong>');
      // Add System Uptime
      var sysuptime = convertMS(data.sysuptime * 1000), human_sysuptime = '', llabel;
      for (var uukey in sysuptime) {
        human_sysuptime = human_sysuptime + '' + sysuptime[uukey] + uukey + ' ';
      }
      $('.sysuptime').html('System has been up for: <strong>' + human_sysuptime + '</strong>');
      // Add server load average knob graph
      $.each(data.sysload, function (lkey, lval) {
        if (lkey === 0)
          llabel = '1min';
        if (lkey === 1)
          llabel = '5min';
        if (lkey === 2)
          llabel = '15min';
        var loadBox = '<div class="col-xs-4 text-center" id="loadavg-' + lkey + '" style="border-right: 1px solid #f4f4f4"><input type="text" class="loadstep-' + lkey + '" data-width="60" data-height="60" /><div class="knob-label"><p>' + llabel + '</p></div></div>';
        $('#loadavg-' + lkey).remove();
        $('.sysload').append(loadBox);
        var lmax = 1, lcolor = 'rgb(71, 134, 81)';
        if (lval >= 0 && lval <= 1) {
          lmax = 1;
          lcolor = '#00a65a';
        } else if (lval > 1 && lval <= 5) {
          lmax = 5;
          lcolor = '#f39c12';
        } else if (lval > 5 && lval <= 10) {
          lmax = 10;
          lcolor = '#f56954';
        } else {
          lmax = lval + lval * 10 / 100;
          lcolor = '#777777';
        }
        $('.loadstep-' + lkey).knob({
          'readOnly': true,
          'fgColor': lcolor,
          'draw': function () {
            $(this.i).val(this.cv);
          }
        });
        $('.loadstep-' + lkey).trigger('configure', {
          'min': 0,
          'max': lmax,
          'step': 0.01
        });
        $({ value: 0 }).animate({ value: lval }, {
          duration: 2000,
          easing: 'swing',
          step: function () {
            $('.loadstep-' + lkey).val(this.value).trigger('change');
          }
        });
        $('.loadstep-' + lkey).css('font-size', '10px');
      });
    }
    // End if error/notrunning
    $('.overlay').hide();
    $('.loading-img').hide();
    $('.refresh-icon').removeClass('fa-spin');
  });
  // End get live stats
  /* Morris.js Charts */
  if (thisSection === 'dashboard') {
    // get Json data from stored_stats url (redis) and create the graphs
    $.getJSON(_baseUrl + '/app/api?command=history_stats&type=hourly', function (data) {
      var dataMorris = Object.keys(data).map(function (key) {
          data[key].timestamp = data[key].timestamp * 1000;
          data[key].hashrate = (data[key].hashrate / 1000 / 1000).toFixed(2);
          data[key].pool_hashrate = (data[key].pool_hashrate / 1000 / 1000).toFixed(2);
          return data[key];
        });
      var redrawGraphs = function () {
        charts.areaHash.redraw();
        charts.areaRej.redraw();
        return false;
      };
      var updateGraphs = function () {
        console.log(dataMorris);
        charts.areaHash.setData(dataMorris);
        charts.areaRej.setData(dataMorris);
        return false;
      };
      if (dataMorris.length && errorTriggered === false) {
        // Initialise new obj
        var charts = {
            areaHash: {},
            areaRej: {}
          };
        // Hashrate history graph
        charts.areaHash = new Morris.Area({
          element: 'hashrate-chart',
          resize: true,
          data: dataMorris,
          xkey: 'timestamp',
          ykeys: [
            'hashrate',
            'pool_hashrate'
          ],
          ymax: 'auto',
          postUnits: 'Mh/s',
          labels: [
            'Devices',
            'Pool'
          ],
          lineColors: [
            '#3c8dbc',
            '#00c0ef'
          ],
          lineWidth: 2,
          pointSize: 3,
          hideHover: 'auto',
          behaveLikeLine: true
        });
        // Rejected/Errors graph
        charts.areaRej = new Morris.Area({
          element: 'rehw-chart',
          resize: true,
          data: dataMorris,
          xkey: 'timestamp',
          ykeys: [
            'accepted',
            'rejected',
            'errors'
          ],
          ymax: 'auto',
          labels: [
            'Accepted',
            'Rejected',
            'Errors'
          ],
          lineColors: [
            '#00a65a',
            '#f39c12',
            '#f56954'
          ],
          lineWidth: 2,
          pointSize: 3,
          hideHover: 'auto',
          behaveLikeLine: true
        });
        $(window).resize(function () {
          redrawGraphs();
        });
        $('.sidebar-toggle').click(function () {
          redrawGraphs();
        });
      } else {
        $('.chart').css({
          'height': '100%',
          'overflow': 'visible',
          'margin-top': '10px'
        }).html('<div class="alert alert-warning"><i class="fa fa-warning"></i><b>Ops!</b> <small>No data collected, You need at least 5 minutes of data to see the chart.</small></div>');
      }  //$('.overlay').hide();
         //$('.loading-img').hide();
    });  //End get stored stats
  }
}  // End function getStats()
